# -*- coding: utf-8 -*-
"""Q_EAR_ECC_TARA_(1) (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10Dmpbic7-y0qLklhV8YxlMb34ubBGDY4
"""

import random
import math
import numpy
import matplotlib as plt
import sys
import numpy as np
import datetime

#Model
#set parameters
class Model:
    def __init__(self, n, m, dx, dy):
        # Number of Nodes(Coordinators)
        self.n = n

        # Number of Senesors
        self.m = m

        #Area dimension
        self.dx = dx
        self.dy = dy

        #Sink Motion pattern
        self.Sinkx = 0.5*self.dx
        self.Sinky = self.Sinkx

        #Initial Energy  (Joules)
        self.En = 100
        self.Ec = 200

        #Eelec = Etx = Erx
        self.ETX = 50*0.000000001
        self.ERX = 50*0.000000001

        #Transmit Amplifier types
        self.Efs = 10*0.000000000001
        self.Emp = 0.0013*0.000000000001

        #Data Aggregation Energy
        self.EDA = 5*0.000000001

        #Computation of do
        self.d0 = math.sqrt(self.Efs/self.Emp)

        #maximum number of rounds
        self.rmax = 5000

        #Data packet size
        self.DataPacketLen = 50000000000000000000

        #Hello packet size
        self.HelloPacketLen = 50000000000000000000

        #Number of Packets sended in steady-state phase
        self.NumPacket = 8

        #Redio Range
        self.RR = 35 #0.5*self.x*math.sqrt(2)

        #Number of Cluster Head
        self.NC = 10

        # Vsup
        self.Vsup = 2.7

        # Isens
        self.Isens = 25 * 10**-3

        # Tsen
        self.Tsens = 0.5 * 10**-3

        self.w1 = 1.1
        self.w2 = 1.2
        self.w3 = 1.2

        self.Niter = 0.97*10**6
        self.f = 191.42*10**6
        self.Cavg = 22*10**-12
        self.I0 = 1.196*10**-3
        self.Vt = 0.2
        self.Proc = 21.26

        self.IA = 8 * 10**-3
        self.IS = 1 * 10**-6
        self.TAN = 10**-3
        self.TACH = 10 *10**-3
        self.TranON = 2450*10**-6
        self.TranOFF = 250*10**-6
        self.TS = 299 * 10**-3
        self.TSCH = 290 * 10**-3

        self.CN = (self.TranON + self.TAN + self.TranOFF)/(self.TranON + self.TAN + self.TranOFF + self.TS)
        self.CCH = (self.TranON + self.TACH + self.TranOFF)/(self.TranON + self.TACH + self.TranOFF + self.TSCH)

        self.Vmax = 2
        self.Vmin = 0

        self.gamma = 0.4
        self.C = 3 * 10**8

        self.Pld0=10*math.log(4*math.pi*self.d0*self.f)*self.C
        self.pploss = 0.2

        self.BER = 10**-5


        self.fi = 1.79
        self.miu = 4*math.pi*10**7
        self.ro = 1040
        self.omega = 2.4
        self.eps=52.73
        self.I=0.1

class Topology:
    def __init__(self, model):
        self.xc = [random.uniform(0, model.dx) for _ in range(model.n)]
        self.yc = [random.uniform(0, model.dy) for _ in range(model.n)]

        xn = []
        yn = []
        for c in self.xc:
            for _ in range(0,model.m):
                randx = random.uniform(-0.5,0.5)
                xn.append(c+randx)

        for c in self.yc:
            for _ in range(0,model.m):
                randy = random.uniform(-0.5,0.5)
                yn.append(c+randy)
        self.xn = xn
        self.yn = yn
        self.x = self.xc + self.xn
        self.y = self.yc + self.yn



        x_=self.xc + self.xn
        y_ = self.yc + self.yn

        x_ = np.array(x_)
        x_ = x_.astype(int)
        self.x=x_

        y_ = np.array(y_)
        y_ = y_.astype(int)
        self.y=y_


        self.velX = [[random.uniform(-1,1) for _ in range(20)] for _ in range(model.n)]
        self.velY = [[random.uniform(-1,1) for _ in range(20)] for _ in range(model.n)]

        self.velX_ = [[random.uniform(-1,1) for _ in range(20)] for _ in range(model.n)]
        self.velY_ = [[random.uniform(-1,1) for _ in range(20)] for _ in range(model.n)]




        #print("self.velX", self.velX)
        #print("self.velY",self.velY)
        #print("self.x",self.x)
        #print("self.y",self.y)


    def BrownianMotion(self):
        n = 20
        dt = 1/n
        dB = 0; dC = 0
        for i in range(n):
            dB += math.sqrt(dt)*random.random();
            dC += math.sqrt(dt)*random.random();

        return dB, dC

    def RandomWalk(self, model):
        '''
        for i in range(model.n):
            v = random.random()*(model.Vmax - model.Vmin) + model.Vmin
            angle = random.random()*2*math.pi
            self.xc += v * math.cos(angle)
            self.yc += v * math.sin(angle)
        '''
        for i in range(model.n):
            ux = numpy.mean(self.velX[i])
            uy = numpy.mean(self.velY[i])

            n = 20; k = int(n/2); sx = 0;  sy = 0

            for j in range(n-k):
                sy = sy + (self.velY[i][j]-uy)*(self.velY[i][j+k]-uy)
                sx = sx + (self.velX[i][j]-ux)*(self.velX[i][j+k]-ux)

            sx = sx/n
            sy = sy/n

            self.velX[i].pop(0)
            self.velX[i].append(sx)

            self.velY[i].pop(0)
            self.velY[i].append(sy)

            u = numpy.array([ux, uy])
            vXY = numpy.array([self.velX[i][-1],self.velY[i][-1]])

            J = numpy.cov(self.velX[i],self.velY[i])
            B = self.BrownianMotion()
            dt = 1/n
            teta = random.random()*2*math.pi

            m1 = numpy.array([[-math.log1p(abs(sx)),teta],[-teta, -math.log1p(abs(sy))]])

            dv = numpy.dot(-m1,(vXY-u))*dt + numpy.dot(J,B)*dt
            self.xc[i] = abs(self.xc[i] + dv[0])
            self.yc[i] = abs(self.yc[i] + dv[1])


        xn = []
        yn = []
        for c in self.xc:
            for _ in range(0, model.m):
                randx = random.uniform(-0.5,0.5)
                xn.append(c+randx)

        for c in self.yc:
            for _ in range(0, model.m):
                randy = random.uniform(-0.5,0.5)
                yn.append(c+randy)

        self.xn = xn
        self.yn = yn
        self.x = self.xc + self.xn
        self.y = self.yc + self.yn

class Sensors:
    def __init__(self):
        self.x=0
        self.y=0
        self.df=0
        self.id=0
        self.dis2sink=0
        self.dis2ch=0
        self.MCH=0
        self.type = 'Null'
        self.E = 0
        self.SensingF = 0
        self.PowerConsumption = 0
        self.TransferingF = 0
        self.NeighbourList = []
        self.RoutingTable = []
        '''
        self.LinkReliability=[]
        self.LinkQr=[]
        self.LinkPathloss=[]
        self.LinkEnergy=[]
        '''

    def Configuration(self,  counterType):


        if (counterType == 0):

            self.type = 'ecg'
            self.priority = 100 #percent
            self.x = 2
            self.y = 9
            self.E = 3.4
            self.SensingF = 500
            self.PowerConsumption = 464 * 10**-3
            self.TransferingF = 2
            self.sleep = 0.002
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 1.23
            self.yknn = 1.79
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=3


        elif (counterType == 1):

            self.type = 'o2'
            self.priority = 80 #percent
            self.x = 3
            self.y = 9
            self.E = 3.5
            self.SensingF = 500
            self.PowerConsumption = 464 * 10**-3
            self.TransferingF = 2
            self.sleep = 0.002
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 0.75
            self.yknn = 0.41
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=4

        elif (counterType == 2):

            self.type = 'eeg'
            self.priority = 40 #percent
            self.x = 1
            self.y = 1
            self.E = 5
            self.SensingF = 20
            self.PowerConsumption = 435 * 10**-3
            self.TransferingF = 50*10**-3
            self.sleep = 0.005
            self.temperature = 0.001 # for each packet
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 1.87
            self.yknn = 0.81
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=1

        elif (counterType == 3):

            self.type = 'blood'
            self.priority = 20 #percent
            self.x = 7
            self.y = 1
            self.E = 4.9
            self.SensingF = 4
            self.PowerConsumption = 464 * 10**-3
            self.TransferingF = 250*10**-3
            self.sleep = 0.025
            self.temperature = 0.001 # for each packet
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 0.65
            self.yknn = 0.81
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=1

        elif (counterType == 4):

            self.type = 'temp'
            self.priority = 60 #percent
            self.x = 1
            self.y = 4
            self.E = 3.3
            self.SensingF = 0.2
            self.PowerConsumption = 1951 * 10**-3
            self.TransferingF = 5
            self.sleep = 0.005
            self.temperature = 0.001 # for each packet
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 1.87
            self.yknn = 0.71
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=4

        elif (counterType == 5):          #Coordinator
            self.x = 0
            self.y = 5
            self.type = 'coor'
            self.E = 100
            self.patientClass = coordiantorType
            #self.numPacket = 1524.2
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8

        else:                              #Sink

            self.type = 'sink'
            self.E = 100000

    def Sensing(self, model):
        if self.type == 'C':
            self.E = self.E - (model.w1 * model.DataPacketLen * model.Vsup * model.Isens * model.Tsens)

        else:
            self.E = self.E - self.SensingF * (model.DataPacketLen * model.Vsup * model.Isens * model.Tsens)

    def Proccessing(self,model):
        if self.type == 'C':
            self.E = self.E - self.numPacket * model.w3 * (model.DataPacketLen * model.Niter * model.Cavg * model.Vsup**2 + \
                model.DataPacketLen * model.Vsup * (model.I0 * math.e ** (model.Vsup/(model.Vt*model.Proc))) * (model.Niter/model.f))
        else:
            self.E = self.E - self.SensingF * (model.DataPacketLen * model.Niter * model.Cavg * model.Vsup**2 + \
                model.DataPacketLen * model.Vsup * (model.I0 * math.e ** (model.Vsup/(model.Vt*model.Proc))) * (model.Niter/model.f))

    def Trasient(self, model):
        pass

    def findNeighbours(self):
        return self.NeighbourList

    def Moving(self, x, y):
        self.x = x
        self.y = y

"""#Q-Learning"""

#QLearning
#def createArray():
#Initialize row, column
#define the shape of the environment (i.e., its states)
environment_rows = 11
environment_columns = 11
import numpy as np
#Create a 3D numpy array to hold the current Q-values for each state and action pair: Q(s, a)
#The array contains 11 rows and 11 columns (to match the shape of the environment), as well as a third "action" dimension.
#The "action" dimension consists of 4 layers that will allow us to keep track of the Q-values for each possible action in
#each state (see next cell for a description of possible actions).
#The value of each (state, action) pair is initialized to 0.
q_values = np.zeros((environment_rows, environment_columns, 4))

#define actions
#numeric action codes: 0 = up, 1 = right, 2 = down, 3 = left
actions = ['up', 'right', 'down', 'left', 'upleft', 'upright', 'downleft', 'downright']
#Create a 2D numpy array to hold the rewards for each state.
#The array contains 100 rows and 100 columns (to match the shape of the environment), and each value is initialized to -100.
rewards = np.full((environment_rows, environment_columns), -100.)
rewards[0, 5] = 100. #set the reward for the packaging area (i.e., the goal) to 100  # (model.Sinkx , model.Sinky)



#define aisle locations (i.e., white squares) for rows 1 through 9
aisles = {} #store locations in a dictionary
aisles[1] = [i for i in range(1, 10)]
aisles[2] = [1, 7, 9]
aisles[3] = [i for i in range(1, 8)]
aisles[3].append(9)
aisles[4] = [3, 7]
aisles[5] = [i for i in range(11)]
aisles[6] = [5]
aisles[7] = [i for i in range(1, 10)]
aisles[8] = [3, 7]
aisles[9] = [i for i in range(11)]
#set the rewards for all aisle locations (i.e., white squares)
for row_index in range(1, 10):
  for column_index in aisles[row_index]:
    rewards[row_index, column_index] = -1.
#print rewards matrix
for row in rewards:
  print(row)
#define a function that determines if the specified location is a terminal state
def is_terminal_state(current_row_index, current_column_index):
  #if the reward for this location is -1, then it is not a terminal state (i.e., it is a 'white square')
  #print('current_row_index',current_row_index)
  #print(current_row_index,current_column_index)
  if (rewards[current_row_index, current_column_index] == -1.):
    return False
  else:
    return True
#define a function that will choose a random, non-terminal starting location
def get_starting_location():
  #get a random row and column index
  current_row_index = np.random.randint(environment_rows)
  current_column_index = np.random.randint(environment_columns)
  #continue choosing random row and column indexes until a non-terminal state is identified
  #(i.e., until the chosen state is a 'white square').
  while is_terminal_state(current_row_index, current_column_index):
    current_row_index = np.random.randint(environment_rows)
    current_column_index = np.random.randint(environment_columns)
  return current_row_index, current_column_index
#define an epsilon SMO algorithm that will choose which action to take next (i.e., where to move next)
def get_next_action(current_row_index, current_column_index, epsilon):
  #if a randomly chosen value between 0 and 1 is less than epsilon,
  #then choose the most promising value from the Q-table for this state.
  if np.random.random() < epsilon:
    #if (isinstance(current_row_index, int) and isinstance(current_column_index, int)):
    return np.argmax(q_values[current_row_index, current_column_index])
  else: #choose a random action
    return np.random.randint(4)
#define a function that will get the next location based on the chosen action
def get_next_location(current_row_index, current_column_index, action_index):
  new_row_index = current_row_index
  new_column_index = current_column_index
  if actions[action_index] == 'up' and current_row_index > 0:                                 # North
    new_row_index -= 1
  elif actions[action_index] == 'right' and current_column_index < environment_columns - 1:   # East
    new_column_index += 1
  elif actions[action_index] == 'down' and current_row_index < environment_rows - 1:          # South
    new_row_index += 1
  elif actions[action_index] == 'left' and current_column_index > 0:                          # West
    new_column_index -= 1
  elif actions[action_index] == 'upleft' and current_column_index < environment_columns - 1:  # North West
    new_column_index += 1
  elif actions[action_index] == 'upright' and current_column_index > 0 :# North East
    new_column_index -= 1
  elif actions[action_index] == 'downleft' and current_column_index  > 0 :# South West
    new_column_index -= 1
  elif actions[action_index] == 'downright' and current_column_index  < environment_columns - 1:                 # South East
    new_column_index += 1
  return new_row_index, new_column_index

def cutout(seq, idx):
        """
        Remove element at `idx` from `seq`.
        TODO: error checks.
        """
        return seq[:idx] + seq[idx + 1:]

#Define a function that will get the shortest path between any location within the warehouse that
#the robot is allowed to travel and the item packaging location.
def get_shortest_path(start_row_index, start_column_index, patient, sensor):
  #return immediately if this is an invalid starting location
  if is_terminal_state(start_row_index, start_column_index) : #hub
    return []
  else: #if this is a 'legal' starting location
    current_row_index, current_column_index = start_row_index, start_column_index
    shortest_path = []
    shortest_path.append([current_row_index, current_column_index])
    #continue moving along the path until we reach the goal (i.e., the item packaging location)
    while not is_terminal_state(current_row_index, current_column_index):
      #get the best action to take
      action_index = get_next_action(current_row_index, current_column_index, 1.)
      #move to the next location on the path, and add the new location to the list
      current_row_index, current_column_index = get_next_location(current_row_index, current_column_index, action_index)
      shortest_path.append([current_row_index, current_column_index])
    if shortest_path == []:
      return null
    else:
      if patient%2==0:
        #patient is in ccu, so ecg and o2 are important sensors
        if sensor==0:
          shortest_path = cutout(shortest_path, 2)
        elif sensor==1:
          shortest_path = cutout(shortest_path, 4)
      elif patient%3==0:
        #patient is in icu, so eeg and blood are important sensors
        if sensor==2:
          shortest_path = cutout(shortest_path, 1)
        elif sensor==4:
          shortest_path = cutout(shortest_path, 3)
      elif patient%5==0:
        #patient is in general critical, so temperature is important sensors
        if sensor==3:
          shortest_path = cutout(shortest_path, 1)
      else:
          shortest_path = shortest_path
      return shortest_path

def get_shortest_path_NOMA(start_row_index, start_column_index):
  #return immediately if this is an invalid starting location
  current_row_index, current_column_index = start_row_index, start_column_index
  shortest_path = []
  shortest_path.append([current_row_index, current_column_index])
  #continue moving along the path until we reach the goal (i.e., the item packaging location)
  i=0
  while i<10:
    #get the best action to take
    action_index = get_next_action(current_row_index, current_column_index, 1.)
    #move to the next location on the path, and add the new location to the list
    current_row_index, current_column_index = get_next_location(current_row_index, current_column_index, action_index)
    shortest_path.append([current_row_index, current_column_index])
  if shortest_path == []:
    return null

  return shortest_path

def training_qlearn():
  #define training parameters
  epsilon = 0.9 #the percentage of time when we should take the best action (instead of a random action)
  discount_factor = 0.9 #discount factor for future rewards
  learning_rate = 0.9 #the rate at which the agent should learn

  #run through 1000 training episodes
  for episode in range(1000): #epoch
    #get the starting location for this episode
    row_index, column_index = get_starting_location()
    #continue taking actions (i.e., moving) until we reach a terminal state
    #(i.e., until we reach the item packaging area or crash into an item storage location)
    while not is_terminal_state(row_index, column_index):
      #choose which action to take (i.e., where to move next)
      action_index = get_next_action(row_index, column_index, epsilon)
      #perform the chosen action, and transition to the next state (i.e., move to the next location)
      old_row_index, old_column_index = row_index, column_index #store the old row and column indexes
      row_index, column_index = get_next_location(row_index, column_index, action_index)
      #receive the reward for moving to the new state, and calculate the temporal difference
      reward = rewards[row_index, column_index]
      old_q_value = q_values[old_row_index, old_column_index, action_index]
      temporal_difference = reward + (discount_factor * np.max(q_values[row_index, column_index])) - old_q_value
      #update the Q-value for the previous state and action pair
      new_q_value = old_q_value + (learning_rate * temporal_difference)
      q_values[old_row_index, old_column_index, action_index] = new_q_value
  print('Training complete!')

"""#**EOCC based on SMO**

###Energy
Optimized Congestion Control based on Temperature Aware Routing Algorithm (EOCC-TARA)

![image.png](data:image/png;base64,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)

![Screenshot from 2022-05-25 21-36-25.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgUAAAKgCAYAAAALTQ5QAAAABHNCSVQICAgIfAhkiAAAABl0RVh0U29mdHdhcmUAZ25vbWUtc2NyZWVuc2hvdO8Dvz4AACAASURBVHic7N13nFTl2fDx3zln+vbGLrDAsvS29N5FVMSGLWqM0Rg11RRjnseo70PUFDVGY0w3dmOwoqKoIFVpIr33vrC9Tzlzzv3+MTsDiChly+xyfT+fI7vDKdc5M3Jfc1dNKaUQQpyVhvrfSNO0BjmPEEKcCUdzByBES/PFBCD6+9kmBpqmoZQ6ITGQREEI0VQkKRDiKxxb0Nu2jW3bKKUIWza1Zphyf5Bif4iKYJjKYIjqkEWtaRG0bYKWwrQVCoieRQN0wGlouHUdt6GR5HSQ5DJIcTtJ8zjJ8rpJ8TjxOR0Yuo6u62iaFttAEgUhROPQpPlAiAilVGyLFv6WbVMRCLG3OsC+miD7qwMcqQsSsBRup0GS20W6102y20miy0GSK1KYuxw6bsPAodcX5tFrALZSmJZNyLIJWha1oTA1oTDVQZOqoEmZP0hNyCQUDpPkMGib6CE30U3HRDcdk7wkOg0cDkcsSdB1HZBEQQhx9iQpEKKebdtYtk1hTYA1R8rZUFrD4boQbpeL3JQEcpN9tE30ke5z43EYNHYRrIDaUJiSugCF1X72V9VSWFWLbYXpmOihICuZflkpZPrcJ9QkCCHEmZCkQJyTjq0N8IdCbCurYcmhcrZXB0nyeOiWmUyPjBQyEzw44qygDVk2hTV1bC2pZEdpFeGwSd9ULyPbppGXmoDT4cAwDEkShBCnTZICcc44tkNg2LI4VONn/v4yVhVX0TY5kf5tM8hPS8Jp6M0c6enxhy22Flew9nAZNf4Ao9qmMj43nTSPC/2YPglCCPF1JCkQ5wzbtrEsmw3FFby14zB+zcHw3Db0apOKU29ZicDJ+M0waw6X8fmBIjr6HFzRJZv8jBSpNRBCnBJJCkSrdmwzwdbicv67oxjN6WJCfjvaJfmaO7xGoxRsL61kwa5DtPcYfKNbG7KTEqRZQQjxlSQpEK2abdv4QyYvbT7A1qoQU3p0pH1yQnOH1WQUsKW4nHk7DjC5fSoXd8nB0HUMw2ju0IQQcUiSAtEqRecU2FdezZPr9tGnfQ7DO2Rzrn5BDls2H2zbR6iulh/060B6UoL0NRBCnECSAtHqKKUwTZPdlXU8sWYvl/XtSrtzqHbgq6w/XMrqvYe4e1AeGQme2HwHQggBkhSIViY6+dDBimp++/kerhrQgwyfp7nDiis7SipZvnMv9w/rQqLXI00JQogYSQpEq6GUwrIsTNPkgWXbGdI1j7y05Ca5thkK8dEbMzCDQVIzs+g9eAht2rZvkmufiWX7DuP0V3N99xwSEhKk86EQAohMwy5EqxBNCtYeqUD3JtAxLRkbmmT7z1//RFa7XC799q0c3LubkiNHsIHlC+ed0vErFs0nbKsmi3dIh2xWVwQprqmLjc4QQghj+vTp05s7CCEaQjgcJhAIMGPrIQo6dSDR7YotRtTY26L33mHXlo0MHDuBrn0HYDgcrFuxjL8/cC8du/fCm5jEpx/NZsuaVeR26UZpURGrPlnIlrVrOLB7F3/61V207ZRHbn43FFqjxwsaYdumsKiYXlmpaJomzQhCCKkpEK1DtHOh3+/nQE2QrKSEJvvWbQM3/PSX7Nu5nW+PHcLKxfNJb9uerv0GkJCcQq/Bw3jh8Udo36UbxYcPMf/dmRw+eIC/PXAfLq+P7A6d8CUlM3DcedhoTRZz2+REdlfWEgqFCIfDUlsghJClk0XLFy3MbNsmHA5j2Xb9aoRNF4M3KZnfz3iXxbNm8vjdd1JbXc2IyRejaTq608X1P7mbVYvmU7h/H4mp6eR06kxW+1xGTbkUZdtomo7D5caGo+ssNzJN0wmFLcLhMA6H/FMghJCaAtGKhMNhgsEgCcqktC6ArWiybf7bb6CAsZdeyZ2PPMn6FUuxAYXCshV/vufndB84hPw+BdhKxcr96PEKhaVUk8Z8pLqWRCsYSaQsqxnfOSFEvJCkQLQamqah6zq9vRrrDxU3afPBwT27+M+f/sCyObP5fNF8Lrn5DpxeL/66OubPfA2X18eMPz/G/p3bWbv0E7as/pzy4iJKjhxGaRqpmW14459/IWxbTRbzhsJiurlsGXkghIiRIYmixYt+hKurq6moqODAoUP8u0hx8dCBpHmbZo4C0wyh6waVJcUkpafjdLoACIdNDMOBQmEGgzjdbuywhcPpPO54y7LQNND1punst7OknK2b1jMlwaSgoACv1xsbmiiEOHdJTYFo8aLfdJ1OJ16vl/TUVM53+3l/3Rb8YQsLGn3TnS4wDFKyc9CdrtjrmsOJrWkoTcfh8aI0Hc3pPOF4DAOlG00Sa0mdn082buG8RJvU1FRcLpfMbCiEAKSjoWhFDMPA6XTi8Xho73UwtLqUt1ZtYGr/3vhczq8/wTmguLqWOWs3MkmvINWTgtfrxeFwoLeSpaOFEGdHkgLRajgcDjweDykpKaSlpVHgqMY8tI+Zn4UY26cHbVObZnbDeLW1sJi1W7cy0S4hPzuTjIwM0tLScLvdkhQIIQBJCkQromlaLDFIS0vD5XLRJxAgu66EuavqSMvtxJDOuXjOseF3lf4AS3fswVW0nyt9JkneZLKyskhJScHn88lqiUKImHPrX0fRqh07K5/P50PTNBISErBtm4utCjbuKuedwkK65nWiV7tsXI7WPYNfbTDEun2HOLx/L4OtMnKdiiRvKj6fj6SkJLxeLy6XS2oJhBAxMvpAtErRsfc1NTVUVlZSW1tLYWFhpKCsg+2udHJzc+nRtg3JTTRCoakUV9ew+eBhKgoP0DtcQZ8kFwk+LykpKWRmZuL1Rn42DENqCYQQx5GkQLRKtm1j2zaBQIDa2loCgQBFRUUEAgFqamqo9fvZY7nYig87rQ152Vl0zEzH2wI7JCqgui7A3pJS9h0uIrG6mF5agPZOG6fDQUZGBh6Ph+Tk5Nhog2hNisxRIIQ4liQFotVSSmHbNqZpEg6HKS8vp66ujoqKCqqqqvD7/QQCASpNm32al/1GIlpaG3Iy0miblkJGUgK6Fp9V62HLoqiymsLySopKS3FXldDBqqGTFsJjRJpNfD4fHo+HnJwcPB4PiYmJeDweDMOQxY+EEF9KkgLRqimlYlsoFMI0TYLBYKS2oLaWmpoaampqYq/XWYqDtoMDlpMyZwJGchoZyUlkJCeSluAjweNB1zWa6ru1AizbprrOT1lNHaVV1ZRXVUN1OW1sP7laiHYOG5eu4XK58Hg8OJ1OMjMz8fl8uN1ukpKSMAwDh8OBYRhSMyCEOClJCsQ5QSmFZVmxmoO6ujr8fn8sOQiFQgQCAUzTjCUIlmXhtxRlmotS3U2F5qLGcGN5E/H6fPg8HhLcLhI8bjxOJ26nE7fTgbN+dEOk7P3yAlihoH7Ng5BpETRNgqZJIGRSGwxSGwhSFwgSrKvFEagh2QqRRogMO0iaCuF2GMfNy+BwOHC73bjdblwuF+np6Xi93tiETtEpoKVToRDiq0hSIM450QTBsixM0yQUCmFZVixRCAQCVFZWEg6Hj1tWONp50bJtqi2owaBGGdRqBgEMgppOAANTN8BwgO4AwwBd59Dq5biTU8nI7wHKAssCK4xmWbiUhRsLt7LwYpOowiRqFomaTYJOrENgdJIhXddjIwe8Xi9JSUmxfgLR2gCPxxPbVxIBIcSpkiGJ4pwT/dYc/dPhcGDbNi6Xi4SEBEzTJDk5OZY0mKaJZVkEg5EVBcPhMKnBILZtx5IL2w5j2/bxF7JBUxpKKf62cCZZ7dtzWW7kW7tSKlKJ4Dg+pkhcDpxOb6wmwOl0YhgGbrf7uJ8Nw4g1GUR/jt6XTFsshDgTkhSIc1L023O0rV0phdPpjBXyPp8Py7KOqy3w+/2xJKGurg7btmNJQjRBOBm32w2Ax/Plwx+PTVB0XY8lA8c2D3g8ntg6BU6nM7Z/9Jhj+wtIQiCEOBOSFIhzXnRYXrQwhqMrL0ZHMBzbJyGaDBzbiTG6RUV/jzY55OTkkJycTP/+/dG0SKfA6LW/GMcXazKizQfHzisghb8QojFIUiDEV4gWzNECP/pztKbh2GTgy5KCaA2Cz+cDjs606Ih1Rjw+KYj+ebIEQRICIURjkqRAiC/xZYX1sWP7v65/rlKK2tpa7rvvPmpqavjss88wTZM9e/YA8Mwzz5Camvq1BbsU/EKIpiRJgRBn4FQK88TERGpqanjuuedir2/bto0bbriB9PT0Ro5QCCFOnwxJFKIR7d69mz59+uD3+4FIbcPKlSsZMGBAM0cmhBAnkgHMQjSizp07c/vtt8d+v+iiiyQhEELELakpEA1CPkYnd/jwYXr16kV1dTXz589n7NixzR1Siyd9LYRoHFJTIEQjy8nJ4Sc/+QmjR49mzJgxzR2OEEKclNQUiLMSHbu/8fPd7N50JDIUD/lIfVFVVRU7d21n4IDBzR1Ki6WhgQZJKV7GTOmLw+mIzSshhGgYMvpAnJXorH+bV+2lc9dOpGUmNXdIcWvU+CHNHUKr8NGbyxk4vnNsrQdpShCi4UhSIM6YUgrTNAkEAtTW1pGelUJW29TmDku0cpoGlZWVaJoWmzZaEgMhGoYkBeKsRJciNs3QCVP9CtEYlK1iy1xHP2+SFAjRMCQpEGfl2Ol8lQJlf/0xQpwNRWQdCklAhWh4khSIs3J0MaD6xYPkH2rRBKKJqBCiYUlSIBqMsqWmQDQByTuFaDQyT4FoOIovXU64Ibb1G9bwu0ens2nTejZtXs/vHp3OsuWfopRi48Z1PPPc39mwcS2PPv4b/vvai7z+5iu8+96bsXbn6FZWVsryFUtiv+/YsZXHn/w9O3duj337XPzpAl559QVqqqvPON7Fny7ggd/ee1rH7Ny1nYf/8MBJ//7RPz7E9h1bj3tty9ZNPPbEb0/Y17ZsXnj5aV7+73Mopbhv+t0cOVJ4WvGEgkHuvOv2ky4T/VXv1e49uxrtsyCEaDySFIgGo5SK1RY09Na7Zz/mLZiDpun07N6Hz1Yui/RjsCEpKYWsrGx69yxg7rzZDBs8iisuu5at27fwu0enH3eeN99+lSf+8gjKjsSa37k7huHguz/4JhUVFaA0unfthcNw4PMlnnG8+XndIgX4aRzTqUM+37/tpyf9+ztuvZPOnbqibJj94SyUDV3ze3DbLT86YV/QSE/L4kjRYZQNd//0PjIzsk8pjnnz5xDwB3A4XDxw3yPomnFa97F+4zo6tO/YaJ8FSQuEaDzSfCAaTLRfQePQuPKya3n3/bfo3q0X/QsG8d7stxk+dDSfLl3EJVOmoZTC0B31e2t0ze/OO7PeiMUUDocJBgKUlZWwY+c2uuR3ByAzI4sLJ1/CT+++g3/++SU0NAzdETvOsizmzvsAr9fHmnUr6dOrgEkTL6Surpb5i+ZSVl7KxLHnk5vbkcrKChYsnkt5eVn9M1Hs3beb1WtWUuev4xtX38jmLRsoPHyQ2rparrj0mvqHB2vXreJg4X7GjJzAm2/PYEDBYGbPeZcbr7uFzIw2vPPeG0wcdwFzF3zA2+++RnZWDpZtUVR8hCkXXMonSxZQVl6GoetMvegKDF0HBZWVFbz59gyuvPw6tmzbSOHhg2hoFJUc4bqrb2L+wo+orauhX58BuN0e7n/gbn758/sp6DuQBYs/5qYbbiUcDjNvwUeUlhUzaMBQ8vO6MuuDmbRr255Plixk/JjzGDpkJKZpoms6mqbLt3ohWiCpKRANJjr6oLG2S6ZcxXsfzCRsWiT4Evl4wYeEQia1tTV4Pb7Yt8jZH77LM8//nYf/+ADfO+ab96JP5jN+7GSuv+ZmXnzl2aPnVnDHLXeSmJjMo088dLTjZPRbt9LYsm0TCz/5mG9cdROPP/V7wmaYhx6+n8EDhjF54hS+/9NbqKvz88Dv7mX8mPMZPHAEtq3w+wM8/9LTDBk0goWffMys99/imRf+zrjRk/B5E4+Loa6ujjkff4Db5eHt996guqaaYYNH8o9/P4VhOJi/aC6lZaUMGTicdu06UNB3IFVVlcxfOAczZPLKqy9wyUXT+MczTxEIBuuTNHC5PMz6YCa1tbU4HS6mXjiNQ4cPUlpawpatmzh0+BAjh4/nib88Qn5eN7Iy23DeuAtJSkzmv6+9gG0pnvr7H2nXtgOXTb2Gu+/9MaXlZaxYuZS169dw5eXX8egTv4nUEmxYS9/e/Rv1cyCEaDySFIgGo+zGaUOObjnZbWmTlcPLM55l9IgJ9O3dn//MeI5OHfOPaW9WXHj+Jdz8zTv41S8e4Ge/vINQKISyFYs+mcf6jWuwLIvZH71DVVVl5BgVGef+2//7I8s/+5SZ77523HU1TSMtNZ2u+T3IzMjC6XBSW1fL8s+WkJ6WQZusHHxeH6vWfMauPTtITkohK7MNuq6xb/8eqqorqamp4ac/+B9GjRhPz+59uezaSSf0d8hIzwQULpebpMQkenXvS4f2naipqcLpcJKUlBwp5SMT/gIaGWlZkRoSw8G3v3kb730wE7+/DiscjuyqFC6ni6SEJJRS9O83iNVrP+PTpQv56Q//h/79BpHbrgPLli8mFAzW181raJpGYkIyLpcbZdvM+fh92rVtj8/ro2t+DzZuWkdKcho9uvYip007wlYYZSu2bt9Ety49G/VzIO0HQjQeSQpEg2nsmgJlw+WXXMML/3maAQVDuOKSa/n7v//EiKFjj/vGHd26delFeUU54bDFlu2bGTV8HFdddj3fuu67TBx3AW+/9wbKBlspbBu8ngSe/MMz/Pv5v9UnEnzhvPU1CIChOzEMg8LDhSgbfL5E2uXkUlR0mJqaGpQC21YkJaawYdNacrLb0SG3MwcPHWT8mEn87YkXePJvj1JeXn5i7PYxz/PY1xTY9b/bCqywjR3Jgzh46CDPvPB3plxwBYmJSdjR83G0HV4pKC0t5TeP3M9vp/+JmppaZrzxEqVlpYwbfT6gYduqfh4AhW1HTqCURlpaBrt270DZYBgGHXPzjosRBcFgEEN3oKFLTYEQLZT0KRANpil6h19w3iUUFR1B13TGjj6PK6Zei8vpQinF7r07MXSD2R+9Q1ZmNp99vpQ//u7vhMNhnnvpH1x28dUoFSnsOnXozKzZb9K/7yB27d7Bug2rGTF0NO1y2vP4w/+kuPjIcX0RiooO43A42btvDw7DwcFD+7n37od46u+PMWLYGC6/+Go65ubx7Rtu5ye/vI3hQ0bj99ehARdfcAVX3jCZQf2Hce8vf8OjTzzAxHGTueC8i0lISIxdZ9fuHYRCQQ4c3IdSsH3nViorywmFQhwpKiQQCLBnz05GjRhHYeEBPlm6kMqqcvwBPwBHig7z7It/x+vx8cmS+Rws3E95eRlHig5j2za7dm1nweI59O83hDXrVrJj51b69h7AMy/+DU3TqKqpYteeHXTr0pPnXvoH50+cgmEYHCw8wP/+/Nf867k/c/DQAQb0G0K7th2orKpg/4E99bUiOvMWfkS/PgOlL4EQLZiskijOmFKKqqoqamtrefPfixk9bjQZWSmNfl3bttB1AwDLtjDqf27QaygbXfv6irSwFRmu53QcXa0vZAZxOJz1HR+N417TNR1b2ZhmCJfTfcbT89q2ja4fH59lW+iajlJ27PmcirAVxmE4Ys9ScbRJ5Yvnt6wwLqf7S89j2Ra6rscaNxrLWy/OYcJ1XcjMzCQnJwdN0054FkKIMyM1BaLBKNVEMxpqeuw62jE/N/BFTum80cL32H0dDld9bEfPEX3Nru8T4HS666v0zzB27cT4NE2v7xJwes9E1w1spU54ll+MTdN0HA7XSc8dGXFAoy+dLd9ihGg8khSIhiNtvqIpSFYgRKORpEA0GFtmnBNCiBZNkgLRcFRkWKIQjUs+Y0I0FkkKRIOJDtlrTerqanC7PfWd2U6vQ2NVdSUVlWV43F4y0rMwjIbtEBkMBqjz15KWmtGg5xVCnLskKRANJjKOvHVkBZu2ruP9OTMp6DMI0wzxybL5/N//PILH7T2l47fv2srqdcvZuXsbm7as49EH/05Om3YNElttXQ0JvkS2bt/Exi3ruO7KbzfIeYUQQpIC0WBiE9m0cGXlJdz30E957i9vkZQUGWLpdLgIBAK4XV4U6rhhd9FZD6N/AsyeM5Phg8dw1aU31s84aMSezbH7nYyKja44/rzVNVW8NONffP/Wu+jbayB9eg446Xm/LK7WoDV8xoSIV5IUiAYTnRiooUWLs68786nu93U+mjeLzp26kZCQHLufCWMuQtNg0ZKPKS8vZfuuzYwYMo52bTvwwCO/4OLJV/LhvHf48e3/S1pqBhs2r8G2bdxuL/949jHu+flvSUlO46VX/0WXzt2ZM38Wkydcwmerl3DRpMtJTkrhL08/wgO/eoKH/vA/dOrQhc1b13HF1G9QXFrEpi3ruPmG77P880/4dMUCRg4bz4bNa6ipreaOb/+Uj+a/ixk2Wbvhcy6ePA2328Mf/jyd8ydM5cN57/D/7n6Ezp26neWTaRoN9T4KIU6fzPghGkxjTWtr128Ntd/XbYeLCklOTDnuNV0zCASCvDjjn0y94GpuueHHPPLn/6Ntm1zq6uqYMmkaV192E0tXLCS3bR75nbozYsg4+vYciMPhwgrbfLJ0PspWTBo7lf0H9zBy6AQSfInU1NTQKbcLR4oKSfQlk+BNZGC/YTz24NMEgkEmjL6IBF8i6zauZkj/UeS27Ui/XoPJy+1CTU01FZUVvD37NaZMupJvX/d9HvrD/9KlUw8qKsu46pIbuei8K/hs1dJGn4K6qd5vIUTjkZoC0WBsW7WKPgX5nbrzzuz/Ytsq9q3VVoqSkiLKyktQCpISU9A1HX/Aj8PhxDBcOB0uwmGL2MJQ9X0sNE1H2Yq+PQfy4by32bB5DT269sXj9kVGbBxTw6JsBZqGz5uIw3CS4E1i6YqFpKdmYlt2/bDP6H6RyYIOFR4g4K/DthVZGW2pq6vBsuz6GRMNnE4XgYC/Vbw3QojGJTUFosFEFgFq+dvE0VMIBAMs/PQjbFsRDlssXbGQpMRUHIaTvft2UVtbQ4+uffB5krDsSCJg2wrbtrFtsCyLcDhcf04by1aETJNOuV3w+/3c9q2foWzweBIoKj7M3n27qKmrwe8PoGwVO/bpF//EgL7Dqagqp6y8hLAZprauhsNFhZEkwbbpmNuFkrJiSkqKKC8vZciA0WgYWJYdics6Gldr2KRdQYjGY0yfPn16cwchWq5gMIhpmmxevY/sNu3weNyRf7Rb8GYYDiaNncqylYv4fO0yCo8cZGC/4SQnpTJs8FjmLnyP4pIirr38ZqqqKwmHTdJTs6ioLMPpcJGZkU1ZeQkOw0FiQhJ+fy1JCcm4HG6WrVzIzj3b+HT5x5RXlHLBhEuZt3g2WZk5pCSl0iazLYGAH0N30DE3n+ys9ixZMY+hA8YQDAUYPng8Bwv30y67AxWV5TgdLrrl92L44PHMWfgu5RWlXDftVopKClFKkZWZQ0VFGS6ni84du0c6HMbBMz6bbde2vXQuSMfn85GYmIimaa2qI6UQzUkWRBJn7IsLIhX0HUpKWjJAIy+J03Si/3N83f2cyn6///M9XHTeNLp27kVRcSFHig8xcsiEs46xMTTkfTe0ue8vZNI3u8qCSEI0AulTIBqMOqZPQWvLNE/1fr5qv29d/QPem/MaS1YsYGC/4QwbNK5RRms0pIa4byFEyyFJgWgw0jv8q+Vk5XLrDT87+oIthekZkYcmRKORpEA0mMaap0AIIUTTkKRANBhbagqEEKJFk6RANAhNg7079+P2uJs7lLgUDocwrRBed2Jzh9LimSETkBEHQjQGSQpEg2jXw0dFSTE1oWBk3n5pRTjO8vWfsnL1cn743Z83dygtlqZp6IZO5yGJ6LokBEI0BkkKxFlxOBy4XC6y2qaRlObF7/cjo1xPlFWYgrEB2nVJbe5QWixN0zAMg8TERNxuN06nU+YoEKKBSVIgzophGLhcLtLT0wkGg4RCIUkKvkRmZiaaptGmTZvmDqVFMwwDr9cbSwyEEA1LkgJxxjRNw+GIfIQyMzMxTRPTNCUp+BJt2rRBKUV2dnZzh9JiRScpcrlc+Hw+3G631BII0cAkKRBnxTAMdF0nLS0N27YjCwFJUnCCnJycWFJgWVasKlycnmhzQfRzJ0mBEA1LpjkWZyX68YkmA/JxOt4999zD/PnzKS8vZ//+/bRr145wOMxzzz3HhAkTmju8FieaBESTA0kKhGhYkhQI0YgWL17MhAkTsO2jEzgUFBSwatUqqSkQQsQdWUVEiEY0ZswYpk6detxrd911lyQEQoi4JDUFQjSytWvXMnToUEzTJC8vjy1btkjPeSFEXJKOhiKutMYctaCggBtuuIHnn3+eO++8E5fL1SrvU9r3hWj5pKZAxA2lFJZlxX5uTXbv3s3kyZNZtWoVycnJzR1Ogzt2NIUkB0K0XJIUiLgQHc644N017FhXGHnxi2VL9JN6uq9zkr//Kqd77Cnsv3f/Ljp1yD/9Y1vAfed2yeCCa4eg67r0lxCiBZPmA9HslFKEw2HC4TAH9xRx/rThpGUlNXdY4hQFaoPMmrGQuro6XC4XHo9HaguEaKEkKRBxwbIswuEwpmlGvn0qKVRaCoVGOGxhmiaGYcSafiQxEKLlkaRAxIVwOEwwGMTvD6AUKFtatVoKZStCwSC1tbVomobX65WEQIgWSpICETeiMyLadmQTLYOyVaRyR2a0FKLFk6RAxIVjp0lWSqHsrz9GxAelJCEQorWQpEDEHWXTJDUFITOEGQqRkJDYKOcPh8PYysbldJ31ufz+Orxe3ynvHwqF0HU9toplY7IlgROi1ZBpjkXcUbY6sebgNLadu7bzzVum8cbMGYTD4S/dZ9Pm9bz2xn/46S+/x4qVS8/qel/cgoEASinmL5rDG2+9ctbnW7tuFVd/8+LTOubNt2cwb+FHDXpfJ92kqUeIVkNqgdDtbwAAIABJREFUCkTciXQ0PPPjO3fqSlVVJQV9B6JrBral0DQNpVSsA9zLM57nhmtv5qrLr0fXtdg+R2M42oM+etyxxx8f79HXK6sqeOudV7n5xtuZNP6i45pCvnj8qZwXoGePvmhoKPvk5zj+Z8W1V94Yu/bJrnOy654uSQqEaD0kKRBxRzVAR0NV/58Nm9bx93//iRFDx/Dxgtn8+t5HCQT8bNq8jvkLPyI1JZ2lyxdhGA7WbVjFj+64i6UrFrNk2SLKK8oYPWI8S1Ys5rzxFzBr9lt848pvsWb955SWlfDb6Y/z8YIPqKgsZ/2G1fz4e3fz0oxnWL9hNQMLhrB85RJSU9O4+oobmP3R21hhizUbPuf2W37M/gN7eeW15+jXeyCLlszjkYeeIiM9sz54xWsz/0NyYgpFJYe54ZqbsWyLl/77LHPnz+bhB54kGAww64O3CAaDDBowlHZtc3nsyd/QrUsP3G4PgWCAAf0GY9s2i5bMo212O9ZuWMUTD/8TpRSvvPYc2W3asXLVUiZNnMKYkRPO/FlLTiBEqyHNByLu2PVDEs9mg0i/hG5derF12yamXfINxo8+n0WfzqNL5+50yM1j4rgLOXToAFu3b+aSi6bRq0c/Hn/q93Tu1I29+/fw8INPcdnFV7Nj5zYumnQpl1x0JZ+tWsYv7ryPg4f2U1pawr59e5g88WLClsWGTWsZOXQs+Z2707f3ADLSMykpKWbnru0sXrKAqRdNY+zI8/jNI/fTvWsvNm/dyA3X3kJBn4GsWLkkFnsgEGTmu68ysP9Qhg4ahW0rgqEQV19xA0MHjeDTZYvYs283gwcMp1fPvnwwZxb5ed3YsWsb37nph9x0w+34vAlUVlWSn9eN3Xt2cvt3fkJyUgrbtm/ho4/fJxAIMGXyZaxcvYJBBcPO6lnLSBEhWg9JCkTciRY0Z7MRbYJQ4PX6cDpcuN1ezJCJbavYXAjrN67B5XRj24pePfqyc/d2NDRSU9Jwuzw4DCcetxvDcOJ2eUjwJWLbCqfTRdgM061LT+bMm43T4SQctrEjXfGxbYWuGaBg0+b1GLqBbSt6dOvDrj07QGkk+BLRdQPPMXFFz/2NK7/N9bdcytIVi1G2wuv2YugO3G4voWCQvI5dWL3uc2pqarFsC9tWeDxefN4EvB4fum7UNw/oJCUmgyJyHdOkR7c+bN66kQMH95PXMR+nw3VWz1qaD4RoPSQpEHFH2We/2bYd2ayj32aPHe5o2zaWZVPQZxArPl+CFbYpLS1l1LDxkcLOsuv3A/uYtvlj2+nDls0f/vwQkydOxbYVtbU1WGGbYChEZWVl5DxK0btnf9as+xwzZFJWVsqoYeOOxlN/flsdjT3gD5CelsGbL81l1uy3sKPXtusTJqX413NP0aVzd1KSUwmHLWpqao/ep320puXY6ygVqT3xuLz06NaHQ4UH+d3/PYmm6Wf5rJv7EyOEaCjG9OnTpzd3EEKEQiHC4TAbV+6hU15HXB5X/fj309/27ttNSWkxHo8XXTMoKy+lU4d8DhUeAKBNZg77DuzG6XAxqP8w3C4Pyz9bjBk2ufqKb7J95xaqa6rp0bU3xSVFlJaV0KlDZw4e2o9tK9pk5nCk6BBZGdnkZLdj/qKP6Nm9LxWV5YwZcR4rVn5Kbvs8ikuOgIIRQ8eQ3SayX3V1FTdc8x32799DZVU5eR27cPDQAQzdQfeuPQEN27aZ+e4MAgE/I4eNw7ZtyivKIvsWHsDQdUYNG8+7s9+gc8cuHD58kNx2HamoLKNtdi7JSals3b4JhxHpMuQP+OnQPo/CwwfxeRPweHy8NWsGq9eu4O33X0fXdLp16XXGzztsWuzYuoteg3Nxu92xGQ1lVkMhWh5ZJVE0O6UU1dXV+P1+ZvxtPmPHjyE5rXHmDhDw4KP3cPP1d5DbvhOlZcVs2LyWCWMmn/H5goEQH7zzMdNuG0FSUhJpaWnoui5JgRAtkIw+EHEnWpUuGsfVl93IMy/9FafTxYB+Q7lw0mVn9byl+UCI1kOSAhF3pEd74+repTf3/eLhoy+oSL+GMyUdDYVoPSQpEHEn2lFOtAzyXgnRekhSIOJOZKhbc0chTpW8V0K0HpIUiLijbIVtybfPlkKaeoRoPSQpEHHHtpCkoAVR8l4J0WpIUiDijjQftCzyXgnRekhSIOKOsqWmoCWR90qI1kOSAhF3ZD79lkXmlBCi9ZCkQMSdSE1Bc0chTpV0NBSi9ZCkQMQVh1Pj82Wr0fXWtVaXrWzWb19C7/yhOB3u5g6nQSmlMBJkrQMhWgNJCkRc0DQNXdfpNiydgD9AbV0dSkWWQG4NQmaIN/7xD4ZO7kx6ekZzh9MwNNA1DY/Hg9eXjmEYrS6ZE+JcI0mBiAu6ruNwOEhISMDhcGA4DOxW1K3dNE10Xcfj9ZCU3HoWe9I0DbfbjcfjibxvhiE1BkK0YJIUiGanaRoulwvDMMjLy8OyLMLhcHOHBUSqxoGvLei+bj/TNHG5XOTn55OXl9egMTaGU71vAMMwMAyD5ORkHA6HLJssRAsmSYGIC9GldhMTE1FKYVmtq6ehZVk4nU68Xi8pKSnNHU6D0nUdXddxOp3SfCBECydJgYgLhmEAkJSU1MyRNA7btnE6nXg8HtLS0po7nEYhtQNCtHySFIi40loLlmifCdM0W+09CiFaPqnrE6IBzZ07l0OHDp3werTfhGmazRCVEEKcGkkKhGhAb775Jj169OCuu+46ITlwOp2EQqFmikwIIb6eJAVCNLCamhr++Mc/0qNHD37+85/HkgOXyyVJgRAirkmfgjj3k5/8hJdffrm5wxCnqKam5rifH3/8cZ5++mmefvppaT4QQsQ9TUUHJIu4NG3aNIYNG8Y111zT3KGIU3DfffcxY8YMINKPoF+/fuzcuZP8/Hy2b99OSkoKbrebgQMHMnPmzGaOVgghjic1BS1AmzZt6Nq1a3OHIU5Beno6mqYxevRo7r//fs477zwmTZrEokWLAAgEAgA88cQTzRmmEEJ8KUkKhGhAgwYN4sMPP2TSpEmxiXwefPBBJk6cGJu2uV+/flx66aXNGaYQQnwp6WgoRAP67ne/y+TJk4+b2W/s2LFMnTo19vvdd9+NwyH5uBAi/si/TKLJnMvdV6ZPn87s2bPp0KED11xzzTn9LGTyJiHilyQFotEppWJb9PdzTUFBAVdddRWjRo3C4XC0urUdTkU0GYiucyGEiD+SFIhGZ1kWwUCQt59dRsBfP07/3MsL6NduMnpZCi88Nqe5Q2l69TlAbn4G4y/tj2EY0oQiRByS/ytFo1JKEQqFqKysoqYiyOU3jWvukEQzCQVN3puxiGHnd48tlS01BkLEF0kKRKOJNhmYpkltbS1o4HI7mzss0YxCZgi/34+maXg8HkD6GAgRTyQpEI3ONE3q6vzH9Ss4KlogfFV7whf3+WIh8sXXv65t4qv2O9m5T9WpHq+dwrlb130rG8JmmGAwiMvlQiklCYEQcUaSAtEklFKgIgXDF/7mVI4+xWNOtSD7qv3OtrNDQ8Rwsn1a9n0rpVCokySHQoh4IEmBaHTHFgK2FAbnLKUABbZtS1IgRJySpEA0HQWcUFMQvxSRAszQdSzbwtCNJrluQ1zrTM6hUChbHTfxUkNStiQCQsQ7mdFQNJlI1TH1W7Qa+Yu/H79VVFbw5F8f4+HHHuT1t/7LX/75J+bO//CY4079XF++35efwx8I8Kv/dxdzPp5NMBTi+3feghkOf+G6X3Wtr4vtxGNtW/H8y//m0cd/+zXn+Opzfzj3fe6+585Tvu+wZaEULFuxhL/+809fcz9nc9/N/QkUQnwdqSkQTerEauOvLimSk1LweDyYpsmVl38Dy7JZvXblSaqfz6Rt/cvjcbvcZLfJIRQK4TCcPPXHf2PoxkmrvaMvH+0393X3+eXn6ZrfnR07t9Wf78z6FPTo1psZr7/8JYXwifdthsO8/uZ/uP7amxg2eCRDBg6PFeRffT/1r57GfUuTgRDxT5IC0aRO7Gh4KrTYN+lNm9czeMAwamtree+Dt6nz19I2pz3jRk/k+ZefJjEhkZWrV9C7Z18yMzLp07s/L//3We649cdUVVexbftm2ua0Z+/+3ezes5PbbvkhS5YuYt+BvezctY0ffe8utm3fgj9Qx4rPl9E5ryvbtm/htTdf5ud33sOLrzxDRnom6zaspl+fAVx9xfXsO7CH1WtXUlpagsPp4IJJU8lp05aQGeKl/z5DUmIym7ZsoFuX7txw7c0UHjnEp0sXUlxSxKgR4+jfdyDrNqxmx65trF2/CgDbVixYPJdDhw4QDAW55Vt3oNX38N+2cws7dm5l567t3P6dH1NUfJhVqz9j09YN3Hzj7bH9lA1bt29i89aNbNm6ie/d9hMMXWfOvNkcPnKIkcPHsnrtSt7/4G26de3JwUP7CYVCXH3F9axa+xn7D+xlz77d3PiNmykpLeb1t16hd68CFn86j3vu/jVZGW1Q0UJfff0oAskJhIh/0nwgmo6KdDQ83U0pWLPuc5598Z+8PesNbKV47Mnf0adXf7557Xf46z8e51DhQaqqKvEHAvzojrsY2H8ony5bTNfOPVi/YQ1KwZEjhQwZOIKP53/I+ROmUFtby8rPV5CYmMznq1fw4+/dTVFxEavWfMYlU66kZ/feKKXIbd+RJcsX43C4qKquoqyslLvuvJcX/vM0lm3zuz/8mn59BtKvzwBWfLaUjPQsbKVwGA78fj+HDxfyi5/cy8szniMctvj1b+/hwvMv4fprvs0v7vkhxSVF/O3pP3H5JdcwasR4ULBu/RpWfr6cHt378J8Zz7F9x9bY83hlxvO0b9uR8WMmoWzFk3/9A+3bd8DpcPGXf/wxVviapsk//v1nOrTvREVlBS+98gyPPvEQo4aP4/yJU1ixchkjh42lQ24eAwuG4nF72bJtM2XlpTz7wj+4dMqVDO4/jPt+fTft23Vk3sI5jB01ge5dezF33gex90ad4vsqfQqEiH9SUyCajOIMO5spRf9+g/n2DbdxpOgwylZ8smQBt938IzRNo2+fAWzctB6X00W7nFzyOubTqUNnfv+H/2P33p3kderC62+9QtvsdowZOZGpF13Bh3NmUV1dRTgcJjExiZzsdrRv14FZs9+ibU57lK1ITkwBBQ7DgWE4QEWaFdrmtMft9qBpOrZlk9uuA1u3bcLlctO1Sw90TY/dp9vlJiUlDZfTjWE48Pvr2LhpPV6PD03TSElJZc68D3A4nKAgOTEZBazfuIYO7TuRn9eVV198nwRfYuyc1171LX5534/omt+DX9/7MAcO7ie/Uzfyb+qGw+GkoqIMpRTlFeXU1dXROa8rv/zZ/bhcbm68dRqJCclkZWaTn9eNbds31z9ihdvtAaXYtGVjrMDv27s/W7dvQtd0khKTSE1JJyUllUAgcNrvpdQUCBH/pKZANC11+puy64c0KsjOygEF3bv2YtXqFaDADIXo06sg1qENBRoa50+8mD888Rvu++VDvPfBTLIys1EK7n/gF0y9cBrpaRmYZgjbsiMFnII2WTmsWLkU21ZYlkU4HI40eXyhsx31r6Fg8MDh1NXVkZSQzA+++7PjY//Cn06Hi6SkZHbv2YmyFUkJSRT0HcjGTesIBAJYloVlWXTK7cyb78wApbF33x6Kio/EzlldVcXrL36Ax+NlyfLFVFSWs3nrBhyGk5WfL4vdS2JCEpu3buTgwQMoW7Fm7Uoy07N4/8OZBINB5i38CNCwLKu+kI/E2aF9J3bs3IoZMgkEAvTpVYCm6Sd0NDyT91EIEd+M6dOnT2/uIMTJzZgxg+7duzNo0KDmDuWM+f1+qqqqObClim798k6rLKmqqmTFqqWEQkF6de+H2+NFAYP6D+PVt16moqKCLp270a/3QFauWo5pmvTt3R9N0+nQviO6rjOgYCimGeKi8y/FMBwUHj7Eok8/JjUlnSNFh3E4nBQVH2Zg/2H07NGH5Z99widLF1Lrr8XljHzT37xtA7169I18a9Z1EuoL3H59BrJk+SLmzv+AT5ct5MOPZzFq+Hg8Xh9m2OSzz5ehlCI1JY1NW9bTt1d/xo0+j1dee57SshImjruAgr6DCIdNXp7xLP5AAL+/jssvuYYjRYd58m+PkJqcyugR41FoKGDewg/ZtXs7Pq+P8ydMYWD/oTz8+K9Z/tmnXH3FN9mzbxf7D+xl2KBR9OjWm9899v/YsnUjV1/xTQYPHM7fnn6CBZ/M5dKLriIrK4e582eTldmGI0WHqaysYMKYySQnpTB3wQcUFh7gxutupayslE1bI89g+84thEIhCvoOQtP1U34vrbDNlvU76Dk4F7fbjdfrRdM0mdVQiDiiKekSHNemTZvGJZdcwq233trcoZy26LC00tJSDuw/xLK39zP1uvHNHVaDCgT8PPqnB7n37ofQdZ0Vny8hp01bOnbo3NyhxR0zZDLzlQ+44rbhJCcnk56eLssoCxFnpE+BaDKK1jcszeFwkpGWyS/v/xFts9sxeuQEOuTmtbr7bAjySISIf5IUiKajWl/BoOsG3/vuz457rbXdY0M5s+GoQoimJEmBaEJKCoZzmNSeCBH/JCkQTSRSIEjBcO6ShFCI+CdJgWg6ZzgszbZtyspL8Hi8ABiGA2/9z+Ls7du/G19CIpnpWae0f0lpEZkZbU77OpIQChH/ZJ4C0WQiHQ1PbzNNk9dmvoTL6WHmrFe5+ftXUV5edtrnke3ErbikCKVg5+7tFBYePOXjyivK+ejjWWd0TSFEfJOaAtFEjs7HfzpefvUZBvUfRmJCMt269CQnux05bdp/4TyKmtpqHA4HHrePsGViWRYOh4NwOIymaTgdTkJmCKfTha4dzYVr/TVomobPk4BSNiEzFFku2TBwOd0ABIJ+wmGTxIQkFBAMBrBtC6/HhwJqaqrw+RJwGE5CZhClFC6nC8u2sW0rdh4A27aoqa0mISEpssASipqaKlwuN26XB1AEgn4cDhfBoJ8EXxIAdf4aNE3H6XBi2RYOhxOlFLZl4XK56lc6tAmGgnjcXjQN/P66WMxh08QMmzgcDlxON8tWLmL33h1cO+0mxow8r34CJ1DYVFdX4fX4cDpd9fEE0HUdy4rcc5e8Hnw0713yO/cgv1O3U34vpaZAiPgnSYFoOur0Cgbbtnn3g9e5/urvoFR9J8UvOcdLrz5Nh/Z5fLpsHiOGjqN92w786sEf8/STr/PYXx6gZ7c+XHvFTTz5j9/zg+/ejc/rA2DugvcwDAfvz3mTy6Zcy/pNq9m5ZxtdO/dg2WeL+Pef32Dtxs8pLjnMmvUryevYBV3TmbNgFokJSdz6rR/z3odvMGXyNJ7618OMHz2ZpMRk3pn9Gn/5w0ts3b6RNes/46br7gCgqrqSGW8+R6cO+bz13n956pHneeblv9CrewGz577F1ZfdCMADj/ySqy//FrM+fJ0H730Cv7+OXXu2U1VdSd9e/Zn/yYd0yevByKHj+OHd3+KZp97kvofupGf3vtTV1bJzzzbGj5rMnAWzuOWGH7Bu4yp27N6C1+Nj/ebV/OuJV5k7/31CZohdu3fw9ItPct7YKZw37iL+9cKfKOg9iLdnv8ptN93J1h2bePPdlxk78nxmz53JP5+YQWpKGv16D+a1t17glz954NTffulTIETck+YD0WQUkT4Fp7pVVJbjD9RhaEb9VMf15zlmnyNFh1m6YgHjRk7i9pt/xuN/fYiu+b3omNuZ8opSBhUMZ9OWdVRVVzFk4Ei8bi/KVphmmLfffxVdNyjoM4S9+3fTs1tfOrbvzPdu/jkOh5Pqmir++8azeNxeenXvx8HC/fTuUUBWRjZ/fOhp0lIy2LF7G/16DaR92450y+/NxZOvxLZtKirK2bFrC5df/I1YrG/N+i89u/Xl/PFT+fb132fz1g0cPLSf0cMm8K1rb+eJv/2Wnt364XZ7uP6q73DBxEvZvHUDhw4fYOGnHzF25CTyOnalXXYHQqEgWRnZ6JqO1+OjY25n+vYayE+/fx9FxYVcfdmNXHvFTazfvIb8zt3J69iVB3/1BMMGjWb+4g/p1aMf3bv2pkte5O+UUixdsZBQKMSoYRO4Yup1/O2Zx+jdoz+pKRncfP336dmtD/sP7kXZiuystmzYvPa03k+pKRAi/klNgWhS9ml8W7StSGESPSYyQyLH/b5j11ZqamuwbUhJSkcpG9tSXDblG8x8bwadO3blYOE+5i54n0svvDp2rBkyqagsZ9TQCYwZPonqmkpWrV2OrunYdmT+AdtSFJccYVDBCBJ8SVTXVHLg4F4cDie2DVmZbcnMaMP8xR/i8ybSu3sBGgbXXvFtnvvPX8lt14lEX0rsmuXlpZSnZKCURt+eA/lk2Tz8AT+2DW0y2+EP1KEUkWaFaAy2zbgRkwkFQ/zwFzdyz89+E2uft21QRFcf1EBpoCLHKQUakQWbsCNrLtg2dO7YHdM0cRiRBZhsG1CRpamPFB8mUB9PTlZ76upqQWlfeCY2tl1/bmWf3vspNQVCxD2pKRBN5+s6otnHb0mJqbhc7siiRAoCgQBV1RVUVVVSXlHGf15/mi55PfAH/Ozeu4N9B3Zz3ripaOiMGDyehZ/OYVDBCC6YeDn7DuzB7fLFruVyuklJTuP3T9zHux++zpr1KwmZofoFkBSmaRIOhynoPZh7H7qTDz5+mwWffIQZDhMMRlYIDAaCBAMBwpbF6GETMesXTxo/6kI+W72EAf2GH3d/o4ZN5F8vPMHHC9/n1beeZ8iAUezYtYXikiK27djMJRdcQzhsETJDKFsRNsOYpsm8xR8wZMAo7rvrYbZu30RKUirbd25m3cZVVFaWU3j4UCxey7IxTRPLUpjhcOzZlZQWYVs2e/btZOyI83E6XBw4tI99B3ZjmiFM02TEkPGsWrucqqpKtu2MxGPW90VQtiIctjBNs/58xXTv0vuE9+yr31+pKRAi3smCSHGuNS2ItH9zBXldO3DSFXO+QNM0qqoqSExIJikhmcIjB8nr2JW9B3ax/+AeMtPa0Kt7ARNGX8TSzxZimibTLvkmuqaj6wb9eg+mc8fudGzfmW75PUmqXwo5eq2xI86nuPQIib4kxo6YTFl5KelpWbhcHjLT2+DxJDB5/KWErTCBQIApk6ZRVHyYrMwcMtOzUUqx/+AeQqEg+w/u5ZNlHzNq2EQ0zSAYCjBh1IWRC9VfM6dNLl0792T33u1MnXwVaSkZjBw6gU+XzychIYkLJ15O4eEDtG/bCZ83EdBISkwmL7cL6zetQdmKKZOuJK++9iM7sy29ew6gbXYuTqcLnycB27bJbdsJnzeBYDBIemomgYCfXXu3oRQMHzyWvA5daZfTkeqaSrrl98a2bZISU+jWuRcDC0awZMVCsrPaMWbEJA4fOUR2Vjt8ngR83kR8ngTaZLZjzoJ3OH/8pWSmf2Fo4sneWxVZEGn3zt2yIJIQcUwWRIpzrWlBpE9e38uEKaNO6xyhUIi33nuJKy/5Fk6ns5EiPTMz33+FA4f2cPH5V1FTW0VpeTFOp4ttOzbRo2tfRg+f2NwhAjBn/jvs2b+T22762dfvfAqKSw7z+dplXDTpitM6LhwKM2/OPFkQSYg4Jn0KRJM63R7oToeLK6feREVFKZkZ2Y0T1Bm6ZPI1LF25kBWrPqFHl76MH3kRW3dsoGdXg5FDJ8RFb3vLCuNyeujQPh9/nT82AdTZMM0wF0684rTvT1oPhIh/khSIJnUmBaWhO8hIy46LQvZYuuZg9NBJR19Q0KNLv8iPcRKrrjkYO+KC2O8NEVdOVu4ZnSdenokQ4uQkKRBNJtJjXr4unquko6EQ8U+Sgjjy2muvMXz4cDp27NjcoTQaKRjOXZIQChH/ZEhiHHn11Vfp2bMnP/zhD9m3b19zh9PwvmTYoWzn0CY5gRBx75yoKbAsC8uymjuMr2XbNn6/n7/+9a88++yz3HLLLZSUlDR3WA1Kvi2eu5Ql770Q8e6cSAqGDBnCtm3b4n7oUyAQiP0cTQ4ALr/88uYKqcFoGvgDNSycu7i5Q2k2uw5sJiutLUkJqc0dSrNxJ+syN4EQceycSAqKiop477336NWrV3OH8pW++93vMmvWLAAMw2DatGns3buXtLS0Zo7s7BiGgcfrZuhlOVRWVraIWpvG8M9fvchVV11F3uDBzR1Kk9M0LTZhkcPhkPkJhIhT50RSAJCVlUV2dnyNc/8ij8eDYRhcddVV3HffffTr149p06Y1d1hnTdd1HA4Hbrcbt9uNbdvn5OI44XCYxMRE3G731+/cykSTApfLhWEY6Lp0ZxIiHp0zSUFLcNFFF3H//fdTUFDQ3KE0iGg1sc/nIzs7m+TkZPx+f2ymw3NRz5496du3b3OH0eQ0TcPhcOBwOEhOTsbhcEgzghBxSJKCONISpzI+FdGaAo/Hg67r51RSEA6HYz+bpklqaio+n++cKww1TcMwDAzDiDUfCCHijyQFotFFq4tdLhdeb2Sa3XMlKZg5cybXX389LpeLQCDA9df/f/bOO06Ouv7/z+293e7d7vWSS+6SS+8VkkgJoUg3ICAQQEFFBPmJIqAo4heQ8kUF5QtSlC5SpRpCSSUhl4T0cr3XvdteZn5/7O1yFxII5Fpyn+fjsbnc7sxnPjM7N/Oad70As9nM+eefz+233z7U0xs0klYBhUKREgQjTRgJBEcDQhQIBpzkzUCW5RH3hHjmmWcyevRodu3aBUBLSwtdXV1cdtllw67B02AhxIBAMHwRokAwaIzEm4FWq+W6667j6quvTr131VVXUVJSMoSzEggEgoMzsh7bBIIh4KKLLsLj8QBgs9m4+eabh3hGAoFAcHCEKBAIBhiz2ZyyFNxwww3DPjVWIBCMXIQoEAgGCFmWkSSJeDzO8uXLGTNmDNdccw3xeHzE1moQCATDGyEKBIJ+JplyKcsy4UiItGx9AAAgAElEQVSUtTuaePKjFuZd+RD/+LCerRVtxGKxPssJBALBcEAEGgoE/UDyyV+SJCKRKDtqvHy8o5V9TUFKctJYPLWYi040sa/ByzubG3nsvQrKcs3MH5dOoduMRqNJlf4VRX0EAsFQIUSBQPANSD7dJ3/GYjEqmvx8+FkTWyq95LvtzCzJ45wFNnrf34sz7RRn2olLMjtq2nlpbSNtXRXMHONkflkGHnui1LUQBwKBYCgQokAg+Jr0tgpUN3fz8fZmNu7tJMNhYfoYDydOL0Gl/PxmfjDngFKpoCzfSVm+k3A0ztbKVv76VgWhUJDZJU7mjcsg3W5MWQ9GWn0HgUAwNAhRIBB8BUm/vyRJSJJEU7ufdXs6WLe7Db1Wx/QxHq49azRatarXOoc/vlatYlqxm2nFbgLhKOX7Wrj/tf1oVRJzSl3MGO3AbtZ/QSAIK4JAIOhvhCgQCL6EpHvA6w+zekczq7a3EJdVTCl2c/mSKRh1n/8J9Ue4oEGnYc64LOaMy8LrD7NxTxN3vrgbh0nJgjI3M8Y4Meq1QhAIBIIBQYgCgaCHpABIWgR8gTDrd7ewekcb3WEFk4oyWLZoAlajrtc6Azcfq1HHokl5LJqUR4s3wMY9Tby0ZgtZdjXzxrmYPMqJQadFqVSmrAgCgUBwJAhRIBjRHCgEItE4Wyo7+Xh7C7VtIcbmuThtbhkuq6HXOoM/T5fVyMnTCjlpWiF1rd1s2N3IC6u3UZpjZt7YdEpzrKhUypRAAOFeEAgEXx8hCgQjlmSsQFyS2Lq/jQ+3NbOvMUBxtpM5ZYVkpZmh5746nCoJZLssZLssyLLM/kYvb5U38ui7+5iQb2XBuAxG5zpQ9ggCIQwEAsHXQYgCwYigdwphPB4nHo+zt76L1Ttb2VbjI8tpY9roXE6dY0vdUOXUP8MVBUUeO0UeOzFJYndNO8+vbsLrq2BKkZU5JU5y0s2oVKpUmiMIoSAQCA6NEAWCY5beFQOT5Ybr24Os2tHKxr0dpFnNTB3t5vgppah6pfwNax1wCFRKJWPzXYzNdxGJxtlW1cpjK+qJxcLMKnEyp8SF06pDoVCIOggCgeCQCFEgOCZJuQbicVo6g3y0rYlP9rSj0xmYUuzhyqVF6DSqXisM3Vz7G61axZRRbqaMcuMPRdlS0cK9r+5Dq4wxpySNuePcWE06VKrP91+IA4FAAEIUjCjWr1/P/fffz6233kppaSmRSIRnnnkGWZa58MIL0Wq1Qz3Fb0yyoJAsy8RiMTp9YdbtamXdng5ikppJRRlcfFIBRp0mtc4xpAMOiVGvYfbYLGaXZuENhCnf18Tvnt+Fw6Rg9hgHU4udmPQa1Gq1KJQkEAiEKBhJzJw5k8zMTC644ALef/997HY7JSUlKBSKo1IQHBgnEAjH+HRfOx9+1kRnQGZ8fgZnz5+A1TQ4KYTDHatRx3ET8lgwPo/WrgCb9jbxxsZdZDu1HD/ezfh8O9oe64mIPxg89u3bx/Llyxk3bhx//OMf0Wq13HzzzTgcDq699loMBsNXDyIQ9BNCFIwwioqKcLvdXHbZZbzwwgt9LvqvvvoqoVCInTt3cv3112M2m4dwpoemd5xAIBRm8/4OPvysiaYuiZLcdE6cNhan1TAsMweGBQpw2YycOK2QE6YWUN/m4+OdTfxjZRWF6TqOn+CmNMeGVqsR1oNBYNSoUdxzzz1cfvnlSJIEgNPp5Gc/+1nq71OSpD7fQVIQC9Em6G+EKBiBXH/99SxfvpzbbruNM844A4BNmzaxZs0a7rzzTh577DHuuOMO7rzzziGeaYLeIiDRjjjCrrpuVu9sY099gHy3g7kTSvCkmVIXyeGfOTBcUJDltJDltCBJo6hs8vLW5kaeXFnDxHwrs0vSKMgwodVqU+JABCj2P9OnT+e0007jd7/7HZMnT+a8885DoVAgyzJPPfUUCoWCN954g0cffZTHHnuM/Px8duzYwc9//vOhnrrgGEOIghGIUqnkL3/5C0uWLCEQCLBs2TLWrl2LyWQCEm6GF154YYhnmeDz4kIye+q8fLStma1VXWS57EwelcPiqdZUCmFi+aGa6dGPQqGg0GOn0GMnFpfYW/95iuP0Ygfzx2WkUhxlWRbCoJ+55ZZbmDVrFgUFBRQUFABQXl7Oxo0bOeWUU9Dr9WzatInnn3+e+++/n4kTJw7thAXHJEIUjDCS5kmTycQzzzzDvHnzWLZsGZMmTeL3v/89sizj9XqZP3/+oM+td4yAJEnEYjEqGxO1BDZXduGwWpk8ys1V40tQqY7uFMLhjkqlpCTXRUmui3A0zq6aVv76TjWRcIAZox3MLnHidphSAYqizPKRYzAYmDhxIoWFhan3amtryc7OZsmSJSxZsoRgMMjdd9/NDTfcwJQpU7jvvvuGcMaCYxEhCkYQzc3NdHR0sHPnTsaNG0dOTg7PPvssVquV0tJSTj31VB588EFMJhM//elPB2VOBwoBSZJo8YZYu6uNtbta0aj1TCxyc9nJJakguMQKgzI9AaBTq5hY6GZiYSLFcVtVC396swa9WmLeuHSmjbKLLo79RCwWIxaLpX6fOnUq119/PePHj8fr9TJt2jSqqqp47733OP30078QayAQHCkKWT72Da7Z2dm88847lJWVDfVUvjZnnXUWp512GsuXLx/qqfQ7vYsLtXcFWbOjmTW72ohKGiYUuhmX7+qTQigYXnj9YbZWNLGjqgWHCeaNdTFttAurSS+KI30D6uvrefnll8nMzEy5CwDWrFnDc889x6mnnsrixYt5+OGHycnJwePxMGvWrCGeteBYQ4iCYc6xJAoOrC7oC0bYuKeNtXs66PDJlOalM6Ewo08XQsHwR5ahrSvA5v1N7KtvI9elZc4YBxMKHOh1iQwGtfpzo6QQCgLB8EW4DwQDSm/NKUkS4Wic8n1tfLStmbr2KKOzXRw3qRSnZWi7EAqODKfVyOLJhSyaVEBDh4/Ve5p4btV2xmQZWVCWwdg8ByqlQrgXBIJhjhAFggGhd5nhaCzO9qoOPtzWTEVzmDx3GpPHjGKJ44AUQsHRj0JBZpqFzDQLcUmmptnLaxsaefTd/ZTlmJk3zsXobAcqlbJPDwaBQDA8EKJA0C8kRQBAPB4nFouzr7GbNTvb+Kyqm3SHlUlFBSyaakWpHLgUwn27t9FYX43T5aZ0/BRSFYyOgI62Fv7zytOc993vo9XpD7nce2/+izFjJ5JXMPqwx47H4zz92ANcdMV1KBQHDxgL+Lt5/aWnOGHpuaQ5MwCIRMK88/rzjJ88k4Kiki/dRnNTHetXrUCSJU4/+5JBuwkrFQry3Xby3YkUx/0NHTy/phF/sIZpo+zMGpNGjsuEUqkUTZoEgmGCCFsV9BuSLFPd7OOZlfv55ZNbeH5VC3ZbOpecNI3TZ5eQl2HrIwgGgpy8Im792eVkZObQH4IAwGAy8/ZrzxGNRb90ubyCYqy2tK81tlKpZOyEaaBQEgj4qa7c+4VlNFodqz54i+4ub6/1VGzeuJrmxrovHV8G/vzHWzn59GX4urzE47EvXX6gUKuUjMlxcu6CMpYtmoKktPLIu3Xc+s+tvLq2mhZvMFWcSiAQDB3CUiD42vTOGohGozR3Blm1vZmN+7yoNQYmFLpZtri4TxfCwbrWa3R6dHoDBqOZeFxia/k6ZFmieMwEzBYrkHjK3rtrK3aHi5qqvcyYuxilQklrSyO7t5eTX1RCdm4iV3z/3h20NjegUquRZYhLEtu3bMDv62LarIWpADoZ0OoMSJLcZ18b6qqpq9lPujsLtVpDMOCjYFQpu3dsISsnH7PFhk5vIBIO88ff3cDokgk40tLpaG+lpnIPRWPK8GTmYjRZ8XV7Wfnua0yduQCL1Y7ZYkPuObZNDbXs2l5O2aQZOF3u1PZ3btvErm2b2L1jM8u+92OqKnZTV1PB+EkzsdnTaGqoJRwO0lhfzfTZiwYlvU2rVjOhwM2EgkSK446aFu5+aS86VZSZo+3MLs3Abtb1adI0ENaDPXv2sGLFin4fV/A5CoWCc845B6fTOdRTERwmQhQIDoveQiAej+P1R9iwt4NV25sJRlWMy8/grAVFGPVD24UweUOW5YQ5P92dha+7i8aGGkZZEtknu3Zs4baffY8f3Xgnb778D5QqNVk5hbz83KN89/Kf8Ntffp/lP/wlne2tNDbUMHv+ibQ2NyDL8MrzjzNlxnzKN65hw9oPuOaG3wLg93Xzx99dz/e+/3OmzlwAQCQS4fl/PMSlP/h/vP3asyw6+Sx+df0lPPr8h3y88k2ycwspLZvCbTdeztOvb0ShUGKxpREIBnjwrl/y8988yI3XnMujz38IyKz+8F0kKc7fH/4Djz7/ETIKkKGmah+frv+IqbOO40eXLuWxFz9Gr08EbpqtdpQqNVa7i9Ufvk1baxPTZh3P//vh+fzuvqf424O/Q6FQkJ6RycSp89DpD+0eGQiMeg3TRmcxbXQWXn+IbZXN3PmvvaRbVSwoy2BSoR2jTj0g7oV//OMfPP3000yePLlfxhN8kZUrV5Kens5ZZ5011FMRHCZCFAi+lN7Fhbr8ITbsaePjbc10BKAkN4MTpo/vk0I41Nbf3qLA4czgnt/+lEuuvJGc/OLUZ8VjxpPmzOD4E86gqaGGpoZayjesomj0OKx2J99acg6v/+tJaqr2cvPv/0aGOwtPdj6SLLPy3VdwubPIzM4nK6cgNabRZCGvsKTPHBQKJbu2l/N/f7qDCy77CUaTBaVKBSgwma3IQF7hGExmK2qNDrPFhjPdTZrTzSVX3Uj5xtX4fd1IMoCCE5aeS17BaNatei/lNpCBFW+/jFanp3L/bs797g+IRqPodAlRkO7ORqfTk5mdz12/vpYbb3uAzOwCiksmsGHtB4waU4bF6uDUsy7qM/ehwGrUM2dcHrPH5dHWFWDj/iZeWLWNHIea4ye4mVDowKDT9lv2gizLnHrqqdx///39MX3BQVi4cKFwCR1lCFEgSHFg+qAkSfiDYT6r8rJmZxs1bREKPU7mThhLmtWY8tgPp795udfPwuJx/O6+f3LP7T8hEgmx9MyLey2j+Pxnz023uakeWQaj2YrRbMXv68Lb2U56RlZiPRm6vO2UjJuC0+Wmtnr/F/Zdlvsej1v/5zFWvPkiN1/3Xf73sf9A8nM5aX3pO3FZhvq6Kl558e/87JYHeOKvd6XWSb5MZitGkzXlOlD0lBmee9wS2tuaUaT2qa9IUiigpamerJxCjGYLRrOVjvbWPssNF5wWI8dPLOS4CQU0dvhYub2Rpz+qY0ymgbmlTsZkW9H1dHEUTZoEgv5DiAIB0Nc9EItL7Kjx8uFnTeyp95Odnsb4okIWTjX3ufAOs/sIkPDh+7o7qa7Yw/atG8nMzufUsy9Bq9On5tva0kRnZxveznZamhsI+H0sPetifnvTcqbPXsSOrRs48ztXkFc4hvvuuJ6zll1Fa3MDe3duZemZF/OjS09m6ozjmL/4NLLzigCIxaK0tTTS1Fib2k44HObJv93FhZddR8W+nWi0OiQpzr+e+Su7d27GbLEzffZiOjta6exsx+HM4L9v/os5xy9h17ZPeeeN5/B2trFl01qc6R4+WbOCxoYaZs07Eb3BRFtLI40NNXzrlHP54SUnsuOzT/Fk5XH5D29OzaG+tpLWlkZaWxq5cPkNPPvEg5gsdiLhCNNmLaT8k4/xdrYRj8d7rBjDDIUCT5oFT5oFSZKpafHy+qeNtL2f6OJ43Hg3+W4TGrU61aRJiAOB4JsjKhoOcwa6omEy4jsai7G3zsvH21vYVu3D5bAxocBDdrqtTxfC4Y63s41YNIpSpUKn09PcWItarSEnvzi1jN/nJRQMojcYCYeCQMLVEPB3UbV/NwWjSjGaLADUVu1FrdYgA56sXBQKJTVVe1EoFOTkjUqNGY/F6OxoRaVSYU9LB0CWJZob6+hsb6Fg1Fh0egMdbc34ur09T/sWJClOMODHaDKj0epob20iw5NDfW0FjrR0urs6cWVkAlC5byc6vYHs3CLi8Rid7a0olUoczgx83Z3UVu+neMx41Bptal5d3naikQgarRarLY3W5npaWxopHjMepUpFR3tLYv/T0lEqh6EoOASxuERFYzufVTThD3YzbZSduWNd5KZbUKvVhxV/cOutt9LV1SXcBwPIwoULufbaazn77LOHeiqCw0RYCkYYyTLDyZ/Vzd2s3d3Bxr0dmAwmygo8XHiCA7WqbxR6Ujl+lTw43OUOtV5vvokUsdk/j3KWgfxRY78wvslsw2S29fzf2uf9cRNn9Bkvu0dM9J5Lbi+BkUSpVpOW7umznEKhxJ2ZizszN/Wew5mBo6fWQHJOhh4BApDuyQEgKyeR/WAwmlOfFY3+XNSqVGqc6Z7U72aLndKyqV/YV8sBKZKujCxcPe4QAKfLw8EYyO/7UE8hX2cMtUrJ6GwXo7NdhKMx9tS18dd36lESYVaJk5nFDtLthpR7QVRRFAgODyEKRhBJ90AihbCJdbvaUSh1jMv3cPaCwsNKITxcs1J/mJ8GyoT1TcYV+93/Y/fXGFq1mrJ8N2X5bvyhCLtqW7jnlQrMujhzx6Yzq8SFw2IQgkAgOAyEKBjmKBQKHnroId56661vPEbSQyRJEnmLf4xfMjJ9TC5L50zu04XwmPcjCY55jHotU4qzmTwqm65AiO1VzTz/8WYKM/Rce/porGZjKjBRIBB8ESEKhjk33XQT5eXlRzRGMpMgGAySWWxj/V4v2yobiEkyJbnpmPTafqr9JxAMPTLQ6Quyo6qJPbVNpBvCTC90IMWjSJI0KAWaBIKjFSEKhjkzZ85k5syZRzRGPB5PVB5sbsbn85Gp89LW1cyuugae26bBbM9gXH4mxdku9FpxSgiOTnzBMDtrmtlZ1Ug80EKRPcqJuWosRi2ZtjjdXV3odbpUrwWBQPBFxB1gBKBQKFCpVJhMieYzwWAQtVqNzRhifCBAZ7CKvXtqWLvZgNPloSzfQ4EnDY1aXDj7k2DAzyMP3MK1v7j3sJaPx+NsWr+S1qZ6svKKmDh13gDP8OgjFImxp66FHVWN+L1N5JpDzHXKmLIU6PV6jEYjer0eq9WKwWBIZSYIBIKDI0TBCCCZmqXRaJAkCYvFgkqlQqvVolarMRiiOIwhwuFO2oNd7NxWyUebzHgyPIzLd5OTbkclTK7fmA1r3mPa7G+h0xv5zvd+etiFgj5e8RpSPMbipd9h+dnTeeSFtej0xoGd7FFANBZnf0MbO6ob6WxvJtPgZ4ItgtUBWq0Wvd6ARqNJCQKdToder0er1Yp4AoHgKxCiYASQtBQkL5IGg4FoNEosFsPn8xEKheju7sbn82GNRnFbg0SibTT52vhkw27+K9vJy8pkXL4HT5plxF5UA/5u1qx8g7R0D9FImPGT5/LpuhUE/N0s+Na36fJ2sK18DcefdDbln3yExWpHoVTywB3X8cP/dw/FYyexbct6HC43az96i6ycQjasfo+5i04nJ78Yb0cru7ZtJBT0487Kp7C4DG9nG0qlEq1Oj0KpHrHBoHFJoqa5k+1VjTQ2NZCu7WKULYqzQIlapcJgsKDVajEYDNhsNnQ6HRaLBY1Gg1qtRtfLbTBSz9/BQpIk4vF4n/9Ho4kOoxqN5stWFQwDxOPfCCEpDJIXSKPRiMViIS0tjYyMDHJycsjPz6egoIDc3FyyMj2My3OwqFjB0sJ20iI7WLX+I558azUfbdlPS6cfWepbfvdYf0UjEZ762534uryAgj/9zw1MnrEQT04Rd/ziMtLdObz4jz8RjcaQpDjvv/0ieYWlmMw2psxahK/Ly3OP30s0EuX1Fx5l66Y1FJVM5G/33YwsyfzPLVcxbuJsWprqefPfT5Cemcu4SbNZvfI/XPKDm1FrtEN+DAbzJUkyda1e3t24iyf/8yGby1eRy05OHeVlXqGKUdkOMj0ecnJyKCgoID8/n9zcXDIyMnA6nVitVkwmE3q9HrVaLQTBILFt27bUd7F27VquvPJKcnNzOf/884d6aoLDQFgKRhAHVnmTZRmVSkU8Hk+ZWGOxWMq1EAwmqv3FYjHy1WEyTUHCUR81bfW8V2UgrnNRnJNJSV4GNpNhKHdtULDYndjsLqbO+RZBv48nHvodRouNcRNnUV2xC5+vC6VKhQwoVYmneqVajUKpQKXRkJ6Zh1qtRWc04XC5GTtxFu7MXPy+LmQg4OsiFA5itbvIypPQaHtKMyuUzFt82oiwEsiyTJvXz47qJirqGjDJ7eSZgyzOlNFqVGg0mtRN3mQyYTab0el02Gw21Gp1yiWWFMDJc12IgcFj/PjxTJ06lTfeeAMAr9dLV1cX3//+94d4ZoLDQYiCEUjvC6VSqUSj0SDLMkajEVmWsVqtxONx4vE4wWCQSCSC3++nq6uLUCiEw+ZjbDSKP1xPRVM9r+/VozZlUJLrYXROBka99itmcPQik3iK1eoMeDtaCQWDaLRaHE43Wr0RBQokSSIWiyFLcq+n3s/rRchyYqDeDZFkFJx+/vfZsPo99AYTZ5z//Z7lZIrHTkktd6zi9QXZWdPE3poG1NE2CqwhTsgGg06DWm3GbDaj1+sxm80pt4DBkIgdUKkSYqG/WysLvhkKhYJf/epXvPnmm0iSBMDcuXM5+eSTh3hmgsNBiAJBiuQFVa1W90nbSvplNRoNkUgEo9FIJBLBFolgNfooi0XoClZRXV/Pv3fpMVjSKc3LZFSWC53m2DnF2loaCPi72bdrC+Mnz+WsC3/Ekw/9loLiMs7+7o/RqLWMKp3EX+/9BXa7i4a6CsLBIFa7k1efe5iySXMIBLqpq95HZ0cL1ft3EQoGCPi78Ha0sXrla/h9XWi1Oir3bueiq37Bvt1bef7xe/nlnU8M9e73O75QmN21zeypaUQOtVJgDXNcRhSTXo1arUuZ/jUaDSaTKRUzkMwiSAoC0SVx+DFr1ixOOeUU3njjDRQKBbfccov4fo4SREMkwUHpXQUxGSwUiUSIx+MEAgFCoRChUIj29nYikQihUIhIJEIsFqPNF6O6W0djyEyaM5PSfA/57jQ0x2BueMDfjUqlSmUFSJJEMOBDp9OjUKpS7pmkVeaQ4/i6ePvVpzjlrEsJh0N89O5LLFpyPkazlUg4hE5/bLhnQpEY++pb2FXdSKCrkWyjnxxzGJvxc+FpMBjQarXY7XaMRiM6XUIgJC0CWq02dTyP5EZzqIZII+CSOCisW7eOefPmMWvWLD7++GMhCvqJgT6Ox85jnKBfSZ54ySexpL9WlmVMJhOxWIxYLIbL5SIWixEKhfD7/YTDYeydneRFo0QiQZq7d7N3RwWrN5lxZ2RSmucm23XspDgajIlmRsn7iEKhxGj6vMmSLJPqPvhl95pQOMTGNe9SW7kbuzODkrIZGHuaNml1hqPafRCNxalsamNXdSMd7Y3kmIJMscdweFRoNAbUags2my1VV8BoNKZiB5LWgGSQ4EA2Nko2CZPiUsrsfRQf9iFn0qTJnHTiSfzg6quJRKJDPZ2jGgWAQoFSqUj9LQyUOBCiQPCV9D75evttkydnPB5PBXdFIhFkWSYajRKJRNBoAmRYooTCrbQG2vls6z4+jFrJ9ngozfOQYbegVIonCHtaBr954GVCQT86nT4VsHi0Eo9L1LZ2squ6kebWRtw6H6OtYex58Z5AQR0GgwGdTodGo8FqtaLT6VLugWSw62B2OYzH4wQDIZ6857+o1V91aTzw21Ec4v2v+uzLljtwXw98/8vG+6plDvX54fbFPJztKJhfeh715Qqe2Pzul4x5tO73193GVy335fstSRJZhQ6WLJuRCqQdCIQoEBw2BwYoAqkgRbPZTCwWIx6P43Q6iUQihMNhOjo6CIfD+Hw+LOYwuWkxAsEGGnzNrFm3k4AqjYKsTEpyPTgsJka6hVFnMAEgHYWKQJJkmjq62FXTSF1jAw5VJ4W2CJNzZPR6HWp1wi1gsVjQ6/Up60DSZZC80CXdAoPZo0CSJMLhMG1t7ej0Os5ZvmjQti0QHA4+b5C3XvqQrq4uDAYDJlPiWtHfQlmIAsER0duMlQxSVKlU6PV64vHEU2E0Gk3FIESjUbxeL2mOCMUZYQKhJup9bXywZidRjZOi7EzG5LixGPVDvGeCw0GWZdq7/eyuaaKqvgGzooNiR5yJ+TG0GjV6vbWPJSBZI+PL3AOD7XtOthSPxWIEg8HE71+lyr7ug+bXWfdwH5gHYy5HuvzXWfdI9vvrnjJH4X7LUsICGw6HUavVyLI8IH8rQhQIjojeJ2UyW0GpVKb8s8lAO4PBkApGTD6VJeIVQhRpY+SY/QTCXdQ01fLWfgMqo5vibA+jsjMw6o7dFMejFa8/yJ7aJirqG9BEWsm3BFmYEUOrUaHT6VCrE2WFjUYjWq0Wh8ORyh7Q6XSpoMED/aNDGYwWjUYJBAI95+5XLDwMbhKDMpcjXf7rrCtEwZe+L8kQjUQJBoOp+C4hCgRHBUmzb2+/lyzLxONxZFkmPT2dWCxGNBqlq6uLcDhMV1cXgUAATzTK+GAQX7iK/fU1vLbbgNHqZnRuJoUeF9pjKMXxaCMQirC3vpl9tQ1IgWbyLSEWuiUMWhV6vTllCXA4HOh0ulRhoWR8QG+LAAzTgkLJGhLxo9B/Izim+UrrVT8hrrCCAUWhUKQUbdKCkHxCTJrAeueiR6PRRPxBNIrDHGJ82E9XaD8VVTWUbzdgs3sYneshL8OJSnVsZDAMZ8LRGJUNLeytbSTibybXHGRuWgyjh9STf+86Akkx0Ns9kMxeGS4WgUORdCMkSywLBMMJWZKRkVPn6UAhRIFgwOmd3tj7pyzLaLVaJEnCarUSiURSMQfBYBC/34/P50Oni2HVhxkXDdAWaKdixx7Wb7GRkZ7F6BwPmS47ymF4kzlaicXj1DS3s6emAW9HA5kGHxOtEWxpylS8SCybpAwAACAASURBVKK7piEVK2Cz2VI1BJLNh3oLgeEoAg5OwlQgf5X7YIQhIxMIBjD1BMIOFP6AH5Ox/7chSRLhSAjDUdxl9CtdWv2EEAWCQaf302LSN5Z86pQkKZXJEIlE+pRZ9vv9uEIhcgMBYrEumnxd7Ny2h1UxG9nuTIpzPKTbLSi+toNRIMkS9a2d7KltpLW1AY/eR5kjhitdiUqlwWCwpjpsWq3WlCUg6R7Q6/Wp1MGjTwgcwDC2FKxa+wH3/ekPXHje94jH42z5bBO333IXCsXAWs1Wrf2Av/ztPv752MsDto39FXu44kffZcUb6/j6QQKHJh6Pc/f9v8XpTOfKS3/4pcuGI2F0Wl2/bbs/Ee4DwYggefNIuhiSPufeZWyTTZpUqmQQm5poNIpOFyHdGCQaa6LB10J5+W66ZQe5mZmMznZjM5uEPPgSZGRaOrrYU9dEY3MDTo2XfEuIGflyqlhV0gWQbLut1+uxWCypbpvJbJNkS9yjWgz0IDN4F+Cvy9RJM6mpreLbp56HUqlk4oSpSBIoFTIyfW+lh4pfO5AvqwKQzMYfWzIh0cfjgONysGUPNodDfU6v9wryRqHX6ZEkUCB/5fwPtq2DbVupUDKmeCytbS2HnL8C2F+5l207tnD6KWcfYotDixAFghFF75uJVpvINpBlGYPBkGrSFI1GicfjqcqJgUCAzs5OIpEIZlOQgrQI4UgdlZ11rKo1ENWkk5+VyahsN2aDSHEEQIaObh9765qobazHTDsFlhATc0Cn1aBW61MZAhaLBYvFglarxWQy9emBcUxYBA7FMLYUyD2NtcKRCHv27iQnOw9kePmNF1AqVWzasoFrrvgpu/fu5KVXn0WlUpGbncfO3du59aY7efyffyUvp4AzTz+fRx7/E0tOOJ2333sdlUpFfm4h48dN4s57b6OsdALRaJSlJ3+bTz5dS3d3F7FYtM9x2bBpHc0tjWzfuZWrr/gpb77zChqNlvUbV/OLG37DG2+9TE1dFUajiW07tnDOGRfw+lv/Zv7chRQXjeEfzz6Kx53F2k9W8dtf3cOY4tKehmIyNTWVbCxfz5bPPmXpSd9mxrQ5ANTV13DnvbcxY8psXn/731xzxfUsmLuIhx69n0x3NvWNtVz7gxvZtmMLu/fuZMtnn3LBeZcmjp0ss79yH/9+7TkuPO8y6htrqa6pZN2GVSy/5Br+96G7MBlNTCibQl5OwRB8u1/OYJ2TIlJLMGxJBicqlcqUe8FoNGK323E6nbjdbnJycsjNzSUnJwePx0OmJ4Px2QZOHh1ncWYd6s5NfLDmfd5YtYHtFXUEw5FUhPlIeckydPuDlO+p5JUP17B+4wfYgls4OaeRxUUSYzKNuDPS8Xg85OTkkJeXlzqeaWlp2O32VHOiZBbBsd6ESJaG6UuWCYdD/OvlZ3jmhSeIRmNs3/kZm7d+yqknncX0ybO4+4HfMqZ4LLv3bOe2m/7A8kt+RCDgJxKJUDq6jB27tiFLMrnZBfh8PsaPncSUiTP4zzuvkJ2VR0NDLWefcQGXX3wNd9//W84540LOPmNZIlC411zefPsVNGoN55xxIUqFkuaWJk5YeAqtrc1UVVeS5cmhs7ODqy//KbFoDKfDxS9uuJ2XXnmW0UWllG/ZyPcvu46Ll13BvQ/ekbBEkHgi/vPf/ojNaic3u4DHnnoISUrEeWR5cqmpqeTExady+833cMfdv8Lr9WK12Fg4/wTeee91IuEIDz1yH2csPZelJ51JW1srsgQdHe2s/PA9fnD5daQ5XPz9yYexWmwYDSZeeeNFpk2exaQJ08jNKhj67/mg3/3gnPvCUiAY1iRvPMnMBVlOmLYlSUKn06HVaonFYuj1evx+P6FQCEmSiEajqFQRRqvCFNnCdAXaqamv5O29JvSWTEZle8hzH7spjjIQCkfYX99MZX0DhJrJNQeYlxbGpE+2G9amggYtFgsmkwmj0YjZbE6lEfbumHksi4DeyAxfS4EUB53OwHlnXswZp4RQqVS8v/1d1GotkiRTMno8j//zbyArsFrsaDUJC9kZS8/j1f/8C4ctjc92bOb9D99jxpQ5qFRq1m1YTUFeEZIkIUug1eowGa1EoxHqGmpQqzSoVVoUCmWf43LpRVdz+x9uIhgK8L93PUZeThErPngHvc5APCahUKowGkxIkoxep8dgMKFWaRKpyRKYTRb0OgOzpy/g7089jNSTBirFoaaumgVzvsXx807k4mVXJm6KPcZ+tVqDw+Ykw5XZE5ekJxqJsnvvLlRqDT6/n4amemQJpk6aRSwW4z/vvMzG8vVkerL57vnL8fm6CUfCHDf3BI6bewKSJPH0C39Hlobxdy/cBwJBX3oLBCDl85ZlGbvdniqzHAwGU1UUvV4voVCI7u5uMiMRpsbCtHbvoaKmkq07jVgdCYGQ7To2Uhwj0RjVTS3sr2sk7Gsk3xJkrjOGzajp03wo6R5IugWS4iCZKjpSBMBBkeVhe2OIx+M9nUtldLpE58wJY6fw3L+eIBaN0dbWytyZxyFJcmo5gIXzT+KCy5dy2013cfy8E1n50TuccPxS/vx/95CbnY/T4SIWjdHd3Z1YNy5h0CdShHfu3obTkU44HCYel1Lnxa7d2/nzH5/k/j//nlVrPuCvj9/Pc39/kzfe/jferk5kSe6Zx+dpnlJc7ikOJROOhJHiMo1NDcyYOqdneQlZknHY0njk8Qf59qnn88mnqzn15M/9/LF4jEgkSigcZsyosXxavp6Kqn2cdfoFRMIh4rE4oXCIFR+8zehRpVRW70OSJBYtOImW1ib+/o+HueSCq6itr+atd1+ldMx4Kqr2okBBKByis7MTq9U2+F/uVzBYGTGqX//6178enE0NHffeey8XX3wxGRkZQz0VwQBwYE+G3uWWk0+8vdPldGrIssgUWf1YaKOuuYmNe+po6QqhUakxGvRHVQZDLC5R09TCp7v3sX33VgzhasbZWihLj5CTpsVi0mO1WlMxAkl3gNlsTrUp7l1ueDCaDw0H3n//fcLhMEuWLEGWZYLBIN5OL3V7fIwqzRtyt8/BXuVbNiBLEs60DDJcbpAhzeHEYrby8ZqVhMIhvnPW96io3IO3q5NRBWMwGc1o1BosZhvz5iwmN7uATHcWWZm5pDlc/Ofdl8l059DhbSMrM5eurk7SHC4y3dlMHj+dJ595hEAwgEajpaR4HCajGWTYur2cHTu3YrXaOXHhUsLhEBs2raVkdBnhUDhROjoeI9OdTWNTPRazlWAwgN/vo7iolBdefgqXM4Oq6v1cdP4VtLS10NLaRF5uIScsXMpb773K6nUfcP6ZlyRSCXuOwfMvPYXJYGLXnu189ztXkJ2Zx+r1HxKLRjGbLGRn5rHkW2fw1LOPUNdQy+lLzmX33p0oFEqWnPBtVq9bSbrTw8nfOp2nX/w7ldUVnHPGd0lzuPho9QrGj5uS2sfh9IqGY1Tsq2T0pKxUR9GBEO8KeQQ0D8/Ozuadd96hrKxsqKciGECSp3KqBW6PGyEejxMKhQgGg4TDYdrb24lEIgQCgZ6nnzihcJgWv5LKLh1tcQeZGZkUZXlw2qzDUh5IskxjWwf76xtpa6vHreui0BrBrpfQ6/UpMZQsKmS321MBhMnmQ8nAwWM2YPAruPXWW+nq6uK+++5DkiTa29upqqhm/esNnHjm/KGe3jFNOBzi0qvP5JnH3vra616w/BSeeOhltMM0dXCgCPiCvP/uSpZePA2bzYbL5RqQXiHCfSA4ZuhtMUimN6pUqlTVRLPZTDwex+FwpBqL+P2JACyv10taOExhJEIo3EKDr51tW3bRhYNsdxaFWW7s5oEt3PJVyDK0er3sr2+kqbmBdK2XMY4YriKpxwpiR6PRYLfb+7QhVqvVfdwDvZsPJY+XoC/DNSXxWGHv/l2MLi6jvr6WTE/2Ya9X31jLmFHj2Lt/N2PHjB/AGQ4/Bst9IESB4JikdxVFWZZTN0NJktBoEsFOsVgMg8FANBpFr9cTDodTZZZt1igFaSFC4UbqfG2Ul+8koEgj15NJQaYb0yCmOHZ2+6hoaKK+qYE0dSdF9igzC+NoNGoMBnOqzLBOp0t1JDxYmeFjOo2wH5FlUkFvgoGhtHgCt914N/D1jrUnPZtbv8F6xwIi0FAg6Cd6C4TePReSFgRJkrBYLH3KLCebNAWDQUzGGHnWAMFIN5UdtayqNoDBTb7HQ77HjU6r6fc5+4MhKhsaqW5swBBvocAaZkK2hEat7Hn6N6TKCyd/JmMDktUFk0Kg9zEQHAZCFAiGIYN1TgpRIBhx9K6imCyzrNFoUnEIJpOJWCxGOBwmFAoRi8VSAiHDGWRCMEggUsO+9jo+qNShNrkpyMwkJ8OFRvXN/6RCkQhVjU1UNzaijjRTaItwSh7oNUq0WnOf+ACNRpNyESSrDyaDBHv7GYUY+PrIyEjxoZ6FQNAX4T4QCAaYA2MQkk/VQMrNoNVqiUajAKnf1Wo1hlgMky5EqbObrlA3FfXVrNhrwmh1U5DpIcvl7DPeoYjGYtQ0t1DV0IgUbCbX5GeBM4pJp0Sj0aRu+snCTTqdDqvVmhICSTEwkgMG+x15+OaqC0Yuwn0gEAwivW+mydoHyZ+SJGG324lGo8RiMXw+H+FwmO7ubnw+H/ZIhHRbkFisixZfJ/sq9rJ1pxVHWhb5mW4yHI4+N2pJkqhvaaWysZGAt4Eck5/Z9hi2zIR7w2h0pKwADkfi/0ajMZUtoNVq+1R7FPQvIqZAMBwR7gOBYAg50IqQrH0Qj8dRq9XEYjGMRiM2m41oNJrqx2Czhci0+1NdHPfv30d5yEK6KxOX3UZDaxudHQ3kmgNMs0VIcyt6LAGWVM0Ai8WScg8YjcaDugd6z1HQ/whRIBhuiNbJAsEQc2BRpGSJ5d5lliORCLFYDJ1ORyAQQKPRIMsy0WiUTGUYlyFINOZjR/U27rr5bm67/fe480iNk8wQMJvNmM3mVNBgsvGQVqsdcWWGhxSFosdSMNQTEQj6Isdl+rOl9KEQokAgOEwOVmbZaDR+ocxyKBQiEong9/vp7u5OFEiKRYl0NVOa68BisaDX6zGZTCmrQO86AsdSG+KjDYUSwrFu/vv2e0M9lWOCtrY2jEYjBoNhqKdyTGDzDPwtW4gCgeAI6J3J0DsFMBn4p1QqiUajOBwOlEolLpcLo9GY6tuQDCRMlhkeiAplgsNDqVSi02mZusRNZ6cXWZYYAQVfB5QX73qS6dOns3ju4qGeylFNovGTNuVOTFoOBwIhCgSCb0jvP0q1OvGnlExzlCQJg8GA1WpFkiRCoRAKhYK8vLxUBkPy1btng2DoSNZ2SMRzaFO1LARfD0mS8Hq9+P1+ZFlm9+7dKffaySefnLKECQ4fhUKBRqPp8/AwUAhRIBD0I70DE5VKZSrGwGKxoFAosNlsfeIDRD2BoSf5XZlMJjweDzabjXA4LETBN8Tn87FkyRIaGhpS761YsYLjjjuOm266aQhndvSSLNuuVqtTFUsHShgIUSAQDAC93QrwuSVBo9GIWIFhSFIYaLVagD5VLwVfD5PJxC233MI111zT5/3ly5djMg1t/5CjleT5mRQGKpVqwLYlRIFAMIAcLLVRCILhiUqlQq/Xo9PpkHryv4Qo+GZceumlPPPMM3z00UcA5Ofnc8455wjXwTfkYO3hBwohCgQCgaCH3q4fIQi+OWq1mvvvv5/Zs2cTjUa54oorRAbCETCYDxJCFAgEAsFBEBadI2PKlClceeWVPPbYY1x22WXiePYzsiwPyDEVokAgEIxoko2wGmvbaKrtRE66DoZ4XscCp59wAe11Eer3dVG/r2uop3PUk5QACqWCzLw0MrLS+r3cuRAFAoFgRCNJErFYjE9W7oKYBptDBMP1F1qsXHnxj+luiQ71VI4p2lu7aahq44RzpvV7iqIQBQKBYEQTDocJBoN4OzuZMWcaWfmuoZ6SQPClVO1pZMvmLXR3d6PX6/tVGAhRIBAIRjRJS0E0GkOS5KFrhpS0DX/V5g93uaMFsd9fe7lEf5VYqrR6Mn22P2IMhCgQCAQjmmRMQSwWQ5bkQetbLxB8U2SJlCCQ+rl9ohAFAoFgRCPLcq+6BIkLrkAwnJFlGQaouJYQBQKBQACALCwFgqOCfjYO9EGIAoFAIOhBkkAeBFEgA9u2b2FfxW4sFitZmTlkurN48eVnOO2Us3Cnew5rHEmWWbHybdQaDQvnf+sLn2/f+Rm1ddV93svKzGb8uEn9sRuCIWIgC2sNXKslgUAgOMpIuBIG/vXHB37Pxk3rOfmE05k8YTr3PnAnUlxm1ZoP8Xq9hz0OMrS2tbB1a/lBP9+4aT1jisfy6eYNlG/9lNHFY/lk47pB2ccDX5u3bhqS7R7JKxKJsm371iGfx4GvgXRxCUuBQDBISJJEW1vbUE9D0EMgEPjCe7I0sKZZgG07NrPig7d55bkVKBRKrBYtv7jhdiRJxmgw4ff5efOd15k9Yx42m4NgwM/aTz7G6Uxn4vipyJLEp5s/IRD0M3fWcZhNVpqbm/F6vezas52CvFG4XBkAnHnadzAYjJiNFpRKJbnZBZx75neR4jKfbd9MY3MD8+csRKFQsH3nVlzODPbs3cGCuYtYt2E17gwPxUUlbNu5BafDxZZtm1gwdzFGo4lQKMj6Daswm61MnTSDyur9SJJEbX01c2YuYOOmdUQiYebMOo5Nmz/hgb/cxS9u+A2xWJTcnAJisSgNjXVMnjSdisp9ANTWVbFg7mJ27PqMmrpq5s9ZiNHYUzdCltm5exsOh5NN5Z8wZ9YCbDYH1TUV7N2/m6KCYgryR7G/Yg8KhYK6+hpmTZ/Hhk1ricaizJ15HLIss3V7OZnuLLbt2MJx877FxvJ12G0OxpZOIBIJs+6TVej1BqZOnsGDD99DMBjgCkc6RqOJ9RtWk+7KYHzZJCqrEvtbV1/NzGlz+XTzJyiVSqZOnolGox3Qc2ggrVlCFAgEg4Berwdg1KhRQzwTQZJ4PM6NN97Y5z1ZlgfcffDx6pWUFI8D+fMumjnZ+antf1r+CUqVirvuv53bb76HR574M5de+H1uuPlqLr/4aj7ZuJozlp7LmnUfUlW1H2daOrKcsAqEQiEmT5ie2ge9zpD4vwzIiZuJXmfg1f/8i1GFY4hGotx067V878Kr+PmtP+a2X/yB1996mfUb1zBv1vH87JfX8L93P8pPbrySi5ddQUXVXl5+/QX+dM9jPPrEX/ju+Zfx69//nNraav77wVu4nBmkOZx8tm0zY4rHUl1TQU1tNbNnzEeSJLI8Ofzz+cfIycrjlJPP5LKrv8MLT77JPQ/8luysPKwWG/5AgIx0D0aDkR/fcDn/9+dnAejoaOPGX/2IpSd+m0AowCNP/InHH36R2//wS+79/cNc+oNzePzhF7nngd+Rm52Hzebg0/L1TJ44nR27ttHc1EjZuEn87JfX8Jub72blR+/x8ZqVnLDoFH5+67U8/eirPPXMI3zn3O/xP/f9moaGOox6I3qdHq1Wx+P/+CsXfedyrv/lD7h42RW89OqzZKR7SLM7Kd/6KWefsYxVa1ZSOmY8VsvANn4ayLYcQhQIBIOA2+2moaGB/k4fEhwZer0ev9+f+n1wAg0VPalkB9/OnJnHYTFbef+Dt6mqrmD3nh1s2LSO004+C5PBzLoNq/nhlTdy1aU/QZIkVnz4Nh+tfh+1WsMV3/sRwBfGTuaxJ99/693XOOv076BSqVl83BKKi0qx29KYPeM4amqrCYdDzJ29EOP/3Yfdmka6y81Zpy9Do9Fw6rkLqK6pYstnmxhbMoHFxy8hL7eAooLRlI4p44RFS+noaGPbjs00tTRhNVuxWGxotVpstjQMBhOyDGqlBo1Gg15noDC/mCmTZrJwwYlc9/MrOGPpuSgUSpaedGaiboQCbLY0Mt1ZnLbkbLIyc3j7vdcIBoL85Ac/Z/XaDwkEA2g1egrzRzFt8iyOX3Ai7e2tbNu5hZbWJhQKBUUFo7HbHMyZsQCvt5Oq6v3MmXk8aQ4XNXXVbNz8CSVjxjN/9iKyMnPw+buRZWhqamDPvp1sLP+E05ecizs9k8L8YsaPncTihUt46dVn+cmNV3DNlTdgMpgH/BwSlgKB4BhA9JIffhwYsDUYgYYL5izm2RefIBQModPpAPB2eVGQTImUEz9lGQVK2tpamT97EQqFgoqqfdTVV9PV3YXFbKGyugJZkplYNoV3/vsGixecTGFB8UH28/OxAYLBANmZ+YwpLqWyen/qfTkupywKyfcSsQuJ31VKNS5nBmqVlrb2FubMOB61WkV1TWXi6bVn3See/hvzZi1kwrgpVFTtRZZ6bV9WkKgNkdhPSeo7v3g8Tpo9nUkTpva4JGSSNXkSyyfWczkz6Ojs4PGn/8Ydt9zP3554MPVZcqxHn/wLJy4+lfFjJ9PU0pjyxSfjMXofEwUKWttamD19ARqNlqqa/Yl5I6NARXtHO/NnLQKgtr768+MqycyfvYiS4nHccsf1GHRGZkybMxCnTq/vU4gCgUAgGHBkWR7wiobFhaVcsuwqfn7rjzjvrItQoCAUDjJ7xgJaW5upravGarXT1tFGmt2F3Z7GpVefQ2FeMVcvv54zT13G8h+ex4SyqZx9+gXU1FUTCAS47upf8KOfXcqf7nmC/Nyi1PaCoSBVNRWolCoC/gB6vYFl51zKNddfxOwZC5gz43ikkgm0d7TR1t5GfUMt4XCY9vY22jvaaGxqIByJsGHTOuLxOGecci4ZLg+FecVc8v0zGTNqLBcvu5LGpnq0Gi3Hzz+J1tZm3l7xOhq1hn0Vu/n2KefT3NzAf1e+RVF+MU899wjxmNRjUdhCU3MD+/bvZsHsxVx47uVcd9MVzJ11PFMnzSQvu7BP0b91G1aRl1PA7OkLUCqUbN+5hVfeeB6vt4PVaz9IjFWxh/mzF9Pa2sxb776KLEvU1FWzYPYiOjrbaW1toa6hhsamejo62mlvbyXgDzBh7GQuvurblIwu45JlV5HmcPHSa88wsWwaBp2By354HoV5o7jiez+msakBvc7I8fNO4PmXnmLe7IWcuPA0TEbzgJ9DAxloqJBHQNPw7Oxs3nnnHcrKyoZ6KgKBYBghyzJerxefz8drT61i0sQZZGSmDcq2O7s6qKmtJCPdgzs9k1gsii/gQ6VUoVAoiMVjmIxmlEol+yv34M7IxGq2ISNTVb0fq9WGw+6kq9sLsoxebyAYCqJWazAbzantRGMR/IGEi8RkNKNRJ/zdza2NhEJBcnMKCIaCRCJhdFo9kUgYAK1WRzgSQqvR8oOfXsgtN/4Bg8FIdlYeChJP+xXVe3GmpWMxW+n2daFAgdViIxqL0trWTLrLTbevizS7k/bONswmCxqNhoqqvXgysuj2deFyZny+rtWWeGJvb8Hn6yI/rwgFn5fu/eGNl3DV936CzWonP7cIhUJBc2sjZpOFYCiAxWwjEPSjUPTMIxqhrb0VZ1o6fn83er2RcCSETqsjEo0gyzI6nZ5wOIRGrcFgMFJZvQ+HLQ2H3YkkS7S1t+ByZhCPxxPzdmdhNJgSc1YosPZss6mlAYvZSrrTPeDnTn1NMzt2lbP0gjmYTCZsNhtKpVKUORYIBIL+ZDCLF1nNdspKJwMJc7ZSqcZqth902VEFJanlAPJyEpYAWQKLyZZaTmPW9VkOQKXU9Bk3+ZkrzZ0aQ681oNcaANBp9alldVo9/oAPb3cnGo2OLE9eyqQOCgrzRvfZH0iY1NUqDZ6MbADs1jQkScZuTUttryA34eLQ64x91+0ZO83uIs3u6rUtCIdDeLs6kSSJvJyilIsluR8HG0ut0uJOzwLA1rP95P7pevYXQKfp2Wf587kljpMCpyMDWQKlQpX6Hg7cX4PedMB6A4tISRQIBIJBQFQ0/CKxaIz77/g7Bp1pSI9NNBrjt7+4H51WN+K/IxFoKBAIBIOAJIEUH+pZDC9MRhsmY8IaMZTHRq8zkZ1pGvJ5DAdEmWOBQCAYBCRp4AMNBYIjRVgKBAKBYBCQJYQoEAx7hKVAIBAIBgFhKRAcDQhLgUAgEAwCckoUfFVqV/KirOjzgyO5Vh/uGAOyrQP255CI/U79ONL78hHst7AUCAQCwYCjQIonL7iHe8U/1qwKYr/7Z7mBRVgKBAKBYIBRqhV8Vr4djUZcFvuLaDzKzoqNjC+e1acIkeDIiEaiWHOUAzK2OPsFAsGIRqlUolarKZrswN8dIBQKDmht+ZFEKBTiiQfu4c8PPiR6f/QTCoUCg8GAwaT//+zdd3ib1fnw8a/2npb3doadPUnCCGE0kEAoM4xAaGkYhRLo+gGFQl9KW1paaCkFCqS0UEYKAcIIECBAgJABZO/lPSXZlmxt6XneP2wJOwRIgh05yflc13MlUST5aFjPrfvc9zmoVKo+W8kwSQQFgiAc05RKJSqVCoNBD8ioNAoRFPQRnUGD0WgklohgsrjSPZyjgkKhQK/Xo9PpUkFB8vK+IIICQRCOWQqFIvXhWlZWRjQaJRaLiaCgD2VlZWE2m6moqEj3UI4KCoUCjUaDWq3GYrGgVqtFpkAQBKGvfJkpMKDRaEgkEiIo6EN5eXn4/X4sFku6h3JUUCgUqFQqVCoVarU6lSnoKyIoEAThmKZUKlEqlVitVmRZTh1C3yguLsbv95ORkZHuoRwVFApF6ujrqQMQQYEgCMe45Adq8gNWBAR9q6CggKamJtRqcbrpK8n3bF8GA0niVRIEQaB/P2iPZfn5+bz//vt9nuYW+ocICgRBEIQ+F4/HCQaDaDQatm/fzosvvkh9fT2nnXYao0ePTvfwhK8hggJBEAShz82fP5+nnnqKUCgEwMUXX4xOp6Oqqiq9AxO+kcjnCIIgCH3u9ttvR6fT9bpsxowZ5OTkpGlEwoEQQYEgCILQ5woLC/nd737X67If/vCH6RmMcMBEM3k9GQAAIABJREFUUCAIgiD0i+uuu46pU6cCkJ2dzYwZM9I8IuHbiKBAEARB6BdqtZqHH34YvV7PJZdc8pXpBGHgEYWGgiAIQp9KLgAlSRLl5eXc/NOfc/bZZxOPx1OL7iQX4BEGFhEUCIIgCH0mGQz4AlE+2+nms51eQkXnsGizkhUNW5k0NIMJQ1yY9Zo+3+FP+O5EUCAIgiAckp7LQsdiMVraQ3y+q5W1e9uIxJWMKHFx1pRysuxGkKGxNcCGvW6WfL4Fsw4mDHIwcbATh0WHVqvttYSvkB4K+RhY0zM/P5933nmHESNGpHsogiAIR6zk6SIZCCQSEg2tQVbv9LJ2dysqlZpRpZmMKnFhM31z/UCrP8zGSjebqjyoFQkmDnUxaaiTLJsBlar39IIIEg4fERQIgiAI3yqVEYgn2FnXxuodXrbU+LGZTYwZlMmwogyMukNLPneGomyp8rJhr5tQOMToUjuTyzMoy7Wh6p5iEMskHx5i+kAQBEHopee0gCRJRGMJtlS38fmednbWd5DlsDB2UCbTxg1Fq1b1uN2h/TyTXsukilwmVeQSjibYXuvlhRXNtHVUMrzQwoRBdioK7ahVXdtciyxC/xGZAkEQBKEXSZIIRuKs39vKqm1uajwhSnMcjC7LpDTbhkp5eE7EsYTEnsZ2NuxxU+fxMSjHyJSKTEaXOtGqlf2ydfCxTmQKBOEotWvXLkKhECNHjkSpVBKLxdi+fTsAFRUVaDSaNI9QGAi+rA9I0N4Z5vNdXtbs9NAakBlakMGU4SVc6LLQ87x7uL5JqlVKyguclBc4kSSZ6hY/q3a6eeaDanJsaiYNdTJ+sAuLUZvamlkUKn43IigQhKOUy+Xi/PPPZ8aMGdx2222o1erUZjQjR45M7+CEw65nUjiRSKQCgea2IGv3tLN2bzvBKAwvdjFz8ghcNsOXt+XQpwb6jEJBcbaN4mwbAE2tATZWunlz3Q5sBiUTBtsZX2bHadGjVqtRKBSoVKoeNxeBwoEQQYEgHKUcDgczZ85k4cKFjBw5klmzZpGVlQV0fUCGQiE2bdpEWVkZLpcrzaMVDgdZlpFkmVp3J6u2e1i7pxWVSsvIkkwumDoCq1HX47ppHOgByHaYmO4wMX18CW2dYTZVuvnr61WoFXEmDnYyucJFXoZZZA4OkggKBOEoZjabWbhwId///vcpKytLXd7W1sa9997L9ddfzw033MBtt93G+PHj0zhSoS/1bB2Mx+PEEwl21razeqeXrXWd2MxmRpVm8oMzStD36BgY4HHA17Kb9UwdVcjUUYUEQjG21nh49K1qQuEgo4qsTBrqpCzPhlqlSmURQGQP9kcEBYJwlBsyZAgPPfQQc+bM4d5778XpdPLiiy9SVlZGaWkpV1xxBY888ggLFixI91CF76Bnx0AikSAaS7C93s+anV6213WS5bAwujSHqWOdaNTKHrdL46D7gVGvYeLQXCYOzSUSS7Cjzsui1W7aOmoYWWRl0tAMBuea0ahVvToZRIDQRQQFgnAMOOOMM9i+fTs33XQTzzzzDKFQiI6ODgAyMjJE0eERrGdWIBCKsnaPl1Xb3dR6IpTkOBlVmsfp420o01EpmGY6tYrRJVmMLskiLknsbWznrbVu6tx7Kcs2MKUikzFlDvRajehk6CaCAkE4SkmSRFVVFaFQCJPJxPz589m0aRMAs2fPZs6cOcydO5eVK1dy3XXXpXm0woHquX5AIpGgrSPMF7tb+Xx3G60BicH5GUwePpjzMsz0PL0dI3HA11IplQzJdzIk34kky9S5O1i9283zH9eRY1Nz3BAHY8sc2Ex6VCrVMbtpk1inQBCOUh6Ph/r6eqxWK6WlpQCEw2Gi0ShWqxW3283q1asZN24c+fn5aR6t8HX2XVpYkmU87SHW7PKyZoeXYEzBsCIXI4szybAavuXehH3JQEt7gM2VbnbUebAblUyucHXtyWDWfSU4ONqDBBEUCIIgDFDJjIAkyVQ1+Vi1w8P6ve2o1HpGlGQyvNiFxaBN9zCPKu2dYbZUe9ha7UZFjPGD7Ewud1GQaUGpVB71OzuKoEAQBGEA6JkRSCQSJBISO+t9fL67jY1VPkxGIyNLMqkozECnETO/h0MwEmNbjYctVW5isQhjS+1MHGynNKcrQDgaCxVFUCAIgjAAJDcb2lTVxqdbW9he30mO08rIkiwG5TpQq8SGQOkUjSfYVd/K5qoWWv2djCiycPywLIZ178lwtGzYJIICQRCEw0ySpNSfgVCUdXu8rNzuptYbozjHyciSTIqy9ukYEAaMhCRT2dTG5io39S1tlGXrujoZSp3odZrUSopHYgZB5KAEQRD60b6FgrIs094ZZu2edlbt8NDiizMkP4Pjhg3lHKd5n9umY8TCt1EqFAzKdTIo14ksQ73X393JsIWCDC1TKlyMKbFhNmi/Uocw0IMEERQIgiD0k2QQANDcFmTVdjdrdnoJRpVUFLo4ZUw5DkuPPQZEEHBEys+wkp9hBQbh9gXYXOXm5ZXbsRtgcrmLSeUuXDZj6voDOTAQ0weCIAh9oGdGoKtjQKKqyc+aXV7WV/pBoWV4cSYVhS7MomPgmOALRNhW42ZbjRutKsG4MhuThjjJd5l7FSrCwAkURFAgCILwHSQ/QiVJIiFJ7GnsZOW2FjZUdnUMDC/KZGjBwO4YiEWjNNRX9VrhSKFQkF9U1munQeHQhSIxttd62FrjJhYLM36Qg+OHZVGcaUKpVAyYtRBEUCAIgnCQemYFwtEYm6vaWLnNzY6GINlOG8OLMik9gjoGdm7bwOpPllFUMpj77r6Zu/74BJ+t/JCL515PVs7hXdiqs8NHIp7A5nAe1p97OMXiCXbXt7K1xk2rz8/wQjPHD8tkeKEdjUad1iWXRVAgCILwLXoWCSY7BjZWtbNmVxuVzUEKMh0ML86iINN6RHYMdHb4MBhNBDo7+NFFJ/HC2xuJxqIgyyhVKqr37qCgaBAGowm/rw2tVkdTYy25+cXEY1HavG4KigeRSMQJdHbQ4W/HYrVjtTkA8LQ00tnpp6SsHFmWaPW0EImEycopIBIOUl9TSWHpYHQ6A3/6zXzOOu9yikuHolAqsVhstLd5MFtsaHV6PC2NSJKEze5ErdFSuXsb2bkFWKz2ND+LhyYhyVQ3t7G12k1Tq4+heSYmDXEyotiGQafptaLi4QgSBm4+SxAEIU16fleSJKm7YyDCF7tbWbXDg9ufoCw3gxGlJZw6fp89Bo7Ar1kmsw3oGrsMSDLodAY6O3y89tzjjBo3hRt/OJPf3v80d/z0cs4851I6/O1sXr+a02ZcyHtvvsBV1/+Kj5a9TmN9NfmFpXyw9BUeX7icnVvXo1Kr2brxc+LxKE5XDu+8sZBBQ0Zy5jmX8vx/HuSa+Xfy82vO496HFlJTtYva6j0YjGbuvfMGnlj4If957M8MHzURg9HEow/cxZSp0znuhNPZvWMTk088nZ9dcx73PPA0OXlF6X0iD4FSoaA0x0lpjhNZlmlo7eDj7W6eWV5HvlPDlIpMxg1yYDFovxIc9EeQIIICQRCEbj3rAyRJoqk1yOodbj7f3UYopmJIvosTR1VgNxu+DATko2ezoZ6PQ5ZhxfK3CQYD+H3tTD5pOgqFkuKyciZMOZWcvCL+78fn8/2LriISDlFbvZvy4ePIyMzhinm/IJFIsOLDt1j98TvMuvCHFJYMobmxllFjJ7N142fc8v8eIh6PMedHP6OpsY7WVjcWWwYZrmxGjJlMbn4xCoUCpVJNZnY+MjBizGRcWbncdOt9bFq/iqaGWjwtzUw9bRbt7a1k5x55QUFvCvKcVvKcVmQG4fUF2Fjt5uWVW7EbZI4b4uS4IRlkOkwoFIpehYp9RQQFgiAcs/adFkgkEtS4A3y+q5W1e32g0FBemMnMKUWY9L07Bo6WQGB/5O4jHAphMJo4ftoMJhx/KpFwsPcVFQpkur6xJrMMCoUSGcjKLUSt1tDW6mHY6OOwOzLwupvweppRKLuu097m5c1XnuGmX92HTmfo9bPlHmOBLzMwyu7bRsJhFAoFx0+bwZSTz6TN23LUvSYZNhMnjTJx0qgS/MEIO2rd/PnVSnTqBOPL7Ewc7CQvw4hSqUSt7jqdf9dpBhEUCIJwTEvuMbBym5tN1T6MBhPlhZmcd1Jpr46BI3Fa4GAFOjsJBQNEIxF0eiOTTpzO9VecSmeHH1mWueLqXxIKBgiHQkQjUcKhIJIkEw6HiCcSaLV6aqp2EYvFqKncxXU/vRufr41fXncup5xxAZlZueQWlNDp93Ut+lNbRXXlTr5Y9SG+9la2b16LwWBm5fK3OWPWpYRCQT5dvpTd2zfh9TQzcsxkOjp8SJLEsFHH8ee75/PQn25Dq9Nz4eU/PqpfI4tBx8ShBUwcWkAoEmNnvYd/Lq0jFgszptTGCcOzKcsxf+ciRVFoKAjCMSGZDZBlmWAowubqdlbv9LC7MYzLbqOiKJPi7COnY6CvybLMnh2bCAY7sdtdFJUNBaClqZ5N61YyYfI0tDo9e3duwWA0o9PpaWt1k51biMfdiEKhoGrPNnZv38S4SdMYNmoCGZk5yLLMhs8/IRoJM/GE06nctYVgsJOSsgosVjvrPvuY/MIyPC2NDCofSTgUpLG+ioqRE6jctRWvu4nMnHzMZiuBTj++9lbyiwbhdGXhb2/ls5XvM2LMpCOynqAvxOIJ9ja2sqPWTZvfT0W+kSnlLioKbeh12lSh4oHuzXDMBAX33HMPZWVl6R6KIAhpYnNmElA6WbXDQ2VziDyXg/LCTPIzbCiVR17HwED0xkv/odXTzJXX3ZruoRyTEpJEbUs722vdtLT5GJJnYkq5i+GFVsxG3QFNLRwTQcHs2bPZtWtXuochCEIaJD/isoedjGnE+VQUZXPiiBJcNlOaR3Z0icdjbPxiBQkpwejxJ6LT6dM9pGOWDDS3dvDRxr1UN3u56IR8Zp88KLUPwzc5JoICQRCOXbFYjFgsRktLC82edr7Y08r2phgRhZXSvCzKC7PIdpgHzDKzgnAoJFmmweNnR20L1Y0tmBQdVORoGD84gwy7hdzcXNRqNVrtNy+xLQoNBUE4qiW7CxKJBFqVzKg8DUWmIOFoMzVtTXxYqyGAjcKcbIYWZFKQaUN1gPOvgpBO8YRETUsbO2rdNDQ3Y1P5KbTEOKNQgU6jwmrVo1Z0ddUc6Pd/kSkQBOGoFo/HSSQS+Hw+Ojo6CAQCtLa2Eo/HiUQiRKNRYvEEde0StZ06fAkLuVk5DC3MojjLgUYt1v4XBo5ILE5VUys76lpwu5twqjspsETItSrRqFVoNBp0Oh0ajQabzYbFYsFsNuN0OlGpVKnWxa8jggJBEI5qyYWIQqEQkUiESCRCZ2dnKigIhULEYjECgUDXVEM8jiegoLZDS3PIgMOZxdCCLMpyM9DrNOl+OAelzdPM64sWcMkPf4ZOb/z2G+zD1+bhjUULOPeSH2P+hmWEfW0e3nhxAefPuQGj2QpAS2MtS1/9L5dfeytK5cEHVpU7N1O1dxunzpj9lf+LRSOs+ugtdm9fjyRJzLn6FgxG837vJxaN8N4bz1NWPopBQ0exad2neJobmHD8aThdOQc9rnQIhKLsafCws66FDl8LucYwhZYoTgOo1SpUKhVmsxmtVoter0ev16NWqzGZTOj1enQ6HUaj8YBqCsT0gSAIR7VkO5Zer0ej0WAwGDAYDKmgoLOzk2g0ikKhIBqNEo1GyVZGcBnDRGMd+MItVO3QsXqDCZM1i8EFWQzOc2ExDtxCulg0Qm3VTorLhrFy+ZtcMOdGtLqDvx+Txc5nny7jzHN/gMny9UGByWxnzYp3OevCeRi66zdtjkw+eu8VLrv6Fg6mXGP7ps+oGHUcGdn5qDS6/a498OLTf+e4E6ZjNFnx+1rRag1fu0aBSq2hrmYPRouNdauXc8Ips3C6cvnt/83lgX+9M2BrSdo7Q+yqd7OnvoVIRws5hiAV5giWPNBoNKhUqlRGQK1WY7fb0el0mM3mVFCg0+lQq9WoVKoD3u1SBAWCIBzVkm1YSqUSjUaDLMvo9fpUrUEsFiORSKQCglgsht/vJxqN0tnZSWY4THEsRiQSpCNcSXVtNYu36VAZXAzKz2ZwvgunxQQD5NwSj8V49P5bMZttnDfnJ+h0Btpa3axZ8Q5TTj4LtUbD1g2rMZqtqNVqcgvKWL/mQ/QGI2Mmnkyg08+2jWvQaHWMnnASOr0Bv6+NjV98wnEnnYnJbCUY6GDT2hUYjGZGjT8RpVqNVqfvWolQhh1bPqe9zYNCoUqtdAggJRJsWruCRCLO4Iqx6PQGNn7xMbIsM/H47/HJssW8tfhpfvyLP2K1OYlEQshA5a7NeN1N5OQXo1Fr+ezTd3G4cphy8kyq92wjIUkolCp2bv2CpoZqjjthOgaThVZ3Ezu2fEGHvw1kKB06ilg8ijMjh1g00hVIDJDXDRncvk521bmpbGhGEfFSYI4w2Z7AmKXoPtGb0el0WCwWdDodVqsVjUaDRqNBr9en3uP7bqJ0MIGPqKYRBOGYkgwQkodGo0mlXQ0GA0ajEYvFgtVqxeFw4HA4cDqd2Gw2sp0mxuar+F5xJ8c7q4i71/LeJ8v57zuf8vHGPTR6/UiS3HUiTNOhUCqxWJ1k5hRhMtuQJImdW9dRU7mDl555iMb6av54x4/YuXUttVW7ePGpvzF8zPG889qzLHvrBZ594k9UjJ5M1Z5txBMJZElix5YvaG6s5bkF9xGNRPjnX25lxNgT2LJuJYuefjD1LV2W4b0lz9PcWEvJ4BH42j2pQEGW4cOli0ChRKXS0FRfzYK//Rqr3cXGzz9mxQdv4HDlYjCYcGXls/S1Z3hvyUJ8ba0sf+dlykdMZNPaT7E6XBhNFvIKBxEMdHL/3dcTDof4cOkiZBkMRgu/u2UurZ4Wnnnij4ybdCq+di8yMPGE6ZQMHsnyd1/mqvm/7VqmOY2vVSIhU+du54N1u3j67U9YvnI5ytZ1nOSq5rTiACNzlbjsJmw2W+q96HA4sNlsWK1WTCYTRqMRvV6PVqtNZRCS7+1DWfJYZAoEQTjm9PywTKZVtVptasVDk8lEIpEgHo8TjUaJx+P4/X5CoRChUIiOjg5M8ThWY4xBjgDhmJ96by2f1BoIKuzkZ+cwJD+TfNfh72RQKlTo9SaMJgsajQ6FUsnEE84gM6eA9954jrzCQTgyspk+ay4dPi9LFz/N4IqxTDzxDLJzi2huqOE3P53N3B//GpVKjUKhZMKU7+Fv97Lw339h26bPSMTjmExWpp9zBbf++CwunPtTAGRJ5rUXHuMP/3gNg8mM05XTFTB0Bw2Z2YX87fc3MvvKn3LazEu59Ef/x85t62hv89LpbyOvcBAarR6jycrgirF8sXIZWp2eVR+9STQSZvaVP0OvN6HV6rHZXeTkleDIyAYZPnr3ZU4761KUShWnnXUZH7z1AiWDRqDTGxlUPia1oUIiEcfuyGTccaekZQOLWEKizt3GrroWGluasSh8FJjCnJIto1Uru9sGTajVaoxGY6ouwGazpVoKtVotKlVXUWHPTFhfEEGBIAgC9PpgVSqVqWWRk1MNRqMxteZBsjgxFAoRCASIRqPYLQEqEglicTdNHR42bNDwQcxEpqsrQCjKch62TobkeViSv/w3KLqnTHpcplTR2trC2MmnodFoqa/ezfRZVzBi7Ak8+Psb+c1f/vflBkWKrtsrVWpamuqQZNDoDNjsrh5bLssEAx342r3ouwv/ZPnLceQUlPG7hxbzj3t/SiQSZtfWdVz8w19QNmRk6tszyEipv3cViv7+H6/x1iv/5s+/uYZ7/r74q49P7lqPwunKpXzkcdTX7OaTZa/Q4W/rvo4CSe6632g0ysjxJ6VuezhEYnGqm73sqmuhtbUZly5IsTXG2BJQq5SoVAZMJhNarRaDoevvarU6lQFQq9UYDAaUSmUqE/BdNz76OiIoEARB6LbvPvXJD2EAtVpNIpFAkiSMRiPxeJxwOIzJZCIWi6U6GqLRKCZjiCJnjHDYQ2u4jcqde1m5QY/NnsWgvCxKcjIw9GMng8OVzSfLXiU7r5T2VjdNDTU0NVTjdTfS3FhLm7eF5sYacvNLGVwxll/86HuUDR3FBXN/yqL/Psjps+Yw6aSZJKQEbd4WGuur6fC10uptpmTQSIxmK8vfWUQw2Mnsq35JMNhJu9dNc2MNs2Zfx99+9xOmnzOXNm8Le3ZuYsiwcQCs+uhN7M4spp05G61WT1trC++98Sxt3hYi4SAjxp/E3l2bWbv6fRrrK3G31OP1tLBk0eOced4P8bV56Oz04W6qY++uzVjsLtpb3TQ31XDOJT/md7dczthJpzBqwslMO/Ni7rrpfOwZ2ezZsYFgoIMTTjuXNSuW0lhXyewf/Lzfnn+AQDhCZaOXPfUtBDrc5BrDDDFHsBdJ6PU61Oqu6arkt36LxdKrEFatVveaDlCr1YdUI3CwREuiIAjCQei5sVI8Hk+tg5Bsd4xEIvh8vlRnQ7KQMRgK4QtDjV9DU8iIwZJFWV4Wpbl938kgSxLtbW7MFjuRcAi1WoMkdQU0arWaeDyORqNFZzAiSxL1NbuxOVxYbE6CnX48LfU4MrIxGM2EQ0FUajV0LwBlNHVlAGqrdmJ3ZmJzZBKPde2YqFar0RvNNNdXodMbkaQ4TlcuyfaDSDhIm7cZpVJFVm4R0XCIDn8rVruLSDiI2eqg3duC1Z5BOBRAliR0eiN+n5fOjnYKiociJeKEwyEUCgUarY5oJNzVm28w0e5tIRTsILegDBQKgp0+Wj3NmK12zBY7ao2WcDBALBbBYnP26XMO4OsMsrfRw96GZmIBN7mGEEW2OFYd6PX6VMo/2T5os9kwGAypYCB58k9OCyQzAoeTCAoEQRAOUvJjs2eAIElSKkgIh8OplsdIJEIsFsPn8xGNRgmHw12dDVGobldS26FFocugJDebsjwXDovYk+FIIcsyXn+APQ1uahqbUcVaKbREKbbLGLWk0v7JhYSSXQLJACHZOphcVGjfQCAd7ZIiKBAEQfgO9g0QJEkiFoshSRLRaJRIJEI8HqetrY1IJEI4HCYcDqeyC9FolFBUpq5DRUPQQFTloCA7m7K8TLLslgHbR3+skiSJpjY/exvcNLQ0Y5DbyTeGyTXH0GuUqUAgWRSYnCKw2+2pLpfktEAyIOhZz5Lu11sEBYIgCH2sZ6CQXHc+EomkOhpCoRDRaBS/358qVAwGgyQSCcLRBDXtMrUdWjplG7lZ2ZTlZZHrtKFSiS7ydIjFEzR429nb0EKLuxmr0k+RJUqeVUav06SKAnU6HQaDIRUAJLMEKpUKrVabqlFJZybg24igQBAEoR/0DAyS9QfJICEWi6WCg3A43KujIRKJEAgEuv4/HKUl2DXF4ImYcDq7MggFmYevk+FYFYnGqG1pZW9jC762FrIMQYosMTIMCfS6LzsCetYEJNe8SHYPJIsIFQpFr0JBGJgBAYigQBAE4bDYX/Yg2eKYSCQIBoOpvRh8Ph+xWIxgMEg0Gu2eaojiDSmp69Thjpqx2rMpzc2iKDsDvfbI2pNhoAqEI9Q0e6lsbCHobyZL10mBOYpdL6HrXhwoGQxotVrMZjNmszm1t0BySuBIyQrsjwgKBEEQ0mDfTEIikfjKgkk910Ho6OhIZRXCkQi+EFS2K2kM6NGasyjOyaI4x4XZoB8wK/cOdDLgDwSpavJQ09hMIuwh3xim2C5h0ZMKBJKdAsnVAw0GQ2rvgZ6FgsBhaRvsTyIoEARBSKPkR3CyiyEZGCQLEXvu4pjsZAgGg8RisVQhY2dUQX2nhvqAHknjpDA7m5JcF3az6GTYlyzLtHYEqGpsob6lBU28jXxTmHxLDKOG1NbDyRUFk3sLWCwWDAYDOp0uNS2QDAj23X3wSA0IQAQFgiAIA04ye9CzkyE51RCPx1PrIAQCgV6LJsViMYJRiVqfkvqAnqg6g7ysbEpyMsmwWVAOxJNVckjfdiY60OvtR0KWcLf5qWpy09TShFHuDgSsEgatqteOg0ajMbWOQM8Nh3pmBfpzRcF0E0GBIAjCAJUMDKArk5CsRei5DkLPQsVQKJQKFhKJBOFYgga/khq/Bp9kJcuVTUlOFtmOo7+TIZ5I0Ohtp6qxBW9rMw51B8XWGNlmCZ2mKxBITgcktxzed2nh5M6Dya2Hj4RCwe9KBAWCIAhHgGT2INnJsG/9QSAQIBgMEg6He2UPUvUJ4SjesIa6gI7WmBW7o6sOIc/lQKM+Ola8j8Zi1LtbqW5qwe9rwaXpoMAcwamPo9dpU62ByZO+yWTCYDCg1+uxWCyo1Wp0Ol0qCFCr1YeUFdi7dy9VVVUYDAYmTpyILMusWbMGhULBpEmT0GgGbmHo0fFOEARBOMrtb2fHnisq2u32VLFiz+xBR0cHkUgEv9+PKx5nUDxOMOTGG/RQvWcnG7aaMVuzKcrJIj/TiV6rTefDPGjBcIQ6t5eaphbCnc1k6QIMsydwFMvodTrU6q4MgMViQafTYbFYUrUCyZUFk8sP99W0QHZ2NjfddBMTJ07k+OOPR5Zl3nrrLS655JIBHRCAyBQIgiAc0XrWHySPfQsVk5mEZF1CR0dHj+WYE/gjCmr8ahoCBlQGFwXZWRRmuTANwE4GGegIBqlt9lDX3AwRL/mmMEW2OGatjEqlSq0omNx5UKPRpNYOSBYL7hsI7Ds98F3V1tZyxhlnsGzZMiKRCKtXr+bSSy8FwOv18sUXXzBy5Ejy8vKoqqqivr6ewsJCioqK+uTnHyoRFAiCIBwl9l1yed9OhuR0QmtrK9FoNNXumKxPiMfjdERk6ju0NIQMyLpM8rOyKcp2YTUZ0zaPLssybR0BappbaGxpQR3zkGcMkWeOYtIqUoFAzw2HdDodNpstVSOQDATUavV+9xnoDwsWLOCdd95h8uR8Yzb9AAAgAElEQVTJ3HzzzajVarxeL88++yznnnsuF110Ea+88gqPPfYYN954I4sXL+a6667rt/EcCDF9IAiCcJToWQSXLJDTaDTIsozRaExt/ZycaojFYqmpBp/Pl9qXITccJpGIEYjUUttexxf1WsJKJ9mubIpyMnFYLCiV/RsgSJKEp91PTbMbt7cJE+0UWaIMy5Uw6tSoVDp0OmtqISGHw5GaEkjWDCRbB3tmAQ5n18BVV13FP//5T+bPn59ax2Dp0qX4fD62bdvGNddcQywW47333kOr1aY9IAARFAiCIBy19q2UVygUvdZFSK7QF4/Hga7tfXtOOegjEUy6MENcEYLhGlqCjezYqsMXt+J0ZlOYnUmWw45K2TedDPFEgubWNmqa3fjam3GqOyiwRBidE0OnVXef6PWp6YHkjoPJdQSShYLJAsHkn+nabEilUpGRkYHVau11uSRJzJgxg2AwiNfr5aWXXuLJJ59k3rx5vP7664d1jPsSQYEg9LGNGzeydu3adA/jmKVQKJg5cyZZWVnpHsqA0PNEmCxQ3LdQUZIkrFZrauvn5IZNgUCAjo4OotEo+kAAqzlOSTxCKFKPO9hEzQ4t6+NWrPZsCrOzyHEefCdDJBaj0dtKXXMLnb5mXNoOSi1RXHlS9x4DGlQqPUajMbWcsNVqTW04lFw7QKfT9aoN2Pexp4PP58PtdlNZWcmoUaNQKpXMmDGDe++9l7q6OlwuFzfffDN///vfmT9/Pg0NDWkdL4iaAkHoc3PnzmX9+vWUlZWleyjHpM8++4x77rmHefPmpXsoR4z9raqYXDApufdCcm+GcDiM3+9PTT1EozG8QQV7WqEpZMRgziI/O4u8jAx0Wi1fqVSUIRSJ0ODxUNfcQizYQq4xRJlDxmEAjUad2lzIav1yeqDndsTJnQf3nRaA9AcCPbW1tdHZ2YlCoSA3NzcVjHV0dLBlyxZGjx6NTqejsrKStra21L/TSWQKBKEfXHPNNdx0003pHsYx6aKLLkJ81zk4yRNpzzS7LMupugRJklAqlakef6VSmWp5jEajmExxXKYg8biPtmA7dc1VfFppRKHLIC8zi7xMF5IsUd/iodHdjCreSp4xxCRbDFtOV/2D0WhMnfR7bjiUnB5ILiR0JC0t7HA4cDgcX7ncYrEwZcqU1L8HDx58OIf1jURQIAiCIAB8ZR2E5EkawGAwpNZBSO7sGIlEUjs5trW1EYlEMJnCZNmijEl00B5so9ZbyVtfdKBUyIwrtXJiRgybMbmQ0JcnfYfDkQoIkp0EyYLBZABwtC4tPJCIoEAQBEH4Wj0DheQ3dbVajSzLqR0DE4kEZrM5Nd2QDBRsgQA5zghblv+PSCTC+FOuQ6OxYrFYUvsMJAsDk9MDyb0G9rd2gAgI+p8ICgRBEIRv1fPknEzbS5KEWq1OdTLE43FisRharZZoNIpSqUxlAWpqalIbDdlsttT0QLI+IDktkawVSP5M4fASQYEgCIJwUHpmD5IncJ1Ol1pd0W63pwoVE4kE5eXlNDQ0pCrwkwFAchEhMS0wcIigQBAEQegT+9YkPPzww1RVVbFp0yZ27NjBOeecQ0dHB08//TQjRowQwcAAJIICQRAE4TvbdzXFZO3B448/nrrOihUrGD9+PKNHjxbBwAB1dG+oLQiCIKTN/Pnzqaio6HXZjTfeKAKCAUwEBYIgCEK/0Ov1/PnPf04FAVlZWVxyySVpHpXwTcT0gSAIQg9i4aO+ddZZZ3HmmWfy9ttvM2/ePAwGg3iO+1hfZl5EUCAIgtCDOGH1vfvuu49PPvmEa665Rjy//aSvAgMRFAhCH0huLAOkNphJJBLAl5XYwsCWfN22fF7JptVVdJ27xAmsr1x/8d188uouPmFXuodylFCgAAqHuJh8+rBUYed3JYICQegDjY2NTJs2jUgkgsfjYcmSJTzwwAOUlpaybNmyPvllFfpXIpEgHo9TtauRsqFFFJaJXRb70ikzj0v3EI46gc4wny5by+gTStDpdL12iDxU4pNKEPpAXl4e06ZN41//+hcAoVAIn8/HHXfcIQKCI0ByZ8BoNEowEERfpMNkNaZ7WILwjWQgHImkdmLU6/XAd5tKEJ9WgtBHbr31Vp599lnC4TAApaWlXHnllWkelXCgJEkiHo8TiUaQJRlZElMHwsAmSxCPxYhEIuj1emRZFpkCQRgohgwZwuWXX57KFtx2220YDIY0j0o4UMklemVJRpZBEkGBMMBJkpyqZ0rWNH1XIigQvkJUBx+6W2+9lWeeeYa8vDzmzp0rnsvvIB0L3PQMDERQIAx0yWxWX37OiKBA6CU5t5r8cBQOTnFxMZdeeikTJ05EpVIRi8XSPaQjTnI9/L4omjpUstyVmj0aJH+Pv+253F/q+WDS0YeSuj7QsfWF5Pj6IsU+UPRRcqAXERQIKckU1IZVu1n59nbUGvH2OBTlzlOQmiw8ee876R7KESkaiXHevCnkFrlQqVSpbXoPJ1mSkRIDOyheueZjtu/YAoDBYOTSi/Zfv7Jo8fMYDAbOPvM8ukrTvnpCXP7JMt774C3uufMvqct27t7GXx78Hf988L/f+BokEgkWv/Ei23duYejgYcw+f84BjX/33h2s37iWd5ct4ff/7wFcGf3T7SHLMs8s/BfRaJR5P7iB/7vjJ9z2i7vJcLr65ecdTv1R9yI+9QWg6xcnuRd6Y72bCScNo2JcSbqHJRyDlr+xjqbGFuyZJvR6PRqN5rB/s5PkgV1oGI6EeexfD/HkowtJJBI8+Mh9SJK8n9M9nHv2RShQIEsyry5ZxPfPvrC7w/1Lg8vKefq5Bb0ec0nRIJqam7rv9+ufizWfr6SpqYFfzL+DuvqaA37eHnz4Pu65634mjJ2E0WDu1+c7L7eQtevXIEsy99x5P1qtbkC/vgdKBAVCv0r2aYdDYSRr/7zhBOHbyLJMIBAgFouh0WhQq9WHPSiQpYFeaKhk1+7tvPDSs1x47mVceuGV+P1+Fi1+jjNPP5t2XxvrNn7OxRfM5bUlL1JUWEIsFueBf9yLxWJj9IhxLPvwbfwdPs44/Wy0Gi3xeJxHFzyIv8PHT675OVqdrivdLsm0d/j4aMUyqqr3cuF5l5GbnQeAv8PHkrcX0+5rY/uOrTidLha/sYgWdzPnnn0R8UScF19+hqLCUmLxGLPP68oirN/0BVu2beLNpa9x9pnnseqzFbS1tSLJEufPuoTlK96jxd3Ezl3bqBg6go5OP+fMvJAXXv4vUyZNZXDZUJa8vZhTpn6PT1Ytp729lVkzL8Dv7xqnUqmkYugIMl3ZbN+5hbUbPsNittDibmHhoqe4cs61rPrsE8LhINW1VdisNq687BrCkTDvffAWsVgMGZmxI8dTVjoknS/0N+qPt6jYEElIkSSJWCxGMBjoTp8iDnEc9kOWIRAIEIlEUvUth1tXsSED9tCoNDz8wFMseOphLrj8DLxeD2ajhb2Vu2horKeooJTX33wZpUJJc0sTlVV7GDd6Ii5nJiefcDpL31tCQX4xRQUlvPjys0iSTGubl1kzLiAaifLwEw901VR0d2E8/Pj9lBQNwma1c8+fbk+Nw2KyMWHsZEZUjKZi6Ej+8OdfM3P6uZww+WR+ess1OO0ulr73BqXFgxg1bGzqdmNGTCAzI4uzpp/Lxs3r2LV7B+eeNZsv1q7mzXdeBVnB2+++wQXfv4yTppzKkrcX47Bn0NbWisfjRkpI2O1O3n73dQaXDiU7K5dXXnuBLFcOz7/4FCcdfypOu4tHF/yVs888n9EjxiHLYLM6+GjFB0QiEaKRCO8vf4d5c3/Cq0sW4fP5eOrZJ1Ap1Zw05RT++9wCsrLy0v5af/Mh9/mamyJTIOyfLDIFQpoMgLfdQM8USJJESeEgXlu4nOde/Dc/+PGFLH1lNaBInTAAkBXdqXm6itJkkBIyM6efyzvL3qCppbHrW7EEmRnZ5GTlM/u8K/jz33/b1e4GJOIS23ZsZs7sHzHtxOlMP3VWr+dGlruCqMbGelrcLSgVKgaXltPY3EAkEsFoNDO4tAK93tD7dnQ9x+8vf4cxI8cjSTInTJ7GytUf8f2zZlOYV0T54BEADCodysbN6zGZLCxa/ByxWIypJ5xGPB7j3Q/epLauGo1Gg06rJ8PpYlBJOZ+uXo5BbwJZgcOWAfIulAoVBr0BWQKjwUx+XhE6rR6r2UYkEsVitlJXX8O40ZPIzsrFoDMO6PdBf3xGi0yBkJJqx+rRkiUOcRzuo+f7MJ2/C+l+Hr7piESivLH0FZRKFVdccjWjho/D52tHpVQRjUUJh8PE4/Hez6ckI3XXDt33t7sZOng4o4aNRZJkEgkJma779rZ6GF4xGjkhd5/xIR6LU1tXTU52Prv2bO/9ekkykgQWsx2Pt4VAIEAiLpGfW4hOawC+4XWWZArzitm8dQOSJBONRhk6eESvtSIkSeaCc+bwx/vv5IzTziESidDY1IBBb+KeP93OmJETGV4x+svH0X2/ZpOV7Ts3E4/Fu7uqpO6f2/0NW5ahO/hLXjZp/InIMmzdvol7f/P3tL/O3370/XtfZAqE/ZKOgcVbYtEoGq324G60/+LtPiNJErIkoRrISyP383MwEDphk6nZgUqWZdZ8voJ4PE40EuH446ZRkFfCtBOn89iTf2PG985Fq9FRXVNJu6+dYDCIUqEiNyefV5e8yOgR43niqYcYP3oSNXVVxOMJHLYMFi56ikg0wo+u+An1DXVYLXbq6mv45U2/4df3/JRMVza33Pz/Us9NNBqlrqEGn99HNBrlpzfczl8f+QNlxUO46ce/wu1uxmyysm3HFsaOmpAaf0NTHXqdgXUbP+f8WZfx+/tv538vPUUwFGTO7B/x9nuvEQqH8Pt9WMxWxoycyJhRExlcWs6F359DYX4xsiQzdtREHlnwACMrxrC3chebtqzHaDBTU1fNiIoxjB8zmVt+cyM5mbl0dPqpb6jFoDdQWb2HxqYGwpFw12UGI1U1e2lxN/HmO4vR6/XodHp+9bN7KCsZuDUF/fEeVciiGV3gy+KuUCjEmy98QnF+BUNHFvXd/SPzxbo1/O0ff+TcWRcBCtZv/Jx77vzLYW05i8VjqFVq/vX0ozQ21nPnbb8/oNvJssxj//o7FqsNKZFg7mXzvva6kUiYx//9D+b/+JcHNbbOzg5u/MU8fnLdzzlu/JSvvV5dfQ333v8bxowajysjC7enmdEjxmGxWPn9fXdy16/+wLDykanrP/XsE+zes4Obf3IrjU31LPvwbTKcmWzZtpFbfnYXtXVV/PGBu/ntHfcxZHBF6nb/evpRamoquemGW3DYnTz/4lPdr5UCb6ubeT+4AYO+71dsXPHuBvRZnYyfMgKbzYbBYDionSYvuugiZsyYwdVXX33At5FlmWAwSDAY5PVnPmFQyXDyirMPZfjCkUqW+esjv2P+dbehVmtwe5rZtmMjJ584Pd0j+1rBzhAfvLucmVeMw26343K5UCqVYu8Doe/1x4puI4eNpbJ6D2efeT56vYFRw8eSSEj069fOfSz498Ncc9V8hpePoq6+5oAfY1tbK+++/xYvPL2Eu//4q2+83QfL3+WpZ5/gkguvxJWRecBjMxrNFOQXfet8dl5uIZ2dnYwfM5nxY49DlmV279nBkMEVJBIJHnn8bzz45ycACAYDLFr8PMdNOB6nw8Utv57Pn+55iAynizfeeoVEQmLk8HFEI1EeXfAgf/nDIwB0dPp5+dWFnDjlFBz2DB5+7H70egPzfnBD12P86F1uuWM+D973OPR1Z8AA+J4iS3Slz4VjhoyMw57JLXddT052PuWDR3D2GRcM6PdBfyywJYICYb+S83J9ep9SV95ZlqCurgaTyYJSoWT5x8to97Wxdfsm5l46j45OP4//+x/k5eRjMHSl+k6fNoN3P3iTqSecisfrZu36NfzpnoewWmwArFz9MR98/C6SlGD33p388e6/A/Dam4uIxaKMGTUBg8HI088toKxkCGaThdZWL3/9xx/xeJq5+9d/Ye261XjbvGzdvpEbr/0l2h5TC0aDiRZPM48ueJALzrmUJ59+lJKiMk6ZOr1XVC5JMnur9nDxBVfw0uLnufaq+XQGOnn48fvJycrlg4/f5aTjT+H7Z13I/Q/9ntEjxrFk6av88PJrOeP0s1PP00uLF7J1+0Z+edOdVNfsZe2Gz7hs9g++8nzKksyaL1Zy3PjjkSWZ06adyQsvP0NNTRWFBcW8ufQ1Tj9lBn6/D1mSKS0axPU3X8kffvNXTj35DNRqNbIk871TZ/LiK89SW1tNQX4Rb7/zBqdNm0EkEiYSjvD08wt44ak3U++JyRNO5Be/up76hjrycgv69n0yAD6DpX4IioWBb+7F1wLX9rpsIL8P+mNsotBQ2K+eRT59ecRiUZ578T889uTfCQWDuD1uFi1+jlkzLmDm9HO5/e6fMaiknI2b13Ltj27mysuuxdvqZXBZOT/7yR08+79/c9UVN1BWMoQ1n69M3W9pyRBWrfmYX950FydMOplHnniAPZW7GDlsLKNGjOf1t15m9IjxZGZmc8rUM5ABpVLFTdfdQnVtFV6Pm5df+x9Oewazzrww1YolSTKJuMTLry1k7MgJ7Ni1leEVY2hqbmLKcVO/8jxt3baRYeWjuPj8K3np1eeJRKIYDSZCoRB2u5O/3/ckzyx8knA40lXlPGYyv7/rr/z2T7cTjcS6uj5kmTNPP4cv1q1BlmH33l2cfOL39inS6lqFbtHi53ltyaJUZkelUjP30qtZ8NQjRKMxPN4WcrLyUoVzv7z5LqaecDrnX34Gf33oD6mshEaj5dILf8C/n3mMcDhCW5uXLFd2alqpM9CJ0WBO/Xy1WoNOq+tqD+vj98hACApkqatKXxziGOhHXxOZAmG/utKnfX+fGrWGS86/EmV3lfSWreu7TgQJGFQylJraqu7KYQsmvRkAlVKF0WBGq9FiMllQyAq0Wj2xaCw1RoWswOlwoVFpOen40/jbI/cyqKScN95+CacjAykhpfquky1bVosNWQKdVkc0GuOqK27gzt/9nAyni/t++wgqpQaAF199jvb2dn57x/2cf/npPPLE/Zx+8gy0av1XnqMPP36PrMwcmluaMJssfPTJMk47eQYKhYJsVx4mg5lRI8bh8bhRKtVkZmTjsDuxW+0EQ6HUmvt6rYEzTz+HV17/H8FQkBmZeb1/lgxTjz+NcaOPY+qU03q0oMF5sy5l1sVTqRg6gmknTmfj5nVdjzsBHo+H63/0M847+2Ju/OUPeeW1/3HReZcjS3DB9y/j/DmnM6h0KNNOnM5n61Yiy12tWw6bE7fH3dXaBUTCESRJIie7oM/fJwMhKpAkGamvH5cg9LH+mD4QmQJhv/qnJUv68pumSoNRb6KsZCg7d28jFA7R0dHBhLFTujsfpB7fHOWv/P0r45NlItEIkiTT4m5mwtjJPPnfhykqKCMrM49EIkEgGCSRSOD3+7sXxfmyHUmSZOobavnvY69itznZuHlt6r7XbVhDW3srBr2JeVfeyJP/fRSA+sY6vK2e1PWamhvJcGZx/qzLOO+sS/jJNf/HU889TkKSQKZrMR5JIpFIUFI0GFmWiEajRCJRcrLzMRpMvVpBL7ngBzz59CMMLi3/6nMpf/n8OOwu3lj6CpIkE48nMOiMnHvWxXz48buUlQwluaeFJMm88Mp/iUQjZGfmcc7Mi7oee6JrEyyz0cpZ08/j01XLKSkegpSQkBISSoWK6666mZdefTb1M9/94C3Om3UpDluGyBSIQxxpPPqayBQI+9Ufi7ds3b6ZEyZPY/OWDYwfOxkAh93FrTffzb+eehiXK5tbbvp/1NZWM3LYWPZW7sbpdDGoZCi1ddWolCrKBw2nsakeg95IMBRMjVFOyLg9zSxd9jreVg+Xz76aHbu28Pyi/3DatBnodAZikSinnTyD9z9ail6nJ8Phor6hlsGl5TQ01lFXX8Prb73EiIoxjBo+PnXfV8+9ib/847f8/i+3c8KkU3jovv/w8BP3M3bURK6f9/Puk1mC9z9aisloJh5PoFQq0esM5GTns7Z7GuDTNcvxtnqYc9GPMBktyJLMu++/iVar5Zfzf0M4FMKVkYXX25WSNxrMzDzjPCaPP6nXa9HQWEtZ8RDWbfyMmtoqWts8lA8Zwc5d2wiFQng8bi678CqaWxoJdHYSCgWxmG14vR6yXLk8/+JT6HQ64vE43585m+07txAOh/F6PcyZPY/WNg+dHR1EolFMxq7ai9nnzeXd95ew8KWn0Kg1KJUqbv7xNxdcHqqBEBRIkkyiHz5wBaEv9cfvn2hJFICvtiTmOAZTVt63BWT9yeN1c/s983n8bwvTPZT9uvevv2b6KWczcdzxqcuuvuli7vvtP3HanV+5fm19NW3tXiqrd3PuWRcfzqGm3ecfb8ZcGEprS2KucyjZeQfeOSII6RAKhvns809FS6LQ/7pS6ukexYHbvXcHudkFuD0tZDj7ZwvWQ9XR6UevM9DY3EAiIaFQKGnxNJGXU8ieyp3Yx3x1TYK161ezc882brruV0fU69AX0v41RQGRcIxgIJLmgQjCNwuH+v49KoICYb+OhP3ke5o49kQmjj0RYMCN22SwMP+a24HuIkdkXI5s7vq/rr3r9zfes8+Yzdndfx9oj6e/pTsoMDnU7N2xlZ174t2XHFvPf39ISBL/felhLjrrh5hNlnQP5yihQKlU4szT9+m9iqBA2K9koZUgHG7pmtFUKpWo1WryBzlw5unp7OxM6/4LR5N4PE7tYzsoGKPF5RJBQV9QKBRotVqMRiNarbbPthgXQYGwX9IRlikQjh7pOg8rFApUKhVGozG19LYICvpGLBZDoVBgNBoxm83pHs5RQaFQoNFo0Ov1aDSag6q7+SYiKBD2qytTkO5RCMei/ui9/jbJD1ilUklhYSHxeJxIJCKCgj4Si8VQqVSUlpaSl5eX7uEcFZJBrEajwWw2o9FoUCgU3zlbIIICYb+S6wAIwuGWrhNxz0yBJEno9fq0judokswUWCwWbDZbuodzVFAoumoKVCoVWq0WlUolpg+E/iNqCoS0SeP0gUKhQK/Xd+390X0I3100GkWhUGAymcT0QR9Jvl+TwUFfEUGBsB8Kmhs9RKOxdA/kiBSLR1EqlKhU4tfrULS3+slQ9G1F9YFIfsvqq7lZ4as0Gk2vjcaEgUd8agkpyajTVajHrWjHG27qLvoS35YOxtMLn6CooIRTThq4+7APTAoUgKPMiMlu6ZNUqCAIB0cEBUJKsiXLmWnDaNERCARECvUQGCxqLBla8oeIudODpVAoMJvNmM2mVEW1CA4E4fARQYEAfFlkpdVqcblcRKNRQqGQCAgOgdFoxGKxkJubm+6hHHEUCgUGgwG9Xo9OpxNBgSAcZiIoEFKSc6l2u120ZH0HBoMBg8GAy+VK91COOAqFAp1Oh1qtRqvV9mkBlSAI304EBUKKUqlEqVTicDhE9fV3YDKZsFgsoh/7EPSsqE4GqSJTIAiHjwgKhBSFQoEsy71WcxNBwcFLnsxEFfvBSwYA+/4pCMLhIYICoZe+WBHrWJecB1erxa+XIAhHFjFhJwgHqWu1x69fi1epVH7j/wuCIAxUIigQhIPkdrs5+eSTefPNN/d78k9OwwiCIBxpRFAgCAdJlmVWrVrFrFmzOOmkk3jrrbd6BQciUyAIwpFKTHoeIrfbzSuvvCK+ER6D/H4/kiQhyzIrV67k7LPPZsqUKfz6179mxowZIlMgCMIRSwQFh+j999/nrrvuYurUqekeinCYhcPhXv+WZZn169dzzTXXMH/+fDZs2IDZbObBBx9EoVBw9dVXYzQa0zRaQRCEA6eQxVeaQ/K///2PJ598kqVLl6Z7KMJh1tzcTH5+PolEAovFwrXXXsvNN9/MZZddxooVK3pd96yzzmLJkiVpGumxac6cObzxxhuprY+FgaG9vZ3q6mqx0ucAJzIFgnAIzGYz8+bN4+c//zn5+fkA3HnnncycOTM1daBSqbjjjjvSOcxj0sMPP8xdd92V7mEI+9BqtSIgOAKIoEAQDpLdbv//7N13fFvV+fjxj7asactL3nGmnTiLEAJJCCEQNmXPQmlLgVIa+JXSsgoEvqUtLVC+35YWaMsobSBAoFACBAgjkywyneE4jrflLcva0r3394csYWeQHdnxeb9eamP56urca6H73Oec8xy2bt26V8XC2bNnM2PGDL788svEz6eddloymjiopaWlkZaWluxmCMKAJGYfCMIhMhgM+yxhrFareeihh1CpVKjVah544AFRCEoQhAFFZAqEwyaGo+xt5syZnHHGGWg0GqZNmybO0T6IQEkQ+i8RFAiHTJIkZFmmZmcz3W4/seueuPjFXXHBjQBsWLkzyS3pX1SoSM20kF+ciVqtFmtDCEI/JIIC4ZDJskw0GuXTt9YzdFS++HLfQ2nxyYBCZ1Mo2U3pV6JRia+XVXL9nWei1WrF50YQ+iERFAgHLZ4KDwQCdHd3E5UiTJw6Eq1efIyEAwsHI+zYWonb7cZkMmG1WsUCXILQz4hvc+GQybJMJBJBlhUUBRRR0Vc4CIoCshTLMkmSlOzmCIKwDyIoEA5ZvPtAlmUUWRGD6YSDEl9dMhZQxspEiyyBIPQvIigQDpmi9AQCSk+mQMQEwkFQ5G8+OyKQFIT+SQQFwmGJf6nHug/EF7xwYCIQEIT+TwQFwmFT4KAzBfX1tTQ01vWZuDi6pAybzb7f13z86QeUloyhIL/oiNt6LEXCYb5Yupi6+hquu/omUlJSDntfLS3NrFqznIsvvPywXr99x1ZWrlrGySedwtiyCYfdjv2RZZlly7/AYrFy0sTJh/RaERMIQv8nKhoKRyQ+puBAj6wsJw/O/QVSNEpBXhGyJLF5y8a9tguHwlTuqkBRFDLSs0gxmg5q/70fPq+X2isuA2wAACAASURBVNrqQ37dgR6yJLNjx9a9nn/+H3+mqLAYuy2Vxsb6w9r3tu3lKIqCwWAgK9N5WPtoa2vlzbfnccG53+HrDWuP+vErioIiy3y9cS2btmw4rNcLgtC/iaBAOCJKz+yDAz20Gh0mk5nMDCc5zjxKR43lpAmTkaIS6zesY/OWjfi8Pv74pyf49LNFeLo8ZGZkoVZrCAXDVFTsoL6+jnVfryEakVi1eiXNzS4UGVpbW1m+YgkNDfVEwhF+/cTDrPhqKT6vD5/Xx/IVS6irq92rTc3NzSxfuZSuri4UGQL+AKtWr6By104UGWRJobx8M5s2bcDtdvOv119i/oJ5tLe3J/bR0tLM0uWf09jUwNiyiWh1eoLBENt3bMPn9RHwB6jctZNdVZVs3bYl8br6+jpWrFyK3+dn8+aN/PYPc6mtrUGn1eNIy0CRIRqJnZtNmzYgSwpSVGbbtnK63F0sX7GEaCSa2F8kHGXx5x/T1t5KJBLhhmt/yJbyTYnzJUsKOysraGpsZPuObX3OQ0d7O0uXfUFbWxuKDE1NTSxfsYRmV+z8SlGZzVs2snHjekBNRnoWsiyzfsM6GhoaDurvH38IgtC/iaBAOHwKh3aXqCh8uXQx/134Ns//40/o9QbeWPBvNGotW7dtprnFhdfnRaVS0e3t5pcPzqFi53a+WPopd993O1u3beGJpx/jhRf/RJOrgR/f+X0i4Qh333s7I4aVcNuc7xEMhvD7fahUakKhEC/983mKCoqZ8/MfUVVVmWjLlvKNvP/BO1hMFm75yQ0EAgEe//3DFOYP4eVXX+C9hW/z5dLFNDTW09beSkXFNnw+H4os9z1uGaSe5zweDw8+8nM0ag0vvvIc69av4b2Fb/PLB++kfOsmfvHAHJqbXSxb8QUrVy0jHA5z9723o1Kp6PJ0ASrefX8B//vs71Fkhd8+ORe7LZW161fz9P/9lvqGWm780ZV89uXH/Of9t3hjwby+mQxZ6mkb/OmvTyJFJRqbGrj/4Z/R0tLMrT+9kXcXLuCLLz9JvMbV3MS7C9/GmZ3LjTdfQWNjPQ89dg9DCody+13fR4pGefa5p9FqdLz5zjzeW7gAFIXyrZvYXb2LO372Q2RJPsi/f7I/sIIgHIgICoQjcqh3iVMmT2PWzHMZVzYRRQaTycLcx+8lOyuX3JwCMhwZ5GTn4czKZdjQUSgKjC+bRFqqg7Nmnsdpp0ynqGAoF59/BYGAH7Vaw8/v+hVfb1yL3+9Do9GSaneQn1vIjp3baXQ1sL1iG5d/51qi0W/urF97859MPXUGZaMn8OenX+Sr1cvRarRkZebw3Wt+yMuvvoDJZOGPf/4d/oCfMaXjycp0kpGeRardkdhPRnoWVrOVocUjycnOjS2GpNJgt6WCAuPHTiI/t5ALz72MUSNG09rWwr/nv8yMaWcx/bSZ/M/DT5GdlYvZZCYvp4DxYyehAE2uRsq3bqKoYCjXXXUT8xf8i5zsfLIynVx03mWce9ZF1NZVJ9qhUWvJzxuCIy2DNLuDRZ8sZEzpeM6f/R1Wr12BRqMlL6eASy+6mlt+MCfxuk8Wf4jP56OmtporLrkWtUbLHbf+nM3lG+n2duPu6uLrjWsZObyU++6ey1kzz0dRYEzpeL5zwZXIskw4HD6ov78sug8Eod8TQYFwRA61P1mn02M0pDB71gXUN9QydcoMHvzlr/nDM79m6fLPewYvfnNnGc8wxN8LVLEui57n3F2d/P3lZzl96plYrfbYa4nfOcsEg0Fmnn4211xxIyaTudddtULFzu0oikIwGCAUCtLS2oyiKFjMFsxmM8OGjOCZJ55n3vxXePOdebEpmPs6ZuJjK/Z9PuCb45dlhUg4QtXunYCK7m5Pn9fGdhZbXyLeHq1GS1qqo885V+2jHfS8lyzLtHe2EQ7Hyiw70tLRarR9Xv/NeZDRqNXMPP1srrjkOjo72vn3/JeYMf0sTCkmZFmmtm43wWAAozGF1rbmnj+HkmiHfNCfgWP2MRQE4SgRsw+EI9Lrmv2turs9dHZ1smHjOjyeLhqbGvD6ugn4/Zxy8lSuu/Im1Co1qbY0vlj6KSOHj6bT3UF7extWsw2Px0MwEKSjs532jja8Xi9dHjdNTY1s276Fjz5+H3dXJ1+tWk6qLY1Fny7kxmtvZvuOcn52722kOzK549a7E2294pLr+Nm9t7J1+2acWblceen1vPTqC6z9ehW7qnbywxtv58tln+FIS+eHN/6YpuZGbNY03vvgbaafNpPRJWMBCAYDtLW10NhUT8nIMbS0NvP2e/Op2l2J1Wpn4riT6epyEwgE6PK4aW9v45orbuT+R37GebMvZljxCGbPuoDmliY+X/IpRoORrq5OMtOzGVM6jvcWLiAzI5trr/geoVCIrq5O3G437R3tdHZ2IEVl1Bo1iqLQ0FRPc0szapWGi867jH/O+wenTp7O6VNnodcbes5XA+lpmdBTM+jsmedz7fcvoqZ2N6n2NM49+6LY+Vz0Xzo6O9hRsY2TTzqN2++6iZEjRnPJhVfS3tGGJEXxer14uj14PB4y0jMP/CEQU1cFod9TKWJI8GGZP38+L774IosWLUp2U46b+Eelo6OD9vZ2Fr60gUu/ew5a7YEXtmnvaMPn9/Z5Lisjm0AwQF19DWazhWHFI4hGo9TWV5OfW4irpRGtVodOqyUQDGCzpuLpdqNSqbGYLXR7PdisdtxdndisNvwBP5kZ2aiIpd+LCosJBANsKd/AiOElpNrT+rx/o6uB1tZmxo6ZgFqtJhgMsKl8Pfl5ReQ68+ju9lDXUINKpaJk5BgUFKprqhhSOBS1OpZk83R7cHd1oFZryHXmUd9YRyQSxmgw4nBk4PG4CYVDWC02ur0e9Do9zuxcqmur8Pm8jC4dhwqob6iNbd/dRTgcIivTiU6rY1P5eqwWK8OHjuoJrDowmywEggFkWSLXmY9Wq0VWZBoa61EUmVR7GlaLjfJtm1Cr1ZSOKsMf8NPe0Ypeb8CZldPnPLi7OtlZuZ2yMRNIMaawa/dO0nvakpOdh1qjZnP5BpxZOWRlOmloqgcUzCYLXl83VoutTyZjfyLhKO/M+5BLb5mCzWbD4XCgVqtFVUNB6EdEUHCYRFAQCwouue4ctDqx2p1wYJFwhP+89pEICgShHxPdB8IREfPPhYMlpiQKQv8nggLhiMTrFAjCgYjYURD6PxEUCEckPnJeEA5EZJQEof8TQYFwRHpPDxT2LzZ9T5UY9T8YiYySIPR/ok6BcETi88/FY98PWVZwuRq59c7r6PK4k96e5D6UZH9cBUE4gKRnCgbqF0W83QO1/cCRj/pWABmxdPJ+tLe3sK2inOmnnUkoFIyVAx7E52oA/6ciCING0oICSZKIRKKs/HgroUCk59mB861R8bULJZDCojdWJ7sph0iFSqVi9ORCcgszjnBKmIKsgHrg/NmOCr/fx4L//pv8nEIWL/mQc868mBnTzmbpysV0d3to72jhqku/x2O/v490RwbFRcNRq9Ws27iaJSs+5fvX/ZiiwmHJPozjbiAH0IIwWCQlKIiXV/X7AmxbW8+0c8cd4h7iF7EDfckc7HaH7pL8y7jkksvYu5P4WH7xHZ3jrt3ZTNW2RrJyU9FqtWg0h1dnQCH2txxsd796vYEtWzdg0Bu54apbuOMXN/Lmy5/w0Sfv8tgDf+THd1/P7DMvZsLYyTjSMsjJzkeSZTLTszlj6mzeeOef3DNnbrIP47gTYwoEof877kFBfF57MBiky92F3qijYKjzeDdjUPN2Bej0tBAIBDAajbFFfNSHN7xkMM4+UKs0GPRGSkeMZeTwMQwfWkJzi4vLLrqODz99F3/AF1vWWPmm5r9apSbPWYgkSfj8vkF3zkBkCgRhIEha90EkEoktRTsI7zSTTVHAH/ATCoXQarXodLoj2tdg/ftFJQlFVtDr9KQYzfzhT3N54Y/zWbjoLaJSbBljWZaJhCOxQYdKr0WTBuE5E5kCQej/khYUKIqCJMe/OAffF2QyKbKCLMnIsnzEd2+9l0UeTBQFvli6iJraKi44+wqyM3Iwm8z8/dU/kZaawdqvVzKmZCLz33mJwtyh2Cw2amqqcLU2olap8fv9pBhNyT6M42owfk4EYaBJWlAgyzKyJPXcaSarFYOT0nMHe3SCAmVwBnWKwpnTz2f0qPGJp5567MW9NptQdgoAf3j07wCUlZ7E2TMuAgZfMCyL7gNB6PeSPiVRZAqOv6P53SzLoB5kQZ2n200wFKSqeiclI8bFihIJBySCf0Ho/5IeFCgcfv9ql8fNJ599iEajITcnH5vNjsfTxcbNX3PrD356lFuafIFggH+99g+mTJ7GuLKJh72fo9mfPRgXRLJa7PzPfX+K/aDEPsPCgQ3GcRSCMNAkv6JhT6bgUB/VtbuZ8/NbOGP62Vxy4VWkGE28/Z/55DoLWLr888Pa57F++P0BNm5ef1ivXb12JQa9kebWZlpam4+oHUfzGq7IsWyBeIjHgR6DLHYUhAEp6ZkCOLy04m+fnMvl37kWR2oGigxjSsaj0+rRafWgwJp1q2hta+a8sy8GlYrNW9azu6aSk8afQkF+EYqisObrlTS5Gpg65QwyM7JodDWwddsmjMYUpp02k66uTpau+Jy0VAfTTj0jUeSnrr6G9s42WttasFqsnDp5OrIss3L1Uppbmjj37Iuoqq6kydXApAlT2Ljla0aPKuN///IEJrOFdEcWOdm5KEB9Qw3d3R527tpBXm4BJ0+cQrfXw4pVS5AlidmzLuTt915n4aL/cO/dj6DT6gkEgrz59jwmTZxCcdGhF8E5anf2PQGdWtwBCgdBdBMKQv+X9EyBchiZgmhUYvXaFYwYVtLn+eFDS1Bkhdb2VlDgtTdeYWflDhZ//hEVlds5a+YF/Oz+H9PQWM+/5r9IOBzhtFPO4LY7v4un28Nzf3+GmafPpq6+lnAozMv/eoFzZl3Iv15/kS+WfoosK0iSxAcfv8tf//ZHHKnp/Pr3v6K7u5vX3nyFgrwhmE1W7n/k/zGkYBh/fu5JdlRspaGhjsyMbAryhzBiaAkZjszYcUSizH/rVf70/JNoNTruvu82tm7fwu+eeoRhQ0ayZesmPl/yCcOGjiIzPYthQ0aCAtu2byHHmc+Dj959yOdOlpWj2rcbn30gHuJxMA9BEPq3fpIpOLQ7CEUBrVZHKBTe67WyopDhyGTiuMmMGF5Ca1sL8xf8k5/P+RUphhSmTJrK4i8W8eZ//sXLf11Aqj2VooKhrFn3FWaThRtvuZy7f/oAu6t3sWv3TlZ8tZTLLr6W/LyinvdSMXJYKe4uNxPGnkxmehZ+v4/FXy7CmZ2HVqvjikuux5Ri5rEHn+Sue3/EBwuWg6JCq9Wh0+lRqzQosoJapWZY8UisVjvnnX0xFZXbWL12BT+740FWr1tBS2sz3d5usrNy0Gi0aDU6FAUmjJ3EyRNPxevtPuRzFzt/R3dMgbgDFA7GYBt7IggDUfIzBRz6nS4KzD7zAr5Y8nGf53ftrkSRY8O+5J4LuCwrpBhN1NRVI8sKOp2BjPQs9DoDDY11yLKCwWAkPS2T66/6IXf9+D7ue+ROvD4vzc2NnDr5dGZOn40Ulb+5047V9439m1h/aTgUwpmVy4ypZ5GZno0sK9TW1zDrjPP557y/JV6n7HEsvZ8zGIykO7J49Lf3Mm7MJEYMi2U+FPmbi6+iKLEiOPLhnbtjMaYg+avviceAeIhMgSD0e8nPFBzml8Xdd/yKBx67i2ee/S3jyibh83uZOG4yO3Zuo7XVRUNjPfUNtezctZ1bf/D/+MP/PopBbyQYDHDG1NlYTFb+8venueay75GVmUPJyDIe+vXPuPqy7zHt1DMZXlxCUeEwrrhxNiUjy/jFnIcTF+eKym3U1FXT0FhPc0sTlVUVfP+7t3PLnGsZXzaJyy6+ltq6ato72vnJzT/n4mtOZ1jxKHKycnnn/fmUlU5g6JARscNXYN2GVZx80lSaW1zceM0tvPfBW7z46l/w+31sryhnXNkkNm/dwGdLPqamtgqzyUJ+ThFtbS20tDSTmZF9aKdcUQ79hO9nP56u7sNeO0EYXKJRKdlNEAThAFTKcc7pxaewtbe3U1/bwFfvNjD7smmHvb+OznaCQT85zvzYQMB9HY0KQqEQne52nFm5ifWC/H4fPr+PzPQsUMVKL7d1tJDpyEKr04ECre3NpNrT0On0vQ5i3+/h9XUjRaPY7WnfbKPqu30oHMRgMCZ+fv+jBbhaGrnwnMvJzspBrVYjSRKhUGw7SZLQ6/Wxn/VG9ukQp8nv2lZHu7eGMy6ciNVqxWw2H9SFPf5R6ejooKOjgy8XbsTTFkCWZTEpD1j4yZsUFQyjrOSkZDel31EBGo2G1OwUZpw/AZvNhsPhOMJVOgVBONqSnilQ4LD6xePS7A6wO2IZh/3FNwrodXqyM3Ni2/RslmI0kWI0JZ7TarQ4M3NjL+lpU4Yjq8/P33Yg5hTL3tvu8TK9zpD4vSRJ1NZX097RSnpaJipUibEG8RK4aq2aWH19w7ce36E40jhQo9Gg1+sZMTETr9dLJBI5atmHgaxzYR2TikcxfLIt2U3pd1QqFQaDAaPRiF6vR6vVimBAEPqhpAcFKCBLg/OCoigqrr38Bz0/qY/beTjcvl2VSoWiKGg0GnQ6HSZTLHARQUGM3+8nMzMTi8WS7Kb0OyqVCr1ej8FgQKfTHfaqnIIgHFtJDwoUYgP1BicVVnNq4qfjdR6O5PqtUqkwGo2o1Wo0Gg3hcBhJkgZtULBx40bWr1+P3W7H7XYnlqFOS0sjLS0t2c3rN1QqFVqtFq1Wi9VqRafToVKpRLZAEPqZpAcFKMqgzRQky5GWm1Wr1eh0OiwWC9FolMFY6jiuoKCAq6++mkgkAsB9992HSqXinnvu4f77709y6/qPeLCkVqvR6/ViLIEg9FNJDwqUQdx9kCxHIyhQqVRoNJpEQDBYg4KxY8cya9YsFi1alHiusLCQe++9F7PZnMSW9S/xACD+uREEoX9KelAQG1OQ7EYMLkfaTSHSvn3dcccdiaBApVLx+9//nvT09CS3ShAE4dAlPSiIjSkYnHeZyTJIb+qPmXPPPZfhw4dTWVnJrFmzuPLKK5PdJEEQhMOS9KBgMM8+SBZFVg65toGwf3q9nptvvpm5c+fy1FNPiZH1giAMWEkOClSEQ2FcDa3JbcYg09XZjc6R7FYMXL3HT8RnXlx19TU0tbopKSkhEomg0Wj69KMLgiAMBEkLClQqFRqtCnuBTGX9up4uhIGTMQgGQ9TWVTNyxKhkN+UQqFCpwGAwUpCVKsYGHCFJlimv6WRpeQsVjT70pVfx6/lbmFaayWmlWVhN+kRtB3GeBUEYCJIWFGg0GowpRkZOyqKrqytWKncAdXa/9957fLHiC86+7A8DZjR1/MJksVgwmUyJIjLigvXt4rMrJElClmV21rtZtq2VrXVeCrJSmTwqj+9MtaNWq+j0BllX0cKjr23BboRpozOZNDwdc0qsih+IgZqCIPRfx33tA4h9yfp8PjweD52dnfj9/gEVFPh8Pq655hra29t57LHHmD17drKbdFDiFyKj0YjBYCAnJweDwZCYNy7ExD+HsZUpY6tjNrb7WLG9jbWVnTisJk4e6WRUfhpazf7PW4vbz5qKZrbXtpGfYWRGWRaj820Y9NpEMCYCBEEQ+pOkBAUQK40biUQIh8MDrgDOc889xyOPPAJAWVkZixYtStwF9nfxeeIajYaUlBQ0Go3IFuwhFgjItHmCLNvSzOqdHej1BiaNyKZsSAYG3aFlhhRFob7Vy5oKF1VNHYzIMTGjzElJgR1dzxoA4vwLgtAfJC0o+OYubOBkCAC8Xi9lZWU0NTUlnnvttde4/PLLk9iqQxO/CMW7PQbzBal38SVJkujyhfhqeyurdnYSkdRMHJbN+KGZmIy6o/J+sqxQ5XKztqKZpnYPZYVWppakU+y0otWKDIIgCMmVtKAgbiAFBADPPPMMd999d5/nJk6cyKpVqwZMtiBuMF904p87WZYJhKKs29XBks0u3D6ZscWZTByeTarZcEynbkaiMjvqO1hX0Yzb62PySAfTRmeRk5aSKAkMg/vvJAjC8ZX0q9hA+sJTFIXGxkauv/56ampqqKqq4swzz0SlUuHz+UhNTT3wToSk6R0IBEMRNu7uYMmWZprcUUoLMzjvlFFk2E2JOEBJ/M+xodWoGVOUwZiiDIIRifLqNp7/qJpwKMApIx1MLc0k22FJrBswkP5bEQRhYEp6pmCgmj9/Pi+++GKfmvdC/7LngMFwOEJFYzfLt7VR0eij2JnGpBHZ5KVb+tUF1xuIsHF3CxurWjDp4bRR6UwanobdbEhkEEQNBEEQjoWkZwoE4Vj4JiugsKvJw5ebXWyp6SI3I5VJI3I5d3JsCmFi+2Q1dB/MKTqmjs5j6ug83N4g63e1sOjNHTgsGk4fk8XkkZmkGLQiIBAE4agTQYFwQug9YDAajVLf6mX5tlbWV3WRarVw0ohsZowf2WcK4UDIkdnNRmaOK+SMcYW0uv18vdPFO19tJC9Ny9SSdCYMy8Sg14oKioIgHBUiKBAGpN7jA+KPFrefNTs7WVXRgVarZ+KwbH504Yg+UwgHQBywX5mpJs6dPJRzTi6moc3Lqp0u3lyxmZF5Fk4b5WBUng2tVrPXNFMRJAiCcLBEUCAMWIqi4PYGWbWjjeVbWwlLGsYNzea6WeMx95pCOBAyAodGRV6GlbwMK5KsUO1y89EGF698VsPYIiunlzkZ6rSh0ahFmWVBEA6JCAqOA7/fz+uvv87WrVv53e9+h1arxeVy8eyzz3LttdcyZsyYZDexX4t3C8QzAl5/iLU721i5o4OuAIwuyuTS6WNjUwgTL0pee48njUrFsJw0huWkEZFkdjZ08NqSJrq8OxlfZGH6mGxy001otd90MYjqlYIg7I8ICo4Dk8nEddddR2lpKRaLhblz5+J0OsnMzBQBwX7s2T0QCkcpr+1i6dZW6tqCjMjL4KxJpWSm7jGFcBDTatSUFmZQWphBMBxla20b/1jcgCJHOLUknSkj03FYDYngQBRJEgRhTyIoOE7UajV33nknb775JmVlZVx55ZWJOzav18uCBQsIBAJkZGRw5ZVXJrm1yRXPCkQlmfLqdpaWt7LLFaDImcZJI4dw0am9phAqIhjYF4NOy8RhTiYOc+INhtmyu5Wn3t2FQRNlamkGU0ZlYjcbRFVLQRD6EEHBcWS1Wpk3bx4XXHABw4cPTzz/m9/8hquvvpqxY8dy7rnnMmbMGEpLS5PY0uOndy2BaDSKJMlUNXlYsaOd8jovWalWJgwr4OzJdjT9dAphf2c26plSmseU0jw6vUE2VbXw6Rs7SLeqOW2UgwnFaVhMhj7dCyJIEITBSQQFx1lxcTF//etf+d73vsell14KwJIlS7jtttvQaDRMnDiRTZs2nfBBQe/uAUVRaOwIsHSLi3WVnVjNZiYMc3LzmFEDbgphf5dqNjJjbCGnjy2k1e1jY1Uz763ZQUG6gRljsxlTaMeo14muBUEYpERQcJz0XgVy5syZ3HHHHTz77LM89thjjBkzhlWrVlFUVEQoFOKkk05KcmuPjT2zAq1dAZZtaWbtLjdarZFxQ7O5cXYxBv03H0sRBxw7malmzj5pKLMmFNPY3s0XW5p59bNqRjhTmDY6k1H5dowGfZ9FmgRBOLGJoOA42bhxI+3t7XR2dpKWlsatt96aGFPw61//mt/+9reEw2HOOussRowYkeTWHh17lhmWJAmPP8zanZ2s3NGGP6yibEg2V88s7jOFUEQCx5dapSI/w0Z+hg1JVqhpdvPh+mZe/aKOccWpnDYyjaIsCzqdts/qmiDGIgjCiUasfXCYxNoH3653QOALhFlX2c7SLc20+xRKCjIZW5xFqsWY5FYK3yYSlahs7GTjLhe+gI+ThzuYOjqTwiwbgMgeCMIJSGQKhKMmPj5AlmX8gRCba9ws29pKk1tiaE4608eX9F2FUISj/ZpWo6GkIIOSgtgUx+317Tz3US2yFOLkYXZOHZVOtsOCWq0WZZYF4QQhggLhsPUeJ6EoCqFwhMomL0vLW9jR4CM/M5UJI4dzvsOCWkwhHNAMOi3ji7MZX5yNNxhma00rzyysxWpQmFqaycnDHVhNOrGKoyAMcCIoEA5LPCCIRKPsbupmaXkzm2u6yUyzM35oLlPHiimEJyqzUc/kUXlMHhVbxXFLdQsfrNtGhlXN1JJ0Jo/MwmTUiamNgjAAiaBAOCjxbgFFUYhKEvUt3azc0cGG3V2YUkyMK3Zy07kl/W4K4ab1X7F+zTImnTKDsgmnJKUNbS1NrFn5OevXLucndz9Galr6Ib2+oW43f3/2Nzz0m+f7XYliu9nItDGFTB1TSFuXj027W3h3dTmFGXpOG+VgbLEDg67vIk0iUBCE/ksEBcK36r0kcWtXkJXbWvhqezuo9ZQVZ3P1mUMx6vrvx6hk9ETuuf0qrr1pzlHdrwKsXPIxU2ecc8Bt//7sb7j5jgfILxqGcgg5k86ONlyNtZSMmciO8g305zHBKiDTbmbWhGLk8UNoau9m6fZm5i/fwqhcMzPGZjMi14ZOq0kENiI4EIT+p/9+mwtJ03sBog6Pn6+2t/HVjnaCkpbRRdl8Z9oAWoVQpUar1aJSqQkGg6xa9imBgI9JU84gI9OZ2Gz3ru1UbNuIPdXBlOmz6e7qZO1XX+DzdTPr3Msxmcys/eoLuj1d5OYXUVW5jXde/xtWWypl42MZCAWo3L6ZqsqtWKx2ps44l4rtm9j49UpWfLmIWeddjsViIxgMsvyLD3HmFbJyySLOOu9KioaOZMOaZbQ2N5KWnknZhCk8dt+tjCwdR2Z2Hlqtjoptm/hq2Sdccf1tWK32JJ3QA1OhIjfdRm56bIpjbYubmCm/UwAAIABJREFUt79qpt29i9H5JmaMdVLstKLrWaQJRIAgCP1F/8pFCkkRDwKi0SiRSAR3t58vNzfxxFvlPP7mTuo6tcyePJYbzprIpBG5mIw6FBgwD3r+f9H7b2Cy2Bg6Ygxd7o7E7+vrdrPo/fmcdf6VvPr3P9Ll7uDpx+9hyunnkJM3hP+57xbqaqrY+PVKTj39HJpdjZSWTcKRkc2oMScl9lO9aweL3p/P2RdczdLPPmDxR+8wdMQY0hxZnDJ9NiaTFQWIRCK8/sqfKd+4FmfuEO65/Qq6PW7mv/osZ553Of/3+/vR6Q0MGTaKMROmkOrIJCpFCYfDqFRq/rvglaSf04N9qNUqhjjT+M5pJdwwezKpqTn8e0kLv3p1M28urabG5SYUCvWUuJb6dTZEEAYDkSkY5OIBQTgqs76ylWXlrdS2hSjOyWBy6QjSbd9MIYxtn7SmHpZ4exUFRo89mV/dfQMzZl3M9398b+J3q5d/hjO3ELVaw/+99AGuhhoa66tJSTEz7qSp/ObBH2M0mVm3agnVu7bzk58/TiQS7pmKp03s54tP3iU7txCVSsUZs7/D+wv+yazzLketVqPT6UGlQlHAZLZid2Qw5fTZ5OUX8/orf8Lv93Pd9+/i84/fJRQMIMsKarUGjUYLqtj7lI49GXdnO1s2rhpwfweIreI4Mj+DkfkZBCNRdta385cP60AJceooB1NHZ5NpTxHdC4KQRCJTMIj07haIRCL4A0G+rnDx5/fK+cU/1vNFuZeSIcV875yTOWNcMelWU2wK4UB/EPt/nd7IC/O+xNPVyYLX/pb4vdWexpqVnyPLCk31NQT8ftrbmgmFQoCKjOxcZFnh8WfmcfJpZ/H043cn9inLSmI/9rQMqnftQFFApdKQmz+k53fKXm1CAaXntTZ7Gl2d7SyY9wJnnns5KSZL7DWJ95B7/n4k/n+gPwxaLWVDsrlm5jguOm08rV4jTyzYySOvrmfhV7tp6fAQCoWQJCkxwFUQhGNPZApOcHuXGpapafWxdEsLm2o8OGxWyooLOLXMjvoEnEJYvmkNKpWKrZvXUl9TSSQaYXjJWIqGliSOceoZ5/PfBS9z5w8vYNKpZ/K9W+/h8utv4x/PPk7BkOHc8KN78Ho9/PfNFzn5tFmcfNos7HYHLa56Vnz5EVNnng/AORddw6/vv5VF/32dxoZqrr5pDs2uero9nWzZuJqpM85D3dOHrigySxa/T5Yzj9kXXoMtNZ2qynLenvc8AGtXfcmQYaV88J9XMZmthENBanbvoK5mF22tTYQj4Vj24QRgMuqZNDKPSSPz6PIF2VrTwsdvVpJt13B6WTbjh9j7THEUMxgE4dgRZY4P00Apcxxfc6CxPTZOYH2Vh5QUM2VDsil2OvpMITzRybJMOBQEwJhi6vM7RZHxebux9BrA5/d1o9HqMBiMxMZcRAgFA4ltotEIWq1uj/0odHvcWKz2b50++MCd13DrXXPJcuZjMlsBiIRDaLU6JElCq9Pt9z0Gi7YuH+XVzex2tTEkU8/pY7IoG5KGyWgARJllQTgWRKbgBNJ7+mA0GqXNE2TltjbWVLqR0TG6KJsrzhiBXvfNgjaDKSJUqdUYeoKBvY5bpcZstfd5PqXnYq0AqFRodXq0On1iG41Wt4/9qLDa0/b9Hj08XR14ujpprK+maFhpYjutPnax06jV3/4eg0S63cyM8UM5fVwxro5uFm9p5t9fNlCSb2bqKAcj8mwYepZ5FrMYBOHoEEHBEYhffPuDeMLHF5L4ansry8pb8IbUlBRmc96UQkyGATKFcBAwmWz84a//QaVWi7/FQVHhdNhwOmzIskJdq5t31rhwf1bLhGI7p5dlUZxtQzOIsl6CcKyI7oPD9M4773DdddfhcDiS3ZREQJCaPYTRVz7OEGc6syeNJNWSkuSWCcKxE5VkNlQ2sHhDJROGWPnlFWPQ6/V9lnYWBOHQiKDgMEUiEXbv3t0vRkXHR2h7vT66FQtLtzTj8ukpzMlmzBAn2WkWkVYVThi+YJgddS1sr3FB2M24AiMzxuWTnZFKSkoKBoMh2U0UhAFLBAUngEgkgiRJ1NfX4/P56OzspMvjpc4tU9GmJqhxMCzfyeiibNJt5mQ3VxAOWSgSZWdDG9tqmvC6WyiwBhiaJpOZasZoNJKZmYnD4cBqtWI2i8+4IBwuMabgBBAf5W6z2dBoNIl57SnGMIWpQQIhFzUdzXxQpYOUTEYW5FBamIXNbExmswc8WZZZ8cVCxk2ajq1ncOGRUhSFzetX0NrcgNWWxinTZh+V/Q5EUUlmd1M75TUu2lqbyDX5GWMLkzFCj1arRa/XY7PZMBqN2O12UlJS0OkG50wNQThaRFBwAlCpVKjVaoxGY2Kall6vjxUo8vsJBoPYrWGGOXwEo/XUtbj4T6UBrSmDksIcRuVnYjKeGHPej6bN61fQ1tzImeddudfvOtpcvL/gRd6Z9xeee30FVtu3BwWhUJAvFr3F0BFljCidsN/tKrZuYOvG1Vz1vbv46Y0zKSweRXZO4REfy0AhyTL1rV2UVzfR1OLCmeJnmDXEKUMV9Ho9Wq0Fq9WKTqfDaDRiNpvR6/WYTCZ0Ol2/W0VSEAYaERScAOKBQEpKCnq9npSUFKxWK9FoFJ/Ph8/nIxAIoNFoSIlEMBvCDLV78Ia62F1Vw/pyM7Y0J6VFToblZmDox6seHi3hUJCP3v0n4VAIqy2Vcy+5ca9t/L5uutzt+5wSaLWn890f3cuaFZ8mqibuS1dnGwvffomKLeuYftYlFA4t7bNtNBLho/+8QjgcQq83cPrZl1EwZCSoVOj0ejRa/Qk/JVGRFVyd3WytcVHT2IRd1ckQW4gxeTIGfSwrYDAYEp/v9PT0RCBgMBjQaDSJAYYiKBCEI3Pif/sPAvFBhFqtFq1Wm7iLkmUZq9VKJBIhGo3i9/sJh8MEAgG6u7sJhUJkO3xEIkG6gtXsrKhh1UYT6Rk5lBY6GXICFzda/vlCurvcXPuDn7N08X/6TA1sb21CikbpbG/F09VBc2MdKrWajKzcxLnW9CooFC9H3JuroZp35j2L3+/lvEtu4tof3JN4be9t165cjKuxlh/+dC5ffvw2ttR0Tj3jQiq2fs20M7+DI8N5Qk5bVBTo6PaxtcZFVX0TJrmTYY4oJQUSphQDOp090S2g1+uxWCzo9frEZ1uj0aDVakWVQ0E4ykRQcAKJfynG75biX5ixBXliqdVIJNKzlLAq8e9wOExKSgSbwU9U6qLN62Z7eRXLNlhxZjkZXeQkLyO1TxnkgW7spOm8O/85zNZULr76lm/uxhVY/MF83B0tNNbtxtvtxu/rxmA08d1b7kOj3eM/mfg6Bnvsv3zjKuprd3HND35O6bhTYosh7aMdJWNP4Y1XnmHBv//M5TfMSWzT6mro8/MJQQGPP8j2umYq61xowm0U2ULMzA5j1MeyAVptrEsgfvG32Wx9ugc0Gk3is9x76qEICATh6BCzDwaBPdc/iC+RLEkSwWCQQCBAKBSivb09kUkIhUJEJYlGt0y1x0CXkkpRbi4lhdlkp1kH9pewotDe2oQtNZ0H7riEu371J/KLRuy12Zpli2hqqOY719y23139v++fyQO/fYWsffT7ez1uPnr3FbZtWsWpp1/AjHOuwGDsVTtCUWhrbSLNkcnD/+8qfvDTRxleMh6A1uZ6MrPzj/xY+wF/MExFfQsVdS4i3mYKLQEK7RImgwaj0YhWqyUlJQWLxYLRaCQ1NRWdToder8dgMKBWqxOBrMgICMKxJTIFg0DvL9F41kCj0aAoCjqdjpSUFKLRKCkpKUQiEYLBIH6/n0gkgsXsoTgrQjjSTr2ngxWrK/CpUhmWl0NJoZM0a9+llQcCb7eHpx69nbMvvJ6M7DwcGTn7HBSg7PWPb4RDQT7+76s01lXx7uvPcd5l36egaGSfbSzWVK684S4ikTDLFr/Lb+67iRtuvZ8RpROB2ODDp+bexjkX34AtNT02oFCBzo5WnnjwZp78W/9eV+PbhCJRdjW2sb3Whc/jotAaYkpaFHM2GI2xWgJGoxGLxZL4DMYDBJPJhEajSYwRiGe8QGQEBOFYE5mCQSr+Z48vmCTLciw7EI0SCoXw+XyEQiE6OzsJh8OJDIIkSfiDERq9Omq8KSjGTEbk5zCyIAuryThgAgRZkggEfJjM+896dHvcRMJBHBnOo/Ke8UWVeq9uKMsyAb93r3YE/F5STJaj8r7HS1SSqXa1s73WRUd7E06jl0JrCJtBSdz5a7VazGZzYuaAzWZLBAXxMTF6vV5kBQQhSURQICT0XlAp3r0QCoUIh8NEIhHcbjehUAiPx0MwGCQajeLxhajp0lLtMaC3ZDOywMnwvCxSDGK++GAgywoNbW6217poamkkU+dhuEMiw6xKXOx1Oh1WqzXRPWCxWBIDYnU6XWLciwgCBCH5RFAgJPQeeyBJUiI4iEajSJKEz+cjHA7j8/kIBoNEIhG8Xi+RSIRwOIwnIFHnNVDjMWK2ZTGq0ElxTgb6PQfnCQOaoii0uLvZXuui3tWEQ+uh2B4m0yyjUasTUwUNBkNigKDJZEoECPHZA/GHyAoIQv8hggLhW8mynMgehMNhJElKdCWEw2E6OzsTgxUDgQDRaJRwOIzbHxug6ApZcKTnMqrASWG2A62YRz4gKcSmEFbUuahuaMIkt1NoDZBnA61GnRgUqNVqE9UFzWYzZrM5UWeg96wBEQQIQv8kggLhgHpnEOIzGCRJSsxeiEQiRCKRxDiE7u7uRNAQDAbpCKip7NDQHLLgzMphVIGT3IxU1OKi0O91+4NU1Dezq74JXaSNYnuYolQFvS5WJ8BisWAwGLBYLJhMpkTxrG/rHhDBgCD0XyIoEA5Z7+xBvHshGo0mAoHeQUF8FkM4HCYYCtHm11LdbaAjaic/O4eRBdlkpQ7wKY4nEAUIhMLsamhhZ70Lgq0UWALkW8KYjdpYVcyeyoI6nS5RVMhisSS6B+LTCHt3D4CYOSAIA4EICoQj0juLEI1GkWU5EQREo1G6uroIBAL4/X66u7sTsxtC4QgN3Wp2u/X41ekMycthZL6TVIsJce04/sKRKLub2thZ78LX1USB2U+hNYzdrEvMCIhnAhwOB0ajEaPRSEpKSqK6YO8KgyCCAEEYiERQIByxPbsX4lMcZVkmEAgkggSfz0ckEiEQCCT+7fP5CEdl6ru1VHXqiOgyKM5zMiIvG0uKkQEzx3EAkiSZ2pZ2KupcdHU2UWAJMsQWwp4Sq2URHx8Qn0UQzwTExwns2T0Qr6QpggFBGLhEUCAcdfHgAEgMToyPPwiHw3i93sTaC/HsQSQSIRQKEYwo1Hp01PlMaM1Ohuc7GZqbhVEvpjgeDYqi0NjmZme9i+bWRrL0HoqsQdKMcmJRIaPRiF6vT2QF9Hp9orZAfNBg78JCIAIBQThRiKBAOC7iAxTj3Qy9F2kKhUIEAoFEoaT4eARvSKayTUWdz4TJFgsQhjgz0Wk1B35DIUEBWjs97Kx30dDcSLq2i6GpEbItCkajMTEOwGazYTAYEosQxZ+PrzcgBgoKwolPBAXCcdG7MNKeVRTjFRO7u7sT3Qu96yBIkkRXUGF3l54Gnxl7mpMR+U7yMx1oxBTH/er0+qisb6a2qRGb2k2xPYzTFEGv1yUyAfFCQvEKg727B+JdBCqVSgwYFIRBQgQFQlLsWWY5PgAxGo0SDAYThZLa2toSYxJCoRCSJNHqlanxGGkO28jOymVYnpOc9FRxsQK8gSC7GprZ3diEPtxCkTVIniWCIbEKYSwAiBcTSktLSxQU2ldWQC2CLkEYVERQICTVvqooSpKUKLMcH5AYDAbxeDyJMQmRSCSximNVl562iI287FyG5zvJsFuTfFTHVzAcYXdjM1WNLpRAM8X2MEPsUQw6daJ7wGQyJZYhNpvNfboH4qsQ7llqWARZgjD4iKBA6Dd6dzHEuxfiayzEByXGg4J4VsHn8/VUUYzQ5NNS052CR0mjMCeHYXlO7GZTsg/rmIhIEjWuVnY1uAh7XRRY/BRZw6ToSHQNxIOBeEGheFBgMpnQarUiKyAIwl5EUCD0a/HBibIsJ2YyhEKhxJiDtra2RJGkYDDYs4pjiLouLbs9BiL6LIbk5DA0Nxuz0ZDswzkikixT39pOVYOLrs5GclN8DEuLYDOqEnf98cWH4rMF7HY7Go0mESTsud6AIAhCbyIoEPq1fXUvxCsoSpKU6EqIL/ccr4cQCoWIRCL4Q1HquvVUuXUoxiyKc3MY4szCMECmOCqKgqu9k6rGZtraGsk1+RiWGiEtRUGj0fTJBPRefCgeIKSkpCQGCorFhwRBOBARFAgDRu8AIV4cKd6NEIlEEt0Lbrc7Ma0xEAgkxih4QzK13QbqfWaMthyG5jopyM5Eq+l/UxzbujzsbogtR+zQuCm0+sk2K33u+rVaLTabDYfDQVpaWp+BgvE6AppexyYCAUEQDkQEBcKA1rtQUiQS2avMstvtJhgM4vV6E4MWQ6EQbr/MLreWBr8ZW2ouQ3Od5CZ5iqPb62N3Y2w5YruqgyJbiMJUFTqdtk8GwG63J/4dn0VgMAzsrhFBEPoHERQIA17v6Y17ruIYL7McDAYTizP5fD6CwWBibEJnUM2uTh2NfhOO9FgGISvt+Exx9AWCVDc1U+tqwqR0MNQeJt8mYdTHBgLGBwfGpxH2HjwYX5MgPmhQEAThSImgQDjh9J7FEJ/aGA8M4kWSfD5fYg2G2OyFMKFwmFafhmqPgQ4pleysPIpzsnHYbUd1CYZgOEytq4WaJheqYDOFFj/51jBmYyztbzAYEjUF0tPTMRgMmM3mxJLE8UAgXmZYdAsIgnC0iKBAOOH1ziTEZzHEByvGyyz7fD48Hk+i5HIoHKG+C3Z16ujGQW5WDkU5hz/FMRKNUt/aRk2Ti7C3iSJrkCH2KGlWQ+JCb7fbE+WG4+sM9F6FcM86AoIgCEebCAqEQWHPGgjxR3yWQnzcQXx6Y7z8st/vJxJVqO+OTXH0qxwUOHMozM7CnGL81veUJJmm9naqm1z4PS4KLAGKrCFsRhKZAKvVik4XKzsc/3e83HA8WOhdZlgEBIIgHEsiKBAGpd7rMMiy3KfMss/nw+/3EwgEcLvdid+Fw2H8YYndnWrqvCZIcVLodJKf9c0UR0VRaOl0U9PkorOjkWyDh2JbGIdJSQQC8QGCBoOBjIwM9Hp9ossgPnsgnhUQBYUEQTieRFAgDGp71kGIBwiRSCRW56BncGI8kxAKhWK1EaJRvEGZXR1qaruNaIwZGLRqunweMnVdDHdIZJhkjAZ9YqBg74qC8QDBZDIlygzvmQ04WlmBuro6HnroIfLy8rj//vsxmUy88MILdHR0MGfOHKzWwVUWWhCE/RNBgSD02HMVx3j3QnyRpngdBI/Hk5j2GK+DsPyrNSxc+D6PPvIwet03iw/FpwvGqwvGZw/EawnEuwfigwaPlc8//5xf/vKXLFu2DIPBwDPPPMOPfvQjLBbLMXtPQRAGHm2yGyAI/UXvNQDiU/yMRmMii+BwOJAkiWAwmHh0dnYSDofJc2YihYNkZWaQkpKC1WpN1BTQ6XSJcQPxrMDxXnTozDPPZMqUKTz99NPMnDmTCRMmJAKCzz77jMbGRrZs2cLcuXP56KOPUKvV1NbW8tOf/vS4tE8QhP5BBAWCsA+9L9a9L+CyLCfu8ONZgEgkQnFxMaFQiLy8vMTv4mWG40FGvMpgslYhfPzxx5k+fTqyLPPAAw8A0NjYyBtvvMHVV1/NG2+8wYcffsjLL7/M888/T0FBwXFtnyAIySeCAkH4FvELd/yCDiTu+iVJwmg0IkkSBQUFhEIh0tPT+yw+1HsVwmTPHLDb7cyYMYMRI0Yk2lJVVUVOTg7Tpk1j2rRpaLVaFEXhnHPO4Qc/+AETJ05MapsFQTi+xNBmQThIvbsXdDodRqMRi8WCzWajoKCAaDSKyWTCZrNhMpkwGo17ZQeSrXdZaIAhQ4bw1ltvUV1dzc6dO9mwYQPp6eksX76c9957D5/Pl8TWCoJwvImgQBCOkEqlIiUlBYBQKNQvsgL70tLSQlpaGp2dnYmLfX5+Pg899BBz5szhgw8+YPz48SxevJjFixdz6623Yjabk9xqQRCOJzH7QBCOwOrVq1m5ciWtra08+eSTXHnllUiSxOmnn85PfvKTZDdPEAThkIigQBCOwKZNm5g8eTLhcDjxnFqtZsmSJUybNi2JLRMEQTh0ovtAEI7AuHHjuPnmm/s8d8oppzB16tQktUgQBOHwiaBAEI7Qww8/THp6euLnOXPm9MsxBYIgCAciug+EpDjRPnZPP/0099xzD/n5+VRUVGA0fvtiSUeTCEAEQThaRKZAEI6C22+/nVGjRnHLLbcc14BAEAThaBKZAuG4kmUZRVGormhi9zbXCZUx+HLpF5SMKiU7K/u4vm/hcCdZuanHbP8mqxG9QSsyEoIwCIigQDiuotEokiTx4eurSTFYyHDak90k4VtUbWskd7iVSaeP6rOSoyAIJyZR5lg4bhRFSawu6PN5GTaymPzizGQ3S/gWng4fHo+bYDCIwWDoV9UZBUE4+kRQIBxXkiQRiUQIBoM9yxSLRFV/pijg9/sJh8OJhaAEQThxiaBAOK5igYBMNCqhyAcXFMTvSw+05cFuN1D0h+NWFCXR5SN6GgXhxCeCAuG4igcFsQGHoMgH8ZqD3fcRtaz/6Q/HrSj0+nudaGdYEIQ9iaBASBpFVlBE90G/JuIAQRhcRFAgJE3vTIHyLfe7qp4EeXybjo62xMVKp9Nhs9n3ud3B7G/P1xxoHz6flx07tzFpwinfut2B9qtCdUjt7P1z3MG0ub2jjXRHxl7bHexxi+yAIAwuoniRkDTxMQWyrKDI7PfRextZVthZWcH5l81ge8U2Pl78IT/88bW0tbUe1L6amhr32l/v1+xvHx0dHQSDITZs/Jonn3n8gO91oP0eqJ3fto/4Y+26VbS0NO+zLR0dHfzm94/w4ztv2u95PJjjFjGBIAwuIigQkiaWKVAO6YEMI4aVYDQYOW3ydC6/+BpysvN4b+ECFDk2KK7J1Rib3SArBIMBWlpc+P1+3O5Onnj6MXw+X599en1eAoEA7e1t3zzn9dLkaiQajRKJRHji6UdpbW1m+LBRaDQaAgE/nZ0de7UvGo2yuXwDq9eupKvLvdfv3V1u2tpbD3ickiRTvm0zq9as2Of7KLLCspVf0tTUuM/f1dTu5rKLr0aWpEM+x3ueb0EQBg8RFAhJoygKssIhPxQFQuEQu3ZXsnrdV2zeupFTTp5OKBTipVdfYNv2cm669So6Ojv4y9/+l5raal759wtU7qpg05b1bC7fELszVmDDpq+54rpzefb5p7n2+xfz7vtvsWt3Jb97ai7LV37J4394mOZmF19vWMu69WuIhCN0dHbwxtvzuOm2q6hrqIu1q+dO+69/e4aqqkoam+r5YNF7fdrd1t7GE08/il5nOOAx/nPe39iwcR1dXW7efGfefs/D/s7h2DEnYbHYUVAljvWQHvHMgUgVCMKgIsYUCEkTS1Ef+kVH7rmL9Xg8tLW3olFraGpqwOVqpK29heKiYZSNHk99Qx2LP/+IkcNKuPSia7GYraTaHZw84dRYWlxRGDm8FIPBwJ2338usM87j8T88yLNPv8zFF1yBy9XIzsrtOLPzyMzIYuqUM5AlCbstle9e/UPq62vYVbWTXGd+om16nYGVq5dx392PYjKZ+xzfQ/9zD42ueh549O4+x6MC7v7pAxTkD+mzn6/WLGPuA7/njOmzE/sJBgM88OjPkBWZHRVbWff1V9hTHQwvHslPb7tnj/OrQE/wcLj9ACImEITBRQQFQtLIh1m8SJEVDAYjZaMnUDZ6Ah0d7fzjn3/hqstuwGqxM2Pa2Uw/bRYeTxd/+PVf+L/nnuCTzz/gsQefAhRkGVDF3leWQaPRoiiQ68xHq9XS3t7Ol0sXc+Wl17Pg3dd67pi/GQOhUqmRZQW1WoMkSX2O4fvf/TH/Wfgmc37xQ/7+5/l9fveLux7mhZf+j4fv/R26fRQB6r3tVZfegM2axq1zvsu8f/w38Tu93siTj/8VgGdfeJIzpp9N2egJe70+dp6IHa+kwGEWIRSZAkEYXET3gZA08UzBoT58Ph+RSJi2tlbqG+r45LOFnH/2JUyeOJV5b77ES/96juf/8b90ez18tWYZTz3+PH6/H1Dh9XazbsNqZKl3P38nPq+XjZu/5oJzLmP12hV0ez1s2bqJ9o426upq0Gq0rFq7AneXm3A4hCwphCMRQqFQYj+r167g3YVvMfWUGbE7dKlvu/Nzi7j95p/T1tH2rce3bfsW/v3GS5w88VR0Ol2sRsC+tlX2fw6DgSA7d22nrb0VV3MjUnQ/+zjQQ8QEgjCoaObOnTs32Y0QBo9wOEwkEmH7hhr+f3v3HR9HdS58/Dczu7NFK616tyy59wIGjDEdTAkBAyFAuKQQkjcJN5fkzU3Ivcklvrl50xsJJCGQQEiBQAodTLl004txt8FFLpIla1VW2tXu7Jzz/iHt4iIb2TJarfV8P5/5WGvNzjyzu9p55jlnzqmoqCKUH+wbfWeQi1Kadzau4+g5x9O6ayft7W18aNFFnHD8qeQFQ5x0whls27aF0046i6qKWlp3tfR3uruMonAx4+onUlJcRlG4GHTfBE33PXwPNdV1+Hx+Fp36YSaMm0JPd5TZM+dRXzeBqZNnMmv6XLTuK+uPq5+Iz/aTHyqgIBSmsrwaMAgE8ti5s4ntO7Zx5eWfJS8Y2if+UF4+oWD+AY/RZ/tpa2+jsXETV176GfJDBQOuF4/HqKmuIz9v39/vbGmmqXk7C449hbZIKzXVdVimdVCvNRp2NbeTUF2MnVCFbdvYto1pyrWEEEcqmSVRDButNdFolFgsxj/+9BydAAAgAElEQVRvf5ZZM46moqYkqzHF4zE+/rnF3H3boxhystvH2uUbibrbOensowiFQoRCISzLynZYQogPiPQpEFmjtT6kjoaH09btW7jikk+zvWkbNVVjshrLSCSXDEKMLpIUiKzpGzQnuzGMr5/C+PopQPZjGYmkkCjE6CJJgcgamftg5NOKQ75zQQiReyQpEFmjNH23y4kRS2skKRBiFJGkQGRN333/2Y5CHIhWWm5cFmIUkaRAZI1WUikY6aRLgRCjiyQFImuUqyUpGOGkz4cQo4skBSJrtJYe/yOdVAqEGF0kKRBZo9TgKgXpfm7vt+Zg18sVI+G4tSRtQowqkhSIrDAM2L6lifa2zmyHctho5YJhYhhHTnf9SGs7RQ0cUcckhNg/SQpEVlSMC9C+s4VIIgFaHxFX93f85RamTZnJvKPmZzuUITPoSwSC1QEKKwv6/k8SAyGOeJIUiGFlWRa2bVNRU0JhaYh4PI46QjoWmD6XgjKbsVOyO5/D4WIYBnl5efj9fmzbxrIsSQyEOMJJUiCGlcfjQSlFSUkJjuOQTCZzeijdZDJJNBpFKYVpmn3THPcfT2VlZc7PKOjz+TKzI8pESEIc+WSWRDGsXNfFdV1isRhKKVzXzXZIQ9Lc3MyCBQvo7u7e4/+PO+447r///py/srYsC9M0CQaDmZ9z/ZiEEPsnSYEYVumP2+5X1Lnuuuuu46c//WnmsWEYPPjggyxatCiLUR0+hmFkKh6SEAhxZJOkQGTFkfSxa25uZurUqXR29t1JsWDBAp599tmcbzrYnSQDQowOR863lsgphmEcMUtVVRWf//znM8f1zW9+M9Mp70hZhBCjg1QKxCGTj857WlpamDJlCpMmTWLZsmVHVJVgqCSpECJ3yN0H4qCl+wPEYwmSCUeSA8Bj+vjElZ/iqKOOpiMSzXY4WWcAGAa+gI3fb+/RL0EIMXJJpUActFQqheu6/OFHT+D12pimXAkCOKkEluXFNOTkB5DodSipzuPDV87HNE08HrkGEWKkk79ScVC01vT29tLd3U0q5XDhJ07B45WPkdhXW0snzyx9ic7OTvx+P3l5edJHQYgRTr7NxaCli0qu6+I4Dq7ropT0LRAD0wqcVArHcfB6vdkORwgxCJIUiIPmui6JRALXVWilZfpjMSCtNY7jkEgksG0brbVUCYQY4SQpEAdNa91fHehLCPQgpj8Wo49WQH8VSapJQuQGSQrEIdH9MxtqpVHyhS8GoJUkBELkGkkKxKHT/cnBB9F8oKGzqwOv18br9eD12h/ATvbV2roT2/YRDhe+b3xbtm6mqqoa+zDEppRi85aNjGuYMORtjRRKcgEhco7cOyWGRClQSh/25aabf8rDS+/nvgf+xhe+dNWgnxeJRA5pf5FIG11dXVz71f/DmnWr3nf95p1NfPKzH6Wzs/OwHO/zy57hq9/44gfyWh5wcQ/9NXu/JV0pEELkDqkUiCHRH8CXfyqV4oFH/sk/7nwMn+0jGMzbYx/paYozMfSXp1evXcEbb73KlZd/et849+rkppTCMEwMA7Ztb+TeB+7hXz/3FSaMn9zXJOKqAdZ/73a6stIKqqtq97vu7vHt/dyB4p8+dRaWaQ34Wg54vBqM/YwPoZXe43f7PF/p9OhCLHv5GSKRNj587kUDbmsopNlAiNwjSYEYkr6rwsO7TdOwmDp5Jhdetohvf+OHLDrtPJSCVWuW88prL6KUS2dXJ5/91L/y1W9cQ92YBlateZuG+vH09HRz/LEnMa5hIinH4Se/+A7tHREiHW10dLZzx2//wV1/u4O8YB5PPfsYX/vyt3ho6b289sZLrFz1Nmh44aVn+cvdf6C2Zixfvubr3HL7jYyrn8CadSv54ue/lolTa81td9zM088/zjlnns9nPvlFlnzvOo6bdwKPPn4/N/7kNu6481Zqa+p47fUXue7/LuHv992Jx+Plvofu4Yf/cyNr1q9k85aNRKOdmVs803bs2Mr9D/+dwsIiVq5ezte+dD3//o0vMH3qLDZv2UhtTR1f+bdv7rH+I4/fTywew3VdrvnMl/ntbb9kbN04Hv/fh/mvr3+XjZveYfuORjZueofzP/QR7rrnjxSGi5gzcx41NXWH9X38QJqVhBAfKGk+EEOi1XvVgsO2aPjekhu4/JJP8pkvfoxv/b+v4aZcvv+TJVyy+AquuvILLHvpGZqad1BZUc0J80/mj7f8k6PnHMf0qbNoGDsBrTSW5aG2ZiwTx0/h5hv+TFlJOc8+/ySV5VWcMP8UvF6bd95dz7w5xzGufgJTJ89Eazj2qAV86+vf5/U3XsJxHB578iFCefl8ZPEVe8QJ8C+XfZo7f/8gf7/vTqLdURYcexITx09h4+Z36e3t5YmnHkG5iisv/wybtmzk5ddeoCA/TH3dOJaveIPf3HoDV3z0Ki6/5FMYhrnH9n/+qx9w+ilnc+lFHycajfLGW69SVVHD/HkL+c5//ZSXX31hj/V/efOPOe/si7j649cwZ+Y8Hnj4H4QLivjQWRdy/LEncsttN7Jm7QpWrl7O5Zd8gsryambNmMvc2cdQXTXm8L+P0nwgRM6RpEAMyQdxInFdl42bNnD5xZ/g8fte4bU3X+aNt15h67bNpFIptNKMqR1LpD0CGNhe3x4Jxd4Jht8fQCvNlEkziMXjRNojrFj1FvV141FKoTSZ54HGNC0Mw0RphWV6WPKfP+KmW37Kz276Hqp/bIa+dQ0MTAL+IKUlFThJh5Wrl2OaFvmhfLSGb3/jx/zzgb/yn0u+xM6dTYTy8jn5hDP4xle/y5RJM2hpbUbrvi0Zxp6xN27dTMrpO966MfW0RXYBRiY+rd9ru9eqr59Dd3c3PtvPUbOPYcvWzTgpp//1qifS3sZHL7ySirJqPnbV+Wxu3PjBJHX9i+QEQuQeSQrEkCjd13xwWBdX89vbfkk83kt+KMyEhkmUl1VzyomLePTxBzKDJs2cOhelFI7joBRYlofWXS1s3daY2ZbWmvaOdpTS7GjaznFHL+TPf/0d9XUTaNy2mS2Nm9BKE2lvY3PjJlxX4boK5fYlJ/HeXtZvWMPvbryHXbtacZzUe9tWilgsRlNzE5MmTKWldScr1yzHwKCjs52Nm97hpVdf4Bc//D3BYB7VVWN48pml3HPvX/jn/XfR3h4h4A/y1DOPsbNlJ11dXUS7uzPbP/PUc3lo6b2ZjpAL55+G66b641O4rkt68CilYMGxJ/G9n1zPK68t48FH7+WUhYt48ulHcZwUm7ds5NwzF7P0yYe49OJP8NVrv8XyFW9gWR52tjSzvWn7YX8fpVIgRO6xlixZsiTbQYjcEo/HicfjbHirmYlTx2EaBn2DFhyeRWuN12uzfMXrvPn2a5x9xgVMaJjE8cecyMo1y9m4+R0+csGV2F6bnlgPluVhbG0DVZW1NG7bzMxpR+Gz/aBhxeq32Lh5A8lEkoXHn8rY2gYa6ieyYtWbnH7yOQT8QebNmU+kvY3a6jrAIOALkEq5FIaLqSyvZuPmd9jRtJVFp51HeVlVJs6Z0+by9PNP0N0d5V8uvZrSknJ6E72gDWbPOJqaqjHsamth85aNLDj2JCaNn8bC+afy8msvMGHcFI6adSynLDyTJ599FMu0GFc/iYnjp/bd4qhh5vSj2NnSzNr1Kznz1A9RXFRKLB7D7/OTdByKwiVUltcQ8AdBw6zpRxOPx9i05V0uPv9yaqvrqKqsZdlLz9BQN4H5x55EMpngtTdfwuuxOeeMC6irHcemxneZM3MeXo/3sL6PvbEkWxsbmTS7Bp/PRyAQkLkPhBjhZJZEMWjpj0okEqGtrY2HbnuLcy86HctjZTmy/bvzb7dhGAaXXfzJbIcy6nRGoix7/gU+dOWx5OfnU1xcjGmakhQIMYLJ3QfikKXbtM0RWiZOOknygvl9PyeSMinPMFMj9HMhhNg/SQrEkOj+9uORyGPZfGjRxZnHIzXOI5XUIIXIPZIUiCFRrsYw5Ntf7EsmyhIi90hSIIZEKY0hZWIxAKnMCJF7JCkQQ6Jc2M9ou2KUkz4FQuQeSQrEkPTdJy9f/mJfMsyxELlHkgJx6HR/84G0HYsBSLIoRO6RpEAMiXI1BvLlL/YlHQ2FyD2SFIghUS7IWDRiINLRUIjcI0mBOCSGYeAqxao312CYMoUGQDTWAWjyg0XZDmVESCYdDOmFKkROkaRAHBLDMJg4v4DOSEvfzIUyUg0PP30XBgYXL74026FknWEY5Pl8FBSFZL4DIXKIJAXioHk8Hnw+H6UVYfx5Fo7jSFIAFJUU0N3dTXltONuhZJ1hGPh8Pvx+P7Zt4/F4JDEQIgdIUiAGLf2l7vV6CQaDlJWVEQqFpFLQr7S0lHg8TlVVVbZDyTrDMPB6vdi2TTAYxLZtqRgIkQMkKRAHzev1orWmqKiIYDCI67qSFAAlJSVs3bqV0tLSbIeSdYZh4PF48Hg8+P1+qRQIkSMkKRAHzePxYFkWPp8PpRRaa0kKgIqKCrTWo75SkD75p6dJlumShcgdkhSIQ7L3l/1oTgqUUiQSCQzDoLOzk6amJhKJBGVlZYTDo7N/QfpzkW4ykKRAiNxg6NH8bS7EEGmtueCCC3jqqadIJpM4joNpmni9XlavXk1DQ0O2QxRCiEGTG8yFGALDMLjuuuuIx+Mkk0m01riuy0UXXSQJgRAi50hSIMQQLViwgAsvvDDz2LIsvvzlL2cxIiGEODTSfCDEYbB27Vrmzp1Lb28vZ5xxBo899pi0owshco50NBT7kDzx4E2ePJlPf/rT/OpXv8pUCeR1PHiSSAmRXVIpEBnpWwvjsV66O+OozEdDPiKD0dzUzNWf/TT3/fN+LI+V7XByRPr2RYOCojxs2yu3MAqRRZIUiAylFEopXnpyNSuWNRIuDmU7pJwTT3QT8MnrdrBamzpYdNlsJkyvxbIsTJlkS4iskOYDAfRVCZLJJMlkkpbmFmYfP5Gpc+qzHZYYJZY9voKmHc1U1IUzwyJLYiDE8JOkQGSkb6dzUg5agVJSRBLDQ2tN0kniui5KqWyHI8SoJUmByFBK4bouiUSir3+Bgv33J9i7zff91tODfHww29h734PZ1t7rHWw8h/O4DybOA+07V457//vQChKJBI7jZIbOFkIMP0kKREa6o6HWDKJSMNgv7b3Xe7/Hh7KNg9nW3usdbDxy3Ae33oH2udtvdN+vJRkQIrskKRAD6E8OdksK9netuu8zB7derpDjPjzrvf8ONVruchEi6yQpEAPSur9SsNf39EFfL+7vbHGAqnVXtJNUKrXH6uFwIZZlDRzEYCvbe6+/e0Ub6OzsYOu2LcyYPnu/x+26Lm++/RqzZx6F1+PdZ9MHddx77aOzq4PGbVuYOW32wNs4hON+7c2XmTl9Dj7bt9/jPtA2Duv7fYAWCikQCDEySPdeMSCt+voUaD3ERe1n2fv3+r1EpKuri0Xnn8Cyl55j+Yo3ufPuO1i/Ye2+z93fPgYb024/K1fz+P8+yu/+8JsDbqN1VyvXffNaYj2xoR/3busrpXniqaXcdsfNgz+u/fw+Ho/T0dGB1rB6zUpisdh+j/ugX7uhvN8H3IdkBUKMBFIpEAPSuu9EmQ0V5dXkBfM4/tiTKAwXccxRC0gmE6RSLvF4HKVcPB4PAX8QgO6eKMlkguKiUjSanp4eUq5DQX4YrTVtkV0UhouwvTbx3hhKaQKBAKlUCtdNZbYzddIMXnjxGTo7OzFNk7xg33gDnV0dpFIpiotLKCupoLi4FKU0ytVEOtowDIOicHEmFq/XSzwepzBcBICTcujoiFBcVIplWbjKpa2tlcLCYmyvDUCkvY262gae18/s8bqn3BSOk6S3t5eiwmKSTpKOjgglxWUYpkk8HsNn2yitSaUcAv4gv771Bk5ccBpzZh7NhR++FJ/Pj+sqenp6ME0DpRShvHwAYvEeYvEYJUWlWR0wSOsjp+lFiFwmSYEY0N59CoZ931qzZt1KgoE8Vq5ezmUf+Tg/u/H7bGncyOSJ03jq2aX89Q8P89KrzxONRnn1jWWMHdOA1vDE048QLgjzuau+xN3//BOXXnwlX/raZznr9PPIywtx34N3c+tNd7Fy9XJWrl7OlZdf3VfN17C5cSM33PQDnnnhSW744S3sbGlmzbqVxOMxxtaN4+LzL4P+q9u//v1PuG6KVWve5qwzzkMrzY9/+R0uPv9y7n3obn7+g1vw+/zc++DdVFfV8ugTD/DT7/6GO++5nTG19dz2p9/w65/fwX0P3k1lRQ1vLH8FdnvdE8kE13/n37Esi+aWJq7/+vd44JF/MHPaHP76jz/y/f/+Bb+97ReMHdPAKScu4uprLuX3v76HF19+joJQmHBBIV/896v4/a/u5smnH2Xpkw9y4vGn8sAjf+dPv7uPxq2bePq5JxjfMJE/3nUrX/3S9cyZcXRW3nPpTiDEyCDNB2JA6bsPsrP0nSO8HhuPxwsYoA2mT5lFw9gJfO6qL2GYFj09Pfzl7tvxer1MnTyLXW2tzJg2m6qKam74we/Izw+zZetmpkycwZjasUyZNJ0Lzr0E13WJtEdYv2ENi8/7KLp/v1ppxtTU8x9f+R+u+cxXuPsff6KyvJoTF5yG3x9g/YY1/Xdk9FUJJoybzJxZx2DbPt55dz3Tp84mP1TAlZddzYnHn8aGd9bxxztv5fhjTuScMy7gU1d8nmUvP0dL604Mw2TKpOmsWv02Tz33BKeddBbnnXURmvded6/HZnz/Pm795V3c/qffMn/eiZy04HTG1IzlkaX3UV1ZSzKZpLS4DMvjoSA/zJiaeo45+gTqx4ynvKwSrTQzps2hvKySq678AvV142lq3sGTTy+lpmoMJy88k2i0ixlT5mTtPZfmAyFGBqkUiAFp3Xdyzta+DQzq6yYQLiiioW4iHR0doMEwTJQC0zBRrqZ55w6OmbuAQCCPzq52NjduxGN5UQoqy2soKSrlyWeWUlhQzLQpswGTj330Km69/UZqa8YSDORnjlMpjWEYfc+tqIG3X2fbjq00NW9n2pTZLHvp6b6ERYNWmnfeXYffH2TyhGn0xLrR6bgUmKaJchXtHe3satsFmIyrn8hTzz5GQX4hJy04g4XzT+XNt18lFuvpj8HY93XX4LE8KAWtu3YSi8UyxxaLx7BtX3+fhL51+9rsdX+iAwZG5nd7x3bOmYu5+fc/x7K8XHbxJwEzi+95dvYrhNiTJAViQOkTXzakUikSiV7a2naBNti6fQtbtm7EwMBxkmilcZy+IZmPPfoErr3uas458wJM06KmqpZYPIZWmt7eXqLdXfT09DBv7nxisRg+r5/TTjyHX9/6M350wRV7HKNhmHR0tNPbG+fl117gwg9fzp/v/h2zph/FmrUr2bZjK21trSSTCRwnxcOP3cdHL7yS9e+sJZHspb2jnWQygVIax3FIJpOcdtJZ/OSX3yHaHWVXWwuLTjuPK67+MLbto7c3znlnX0xbZBfPPP84PbEedrY0090dzfRncBynr6Og0nz47Ev4xwN3Mm/u8Wzb0cinrvg8b698g+dfeorX3niR9o42tm7bgs/28/bKNygtqSCRTJBMJkkk+l4v3R9bIpFk244NFBeVAtBQP5GUk3rvDo9hJkmBECODtWTJkiXZDkKMDI7jkEql2LCqkZC/hMKSgqH3Rj+EZeOmDUyfOofOrg6amrfT0dnO/KMXEo/HKSupwOOxqa0ei8/2s+i087AsD0ppzjlzMa27WqiuGkNJURmuUjTvbMLAoHnnDp5b9r8sOO4UDMMkmUxy8glnAu/tt6igmLLSCpavfJMTjjuF8Q2TmTF1Ntt3bOWUhYsoKS6jvLSSqspafLafUxYuYtuORhadeh4lRWUEAkHqx4zH7/Pj9wXID4U5bt5C6uvGs7OliQvOuYSiwhIWzj+VLVs3ccoJi6itGctpJ57NG8tfoa62gZnT5lJfOw7DMHEch95EgoJQIVUVtYxvmERBfiFvr3qDM0/+ENWVY6irbaAtsouqilrmzDiGcfWTmDV9Lj2xHqoqaiktKcfvC+AqRU3VGGzbT3FRGUF/kJTTd9tnNNrFundW09ERYXzD5Ky8581bWzGDCWrqyvH7/Xi9Xpn7QIgskFkSBdBXcu7p6SEej/Pw3c9TWTSBcZNrsx3WkPzt/j+zufFdzjljMd09UWKxblzXZe2GVRw9Zz7HH3NitkPMGg3861c/zuJzL6W2Zixbtm5kysTp1NeNz0o8b720Fm9pF8csnEE4HCYQCGStaiHEaCbNB2JAmXbqHHbBOZfy8mvPs3L1W0ydNJN5cxaw7p1VhPIKOPaoE3L++Ibq2//xM154+SnWbVjN8cecTFlphfQpEGKUk6RADEj334efywws5s87OfNYK5g0bjqQTnhy+/iGKpxfzLlnXJx5nM33WwqWQowMkhSIAaVH+RNiOOhRXrURYqSQpEAMSB0BlQKRO6RSIMTIIEmBGFBfpSDbUYjRQnICIUYGSQrEgPoG0ZFvajE8pPlAiJFBkgIxICV9CsQwkuYDIUYGSQrEAAxam3bhJFPZDiSnaK1IuQ5ejy/boeScjrZO8sd4sx2GEKOeJAViH8U1PlpVhJb4jv679uQqbjC27Wjklj/+kv++7kfZDiWHGGBAqDZIqDiY7WCEGPUkKRAZpmni8XgorSgkr8BHT0+PlHUPQlQ1EczzM2ZKUbZDySmGYRAKhQiFQti2jWVZGIaR7bCEGJUkKRAZlmXh9XopLCwkEAgQCAQkKTgIXq+X/Px8SktLsx1Kzkif/IPBIIFAANu2MU1TkgIhskSSAgH0fTl7PB4Mw6C0tLR/psKEJAUHwbZtioqKqKqqynYoOcUwDHw+H16vF7/fj8cjX0tCZIv89YmM9BVaOBzuvyVRSVJwECzLori4mIqKimyHklMMw8A0TUzTzDQdSKVAiOyQpEBkpL+IPR4PWutMQiCJweDE43HC4TBer/SiH6z0Zy6dCEhCIER2SVIg9iBfygcnFotx0003EQgEeP7554nH4zz99NPk5+cze/ZsAoFAtkMUQohBM7RcBgoxJGeffTZLly7d4/+mT5/O66+/js8nYxYIIXKHme0AhMh111577R6PDcPg+9//viQEQoicI5UCIYYolUoxd+5cVq5cCcBZZ53FI488Is0wQoicI5UCIYbI4/FwzTXXAH23Jf7gBz+QhEAIkZOkUiDEILzfn0k0GmXChAksXryYm2+++YDrSsIghBipJCkQo97ufwK7j8+QXpRSfYvW9KZcupIpYo5LUmkSriLhKpSG226/nbPPPpvqqkq8poHPMrFNA79lkm97yPNaWKaJ1T8eRHpcCMMwsCwrE8Put+kJIcRwkqRAjDq7j7+w5wLRpMO27gSNXTGaenppjSfZFU+S0qANE69lErK9BLyevpN+/2IZBhgG0LedpKsyS8J16U46xJIp0BoDTdhrURa0KQ/6GJMfoK4gQJnfi9U/iA+wx3C/kiAIIYaDJAViVElf9Wut6YonWBOJsi7Sw7udMTocRdDvoyoUoCo/SHmen+KATaHfh8c8fCdlDXQnHdrjSXbFemnujrMjGqetJ46lXepDfiYUBpleWkBtQTAz0h/IOBJCiA+WJAXiiLV7FcB1XZRSrI9083prlFWRbpLaYFxxAQ1FIeoLQxT47WyHTMpVbOuKsbkjyjttUdpjcRoK/MwpzWduaT4hnxfLsjLDAkuCIIQ4nCQpEEesdEXg3fZuHt/cwspID1XhfGZXFjOxpACfx3r/jWSZBpq6YqxoaWf1zghhD5wyppQF1cUEbK9UDoQQh5UkBeKIopTCdV0SToonN+/kye0d5OcFmT+mgkklBZg5fgKNxBO8sq2VFU27mFpgc8H4Cqryg/h8PkkQhBBDJkmBOCIopQCI9SZ4vLGNpY1tTK8sYWF9JUHvkTfFhwbWtnbw1MbtVNomH5tSTVUokGlaAOmcKIQ4eJIUiJyX7jPw5s4Obl+1jSlVZZxUX4XXGh1jc21q7+LhtVuYXRTgssnVhAJ+qRoIIQ6JJAUiZ6XHEOjpTXDH6u00JhQXTh9Hvm/0TV2sNby6rYXXt+zgC7PGML4wD9u2JTkQQhwUSQpEznJdl2jC4bsvb2BCZTnz6yqyHVLW7Yr1cs/yDfzLxHKOqSrC4/FkmhOEEOL9SFIgck76NsOO7h6+/epG5o+vY0pZUbbDGjHiToo/v7mOi2oLWDi2Asuy9hgxUQgh9keSApFT0k0GqVSKn72+kcqyMmZVlWY7rPe1Y8smqurqh62UH3dS3PHaar4+pzZzdwJI50MhxIFJXVHkHKUUK1o7iWgP06tKcWHYlrUrlrN4ziT+ftstPHT3X7jh+q+zccO6Az5n4/q1/NvF55FSatjitL0ezprawB1rm0ilUu87oZMQQgAcefdqiSNaKpUiHo9z7/odnDR1MmqYz3Xjps3E47U5+fyLCBeXcPJ5i+mNx1G6r4phQP8cCO+pbphAflFRX6zDGG9NOJ+nUgbvNrUwpa4Gj8cjzQhCiAOSpEDkFNd1cRyHnY6mJBRADfP++6dSor1tF8lkkreWPcepF1zM7T/5Hju2bKKwpJTN69by3T/9jW3vbuC5h+8nv7CISEvLsMcK0FBayNqOCBNr3D3mUBBCiIFIUiByQrr8na4UaNMz7FUCAKVBKc27q1dhBwK0NjeBaTFm4hQcx+FT113PteefQXdXF7/9zvV8+cc3UlBUxAN3/A53mCsFAHm2za62OMlkEtM08Xg80q9ACLFfkhSInJKuFCgnmZUrbwUYpsmshScTLi5h1vEnEo/HwTCwvDYKsDwenFSKzevXYnltNAamZfU9d5jj7UokKXQdXNeVfgVCiPclHQ1FTknffRBOxWmJxvqu3IdzURo3lSKVclEaol2dvPjYI5lZGJUG11VoDBqmzmDpXX8k2tlJtLODzvbIsIXzCE4AAAX6SURBVMe7aVc7VaZ0NBRCDI61ZMmSJdkOQojBchyHZDIJ8R5e7EoxqaKEdFV+OJaNa1YRLi2jZcdWNq1dzburVjD35NPpjLThC+YRyC/A8nrIKyzi9I9czvJlz9K2s5nxM+ZQM34igfyCYYt1W0eUnY2bOCrfory8HK/XK80HQogDknEKRM7QWtPT00NnZyctLS38eVs39ROnMqVy5I9TMNx6nRR/e3U5F/q6qS4IMmnSJPx+f2boYyGEGIj0KRA5wzAMPB4PPp+PUCjE6f427lmzFq9nOg2lMqJhWsJJ8cDyNcyJN1NRXEJeXl5muGNJCIQQByJJgcgpXq+XQCCAUory4iIu8/Zw9/K36Zw8hRk1FcPekW+k6Yj18tiKNcxLtDCtOEhJSQmhUAjbtuV2RCHE+5KkQOSU3asFgUCAQtfl3M5mXlz7Ng+31XHi5AbyfHa2wxx2WmvWNLWyct16FuoIY4JegsEggUAAv98vVQIhxKBInwKRc5RSKKXo6uqip6eH7du309XVxfpuh5cpYHz9OGaMqcQ7Sq6Mmzq6eGXDJko7mzjailFZWkJBQQHl5eUUFhZi2zZe7+ibTloIcfAkKRA5Jz1LYjzeNyhPW1sbnZ2dxGIxWtraWO36We8ppH5MLVOrK/DbR94JUWvNtkgnK7Zswxdp4hhPnIqAF7/fT0VFBcFgkMLCQoLBoMySKIQYNEkKRM5KpVKkUqnMHQk9PT3s2LGDeDxOLJFkfcrLJruIUEU1k6oqqCwswDJzu4Qejffyzs5dNO5oori7lWk6SoGhCIfDFBQUEAwGqa6uxufzZToYGoYhTQdCiEGRpEDkNK01ruuSTCZJpVJEIpFM1SASieCkUjQlFOuUnzZ/IUVl5dSVFlMezsf2jvwuNVprOnpibGvrYHvLLjydrYwjRoOZJOT3EQz2TYtcWVlJKBTC7/eTl5cn8xwIIQ6JJAUi5ymlSKVSKKWIRqN0d3fT29tLJBIhmUwSj8fp7e3FcV12KYutRpAWK4DOL6K0sJDSghDF+SGCPjvrdy84rktnT5xd0SgtHVF6OtoIJ7qppZdqFcdvgt/vx+v1kpeXR15eHj6fj9LS0sw4BH6/X6oDQohDIkmBOCLsPmGS4zikUik6Ozvp7e0lGo3S1dWF4zj09vZmmh26nRSt2LRiE7H8JPwF+EL5FOQFCecFCQX85PlsfLb3sHZaVFqTcFLEE0l6envpjMXp7IkT6+mGni7CyR5KdIJykhRaGo9p4vf7sSwLr9dLKBTC5/NRXFxMIBDINBWYpplZhBDiUEhSII4o6bkRlFIkk8nMsMjxeJxUKkVvb2+mg2I0Gs1MsOS6Lkpr4go6tId2LDqVSY/hodeySXl8mLYPy7bxem28Hg8e08RjmVimiWEaGBiARmtwlcJVipSrSLkuScchlUyinAQkE/jcJEHlkG+4FJKi2HTJQ+E1DSzLwjRNbNvG5/Ph9XoJh8OZWzF9Ph8ej4dgMIjH48GyrD2GL5YKgRDiUElSII5I6b4Grutmqgeu6xKPx4nH4yQSCaLRKKlUKtMfId0Msfvz0kmGqxQu4GqDpGHiYJIyDFxMXMNEY2RmRTbQWGgsrbC0xovC1i4WGo8BlmFkrugty8IwDLxeb2Zq4/TdAj6fL9MkEA6H8Xq9mdsLLcvCtu3M+ANSHRBCHA6SFIhRQam+iZbTJ/zMFMz9iUAikcgkDY7j4DgOsVhsn3XT29nb7n9G+7tST5+80yf99Ene4/EQCAQyj9NNBR6PJzM8cTpp2H0QIqkICCEON0kKxKiQ/pinr/zTlYT0v+lKQbpq4LouiURij4pD+rl7bzedLKT3kT5x7937P935L908kD7xm6aJz+fLPN49Adh92b3zoCQEQogPgiQFYtTaX6KQPsmnmw92TwZ2/3PJNC3s1tQAZJoEbLtvuOXdT+DpE7uxWxNCeujmgRIAOfkLIYaTJAVC7Gbvk/5AP+/9f3tXENIn8v3NN7B3krC/3wkhxHCTpECI/RjMn8buicHeBtP5T5IAIcRI8v8BT2atQAUXCEsAAAAASUVORK5CYII=)

###Solution
"""

class solution:
    def __init__(self):
        self.best = 0
        self.bestIndividual=[]
        self.convergence = []
        self.optimizer=""
        self.objfname=""
        self.startTime=0
        self.endTime=0
        self.executionTime=0
        self.lb=0
        self.ub=0
        self.dim=0
        self.popnum=0
        self.error =0
        self.feval=0
        self.maxiers=0

"""##EOCC + SMO"""

class benchmarks():
  import numpy
  import math

  # define the function blocks
  def F1(x):
      s=numpy.sum(x**2)
      return s
  #More objective functions can be inserted here

  #Ex: def F1(x):
  #       s=numpy.sum(sin(x))
  #       return s

  # define the function parameters
  def getFunctionDetails(a):

      # [name, lb, ub, dim, acc_err, obj_val, temp, cost]
      param = {	0: ["F1",-100,100,30,1.0e-5,0, 37.8, 0.05],
              }
              # add values into param dict depending on which objective function to use and what are the parameters associated with it
      return param.get(a, "nothing")

from __future__ import division
import time
import random
import numpy
import math

class SMOFunc():
    def __init__(self,objf1,lb1,ub1,dim1,PopSize1,acc_err1,iters1, temperature_threshold , costfunction):
        self.PopSize=PopSize1 #population size
        self.dim=dim1 #dimensions
        self.acc_err=acc_err1 #accuracy error  suitable node
        self.temperature_threshold=temperature_threshold #temperature_threshold
        self.costfunction=costfunction #costfunction
        self.lb=lb1 #lower bound
        self.ub=ub1 #ubber bound
        self.objf=objf1 #objective function
        self.pos=numpy.zeros((PopSize1,dim1)) #position array
        self.fun_val = numpy.zeros(PopSize1) #function evaluation for every monkey pos
        self.fitness = numpy.zeros(PopSize1) #fitness array of every monkey
        self.gpoint = numpy.zeros((PopSize1,2))
        self.prob=numpy.zeros(PopSize1) #probabibiility values
        self.LocalLimit=dim1*PopSize1; #LocalLeaderLimit
        self.GlobalLimit=PopSize1; #GlobalLeaderLimit
        self.fit = numpy.zeros(PopSize1)
        self.MinCost=numpy.zeros(iters1)
        self.Bestpos=numpy.zeros(dim1)
        self.group = 0
        self.func_eval=0
        self.part=1
        self.max_part=5
        self.cr=0.1


    # ====== Function: CalculateFitness() ========= #
    def CalculateFitness(self,fun1):
      if fun1 >= 0:
        result = (1/(fun1+1))
      else:
        result=(1+math.fabs(fun1))
      return result
    #================ X X X ===================== #

    # ==================================== Function: Initialization() ============================================ #
    def initialize(self):
        global GlobalMin, GlobalLeaderPosition, GlobalLimitCount, LocalMin, LocalLimitCount, LocalLeaderPosition
        S_max=int(self.PopSize/2)
        LocalMin = numpy.zeros(S_max)
        LocalLeaderPosition=numpy.zeros((S_max,self.dim))
        LocalLimitCount=numpy.zeros(S_max)
        for i in range(self.PopSize):
            for j in range(self.dim):
                if type(self.ub)==int:
                    self.pos[i,j]=random.random()*(self.ub-self.lb)+self.lb
                else:
                    self.pos[i,j]=random.random()*(self.ub[j]-self.lb[j])+self.lb[j]
        #Randomly initialize Spider Monkey positions
        #Calculate objective function for each particle
        for i in range(self.PopSize):
            # Performing the bound checking
            self.pos[i,:]=numpy.clip(self.pos[i,:], self.lb, self.ub)
            self.fun_val[i]=self.objf(self.pos[i,:])
            self.func_eval+=1
            self.fitness[i]=self.CalculateFitness(self.fun_val[i])

        # Initialize Global Leader Learning
        GlobalMin=self.fun_val[0]
        GlobalLeaderPosition=self.pos[0,:]
        GlobalLimitCount=0 #initially

        # Initialize Local Leader Learning
        for k in range(self.group):
            LocalMin[k]=self.fun_val[int(self.gpoint[k,0])]
            LocalLimitCount[k]=0 #initially
            LocalLeaderPosition[k,:]=self.pos[int(self.gpoint[k,0]),:]
    # ============================================ X X X ======================================================= #


    # =========== Function: CalculateProbabilities() ============ #
    def CalculateProbabilities(self):
        maxfit=self.fitness[0]
        i=1
        while(i<self.PopSize):
            if (self.fitness[i]>maxfit):
                maxfit=self.fitness[i]
            i+=1
        for i in range(self.PopSize):
            self.prob[i]=(0.9*(self.fitness[i]/maxfit))+0.1
    # ========================== X X X ======================== #

    # ================= Function: create_group() ================ #
    def create_group(self):
        g=0
        lo=0
        while(lo < self.PopSize):
            hi= lo+int(self.PopSize/self.part)
            self.gpoint[g,0]=lo
            self.gpoint[g,1]=hi
            if((self.PopSize-hi)<(int(self.PopSize/self.part))):
                self.gpoint[g,1]=(self.PopSize-1)
            g=g+1
            lo=hi+1
        self.group = g
    # ========================== X X X ======================== #

    # ================= Function: LocalLearning() ================ #
    def LocalLearning(self):
        global LocalMin, LocalLimitCount, LocalLeaderPosition
        S_max=int(self.PopSize/2)
        OldMin = numpy.zeros(S_max)
        for k in range(self.group):
            OldMin[k]=LocalMin[k]

        for  k in range(self.group):
            i=int(self.gpoint[k,0])
            while (i<=int(self.gpoint[k,1])):
                if (self.fun_val[i]<LocalMin[k]):
                    LocalMin[k]=self.fun_val[i]
                    LocalLeaderPosition[k,:]=self.pos[i,:]
                i=i+1

        for k in range(self.group):
            if (math.fabs(OldMin[k]-LocalMin[k])<self.acc_err):
                LocalLimitCount[k]=LocalLimitCount[k]+1
            else:
                LocalLimitCount[k]=0
    # ========================== X X X ======================== #

    # ================= Function: GlobalLearning() ================ #
    def GlobalLearning(self):
        global GlobalMin, GlobalLeaderPosition, GlobalLimitCount
        G_trial=GlobalMin
        for i in range(self.PopSize):
            if (self.fun_val[i] < GlobalMin):
                GlobalMin=self.fun_val[i]
                GlobalLeaderPosition=self.pos[i,:]

        if(math.fabs(G_trial-GlobalMin)<self.acc_err):
            GlobalLimitCount=GlobalLimitCount+1
        else:
            GlobalLimitCount=0
    # ========================== X X X ======================== #

    # ================= Function: LocalLeaderPhase() ================ #
    def LocalLeaderPhase(self,k):
        global LocalLeaderPosition
        new_position=numpy.zeros((1,self.dim))
        lo=int(self.gpoint[k,0])
        hi=int(self.gpoint[k,1])
        i=lo
        while(i <=hi):
            while True:
                PopRand=int((random.random()*(hi-lo)+lo))
                if (PopRand != i):
                    break
            for j in range(self.dim):
                if (random.random() >= self.cr):
                    new_position[0,j]=self.pos[i,j]+(LocalLeaderPosition[k,j]-self.pos[i,j])*(random.random())+(self.pos[PopRand,j]-self.pos[i,j])*(random.random()-0.5)*2
                else:
                    new_position[0,j]=self.pos[i,j]
            new_position=numpy.clip(new_position, self.lb, self.ub)

            ObjValSol=self.objf(new_position)
            self.func_eval+=1
            FitnessSol=self.CalculateFitness(ObjValSol)
            if (FitnessSol>self.fitness[i]):
                self.pos[i,:]=new_position
                self.fun_val[i]=ObjValSol
                self.fitness[i]=FitnessSol
            i+=1
    # ========================== X X X ======================== #

    # ================= Function: GlobalLeaderPhase() ================ #
    def GlobalLeaderPhase(self,k):
        global GlobalLeaderPosition
        new_position=numpy.zeros((1,self.dim))
        lo=int(self.gpoint[k,0])
        hi=int(self.gpoint[k,1])
        i=lo
        l=lo
        while(l<hi):
            if (random.random() < self.prob[i]):
                l+=1
                while True:
                    PopRand=int(random.random()*(hi-lo)+lo)
                    if (PopRand != i):
                        break
                param2change=int(random.random()*self.dim)
                new_position=self.pos[i,:]
                new_position[param2change]=self.pos[i,param2change]+(GlobalLeaderPosition[param2change]-self.pos[i,param2change])*(random.random())+(self.pos[PopRand,param2change]-self.pos[i,param2change])*(random.random()-0.5)*2
                new_position=numpy.clip(new_position, self.lb, self.ub)
                ObjValSol=self.objf(new_position)
                self.func_eval+=1
                FitnessSol=self.CalculateFitness(ObjValSol)
                if (FitnessSol>self.fitness[i]):
                    self.pos[i,:]=new_position
                    self.fun_val[i]=ObjValSol
                    self.fitness[i]=FitnessSol
            i+=1
            if (i==(hi)):
                i=lo
    # ========================== X X X ======================== #

    # ================= Function: GlobalLeaderDecision() ================ #
    def GlobalLeaderDecision(self):
        global GlobalLimitCount
        if(GlobalLimitCount> self.GlobalLimit):
            GlobalLimitCount=0
            if(self.part<self.max_part):
                self.part=self.part+1
                self.create_group()
                self.LocalLearning()
            else:
                self.part=1
                self.create_group()
                self.LocalLearning()
    # ========================== X X X ======================== #

    # ================= Function: LocalLeaderDecision() ================ #
    def LocalLeaderDecision(self):
        global GlobalLeaderPosition, LocalLimitCount, LocalLeaderPosition
        for k in range(self.group):
            if(LocalLimitCount[k]>self.LocalLimit):
                i=self.gpoint[k,0]
                while(i<=int(self.gpoint[k,1])):
                    for j in range(self.dim):
                        if (random.random()>= self.cr):
                            if type(self.ub)==int:
                                self.pos[i,j]=random.random()*(self.ub-self.lb)+self.lb
                            else:
                                self.pos[i,j]=random.random()*(self.ub[j]-self.lb[j])+self.lb[j]
                        else:
                            self.pos[i,j]=self.pos[i,j]+(GlobalLeaderPosition[j]-self.pos[i,j])*random.random()+(self.pos[i,j]-LocalLeaderPosition[k,j])*random.random()
                    self.pos[i,:]=numpy.clip(self.pos[i,:], self.lb, self.ub)
                    self.fun_val[i]=self.objf(self.pos[i,:])
                    self.func_eval+=1
                    self.fitness[i]=self.CalculateFitness(self.fun_val[i])
                    i+=1
                LocalLimitCount[k]=0
    # ========================== X X X ======================== #

    # ==================================== Main() ===================================== #
    def main(objf1,lb1,ub1,dim1,PopSize1,iters,acc_err1,obj_val,succ_rate,mean_feval, temp,cost):
        smo=SMOFunc(objf1,lb1,ub1,dim1,PopSize1,acc_err1,iters, temp, cost)
        s=solution()
        print("SMO is optimizing  \""+smo.objf.__name__+"\"")
        timerStart=time.time()
        s.startTime=time.strftime("%Y-%m-%d-%H-%M-%S")

        # =========================== Calling: initialize() =========================== #
        smo.initialize()

        # ========================== Calling: GlobalLearning() ======================== #
        smo.GlobalLearning()

        # ========================= Calling: LocalLearning() ========================== #
        smo.LocalLearning()

        # ========================== Calling: create_group() ========================== #
        smo.create_group()

        # ================================= Looping ================================== #
        for l in range(iters):
            for k in range(smo.group):
                # ==================== Calling: LocalLeaderPhase() =================== #
                smo.LocalLeaderPhase(k)

            # =================== Calling: CalculateProbabilities() ================== #
            smo.CalculateProbabilities()

            for k in range(smo.group):
                # ==================== Calling: GlobalLeaderPhase() ================== #
                smo.GlobalLeaderPhase(k)

            # ======================= Calling: GlobalLearning() ====================== #
            smo.GlobalLearning()

            # ======================= Calling: LocalLearning() ======================= #
            smo.LocalLearning()

            # ================== Calling: LocalLeaderDecision() ====================== #
            smo.LocalLeaderDecision()

            # ===================== Calling: GlobalLeaderDecision() ================== #
            smo.GlobalLeaderDecision()

            # ======================= Updating: 'cr' parameter ======================= #
            smo.cr = smo.cr + (0.4/iters)

            # ====================== Saving the best individual ====================== #
            smo.MinCost[l] = GlobalMin
            Bestpos=smo.pos[1,:]
            gBestScore=GlobalMin


            # ================ Displaying the fitness of each iteration ============== #
            if (l%1==0):
                  print(['At iteration '+ str(l+1)+ ' the best fitness is '+ str(gBestScore)]);

            # ====================== Checking: acc_error ============================ #
            if(math.fabs(GlobalMin-obj_val)<=smo.acc_err):
                succ_rate+=1
                mean_feval=mean_feval+smo.func_eval
                break
        # ========================= XXX Ending of Loop XXX ========================== #

        # =========================== XX Result saving XX =========================== #
        error1=math.fabs(GlobalMin-obj_val)
        timerEnd=time.time()
        s.endTime=time.strftime("%Y-%m-%d-%H-%M-%S")
        s.executionTime=timerEnd-timerStart
        s.convergence=smo.MinCost
        s.optimizer="SMOFunc"
        s.error = error1
        s.feval=smo.func_eval
        s.objfname=smo.objf.__name__

        return s, succ_rate,mean_feval

        # ================================ X X X =================================== #

def training_qlearn():
  #define training parameters
  epsilon = 0.9 #the percentage of time when we should take the best action (instead of a random action)
  discount_factor = 0.9 #discount factor for future rewards = gamma
  learning_rate = 0.9 #the rate at which the agent should learn =alpha

  #run through 1000 training episodes
  for episode in range(1000): #epoch
    #get the starting location for this episode
    row_index, column_index = get_starting_location()
    #continue taking actions (i.e., moving) until we reach a terminal state
    #(i.e., until we reach the item packaging area or crash into an item storage location)
    while not is_terminal_state(row_index, column_index):
      #choose which action to take (i.e., where to move next)
      action_index = get_next_action(row_index, column_index, epsilon)
      #perform the chosen action, and transition to the next state (i.e., move to the next location)
      old_row_index, old_column_index = row_index, column_index #store the old row and column indexes
      row_index, column_index = get_next_location(row_index, column_index, action_index)
      #receive the reward for moving to the new state, and calculate the temporal difference
      reward = rewards[row_index, column_index]
      old_q_value = q_values[old_row_index, old_column_index, action_index]
      temporal_difference = reward + (discount_factor * np.max(q_values[row_index, column_index])) - old_q_value
      #update the Q-value for the previous state and action pair
      new_q_value = old_q_value + (learning_rate * temporal_difference)
      q_values[old_row_index, old_column_index, action_index] = new_q_value
  #print('Training complete!')

"""#**Test and Evaluate Q-Learning**"""

def test_agent(Q, env=11, n_tests=100, n_actions=8, delay=0.1):
    for test in range(n_tests):
        s = env.reset()
        done = False
        epsilon = 0
        total_reward = 0
        while True:
            time.sleep(delay)
            env.render()
            a = get_next_action(Q, epsilon, n_actions, s, train=True)
            print(f"Chose action {a} for state {s}")
            s, reward, done, info = env.step(a)
            total_reward += reward
            if done:
                print(f"Episode reward: {total_reward}")
                time.sleep(1)
                break

"""#Acknowledgement  """

def receivePacket(sensors ,model, receiver, packetType):
    if (packetType == 'Hello'):
        PacketSize = model.HelloPacketLen
    else:
        PacketSize = model.DataPacketLen

    #Energy dissipated from sensors for Receive a packet
    if (receiver.type == 'N'):
        receiver.E -= (model.ERX * PacketSize)
    else:
        receiver.E -= (model.w2 * model.ERX * PacketSize)

"""#SAR"""

import math
import cmath
def SAR(R, t):
    fi = 1.79
    miu = 4*math.pi*10**7
    ro = 1040
    omega = 2.4*10**-9
    eps=52.73
    I=0.1
    R=R/100
    alpha = omega*math.sqrt((miu*eps)/2)*(math.sqrt(1 + (fi/(miu*eps))**2 - 1))**(1/2)
    beta = omega*math.sqrt((miu*eps)/2)*(math.sqrt(1 + (fi/(miu*eps)**2 +1 )))**(1/2)
    gamma = alpha + cmath.sqrt(-1) * beta
    SAR = (fi * miu* omega)/(ro*math.sqrt(fi**2 + eps**2 * omega**2)) * ((I*1*1*math.exp(-alpha*R))/(4 *math.pi) * (1/R**2 + abs(gamma)/R))**2

    C = 3600
    delta =  SAR * t/C
    return delta

import numpy as np
from time import sleep
from datetime import datetime
import time


#settings
count_num=16000
patient_num = 100
sensor_num = 5

"""#**Q Learning + EOCC TARA**"""

import numpy as np
from time import sleep
from datetime import datetime
import time
from random import randrange
import random
import multiprocessing

sensors = [Sensors() for _ in range(6)]
import numpy as np
from time import sleep
from datetime import datetime
import time

training_qlearn()
#settings
count_num=16000
patient_num = 100
sensor_num = 5
temperature=37.8
costfunction=0.05
temp_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
energy_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
packet_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
throughput_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
time_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
elapsed_cache = np.zeros((patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
patients_priority_cache = np.zeros((patient_num),  dtype=object) #Count - Patient - Sensor
sensors_priority_cache = np.zeros((sensor_num),  dtype=object) #Count - Patient - Sensor
sensors_dead_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
power_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor

elapsed_ecg=1
elapsed_o2=2
elapsed_eeg=1
elapsed_blood=1
elapsed_temp=1

import csv #for working with csv files
import numpy #math matrix operations
import time #algo running time
import math #normal math operations


def selector(algo,func_details,popSize,Iter,succ_rate,mean_feval, temperature, costfunction):
    function_name=func_details[0]
    lb=func_details[1]
    ub=func_details[2]
    dim=func_details[3]
    acc_err=func_details[4]
    obj_val=func_details[5]
    temperature=37.8
    costfunction=0.05
    #selection of different parameters

    if(algo==0):
        x,succ_rate,mean_feval=SMOFunc.main(getattr(benchmarks, function_name),lb,ub,dim,popSize,Iter,acc_err,obj_val,succ_rate,mean_feval, temperature, costfunction) #getting attributes from different file

    return x,succ_rate,mean_feval


# Select optimizers
SMO= True # Code by Himanshu Mittal


# Select benchmark function, for more benchmarks functions, F1=True, F2=True and so on
F1=True

optimizer=[SMO] #list of optimizers, for comparison purposes
benchmarkfunc=[F1] #list of functions

# Select number of repetitions for each experiment.
# To obtain meaningful statistical results, usually ~30 independent runs are executed for each algorithm.
NumOfRuns=2

# Select general parameters for all optimizers (population size, number of iterations)
# popsize ~50, iterations ~100
PopulationSize = 10
Iterations= 16000

#Export results ? For testing purposes, export can be turned to false, csv file will not be generated
Export=True

#Automaticly generated name by date and time
ExportToFile="experiment"+time.strftime("%Y-%m-%d-%H-%M-%S")+".csv"

# Check if it works at least once
Flag=False

# CSV Header for convergence
CnvgHeader=[]

for l in range(0,Iterations):
	CnvgHeader.append("Iter"+str(l+1))

mean_error=0
total_feval=0 #feval=function eval
mean1=0
var=0 #variance
sd=0 #std deviations
mean_feval=0
succ_rate=0
GlobalMins=numpy.zeros(NumOfRuns)


for i in range (0, len(optimizer)):
    for j in range (0, len(benchmarkfunc)):
        if((optimizer[i]==True) and (benchmarkfunc[j]==True)): # start experiment if an optimizer and an objective function is selected
            for k in range (0,NumOfRuns):

                func_details=benchmarks.getFunctionDetails(j)
                print("Run: {}".format(k+1)) #to seperate runs
                x,succ_rate,mean_feval=selector(i,func_details,PopulationSize,Iterations,succ_rate,mean_feval, temperature, costfunction)
                mean_error=mean_error+x.error;
                mean1=mean1+x.convergence[-1]
                total_feval=total_feval+x.feval
                GlobalMins[k]=x.convergence[-1]

                if(Export==True):
                    with open(ExportToFile, 'a') as out:
                        writer = csv.writer(out,delimiter=',')
                        if (Flag==False): # just one time to write the header of the CSV file
                            header= numpy.concatenate([["Optimizer","objfname","startTime","EndTime","ExecutionTime"],CnvgHeader])
                            writer.writerow(header) #write into csv
                        a=numpy.concatenate([[x.optimizer,x.objfname,x.startTime,x.endTime,x.executionTime],x.convergence])
                        writer.writerow(a)
                    out.close()

                Flag=True # at least one experiment
            mean1=mean1/NumOfRuns
            mean_error=mean_error/NumOfRuns
            if(succ_rate>0):
                mean_feval=mean_feval/succ_rate
            total_feval=total_feval/NumOfRuns
            for k in range (NumOfRuns):
                var=var + math.pow((GlobalMins[k]-mean1),2)
            var=var/NumOfRuns
            sd=math.sqrt(var)
            # print("values after executing are: \n Mean Error \t Mean Function eval \t Total Function eval \t Variance \t STD \n",(mean_error,mean_feval,total_feval,var,sd))
            print("Values after executing SMO: \n Mean Error:{} \n Mean Function eval:{} \n Total Function eval:{} \n Variance:{} \n STD:{}".format(mean_error,mean_feval,total_feval,var,sd))
print(sd, var, succ_rate, mean_feval, x)
if (Flag==False): # Faild to run at least one experiment
    print("No Optimizer or Cost function is selected. Check lists of available optimizers and cost functions")

time_now = datetime.now()
elapsed = 0
for count in range(count_num):        #Count
  print('iteration: ', count+1)
  for patient in range(patient_num):  #Patient
    if patient%2==0:
      section='CCU - Critical - ECG + O2'
    elif patient%3==0:
      section='ICU - Critical - EEG + Blood Pressure'
    elif patient%5==0:
      section='General - Critical - Temperature'
    else:
      section='Normal Internal'

    print('Patient: ', patient, '- Section: ', section)
    for sensor in range(sensor_num):  #Sensor

      sensors[sensor].Configuration(sensor)
      if sensor==0:
        if count==0:
          status='ECG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          #energy Consumption
          #Ekd    = Erx_elec*kd**2 + Etx_kd
          #Etx_kd = Etx_elec*k + Eamp *k *d**2
          #Ekd    = Erx_elec*k* d**2 +  Etx_elec*k + Eamp *k *d**2

          #Erx_elec = 36.1*0.000000001
          #Etx_elec = 16.7*0.000000001
          #Eamp = 1.97*0.000000001
          #k=8
          #d=0.04
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + float(sensors[sensor].E) - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('ECG shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] <= 0  or temp_cache[count, patient, sensor] > 38):
            status='ECG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='ECG Reset'
              print('ECG shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='ECG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] = sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('ECG shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='ECG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =    elapsed_ecg*(sensors[sensor].sleep*10**6) -count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              elapsed_ecg=elapsed_ecg+1
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='ECG Reset'
              print('ECG shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          sensors_dead_cache[sensor] +=1
          print('ECG sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: ECG  - Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor], status)


      elif sensor==1:
        if count==0:
          status='O2 Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('O2 shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] <= 0  or temp_cache[count, patient, sensor] >= 38):
            status='O2 Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='O2 Reset'
              print('O2 shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='O2 Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('O2 shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='O2 Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =    elapsed_o2*( sensors[sensor].sleep*10**6) -count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_o2=elapsed_o2+1
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='O2 Reset'
              print('O2 shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          sensors_dead_cache[sensor] +=1
          print('O2 sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: O2   - Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor], status)

      elif sensor==2:
        if count==0:
          status='EEG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] = sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('EEG shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] <= 0  or temp_cache[count, patient, sensor] >= 38):
            status='EEG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='EEG Reset'
              print('EEG shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='EEG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('EEG shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='EEG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =    elapsed_eeg*(sensors[sensor].sleep*10**6) - count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              elapsed_eeg=elapsed_eeg+1
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='EEG Reset'
              print('EEG shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          sensors_dead_cache[sensor] +=1
          print('EEG sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: EEG  - Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor] , status)


      elif sensor==3:
        if count==0:
          status='Blood Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('Blood shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] <= 0  or temp_cache[count, patient, sensor] >= 38):
            status='Blood Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='Blood Reset'
              print('Blood shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='Blood Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('Blood shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='Blood Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =   elapsed_blood*(sensors[sensor].sleep*10**6) - count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              elapsed_blood=elapsed_blood+1
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='Blood Reset'
              print('Blood shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          sensors_dead_cache[sensor] +=1
          print('Blood sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: Blood- Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor],  status)

      elif sensor==4:
        if count==0:
          status='Temp Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('Temp shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='Temp Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='Temp Reset'
              print('Temp shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='Temp Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
            print('Temp shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='Temp Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =   elapsed_temp*(sensors[sensor].sleep*10**6)-count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_temp=elapsed_temp+1
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path_SMO(int(sensors[sensor].x), int(sensors[sensor].y), patient, sensor,succ_rate)
              status='Temp Reset'
              print('Temp shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          sensors_dead_cache[sensor] +=1
          print('Temperature sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: Temp - Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor],  status)

"""#**EOCC TARA**"""

import numpy as np
from time import sleep
from datetime import datetime
import time
from random import randrange
import random
import multiprocessing
sensors = [Sensors() for _ in range(6)]

import numpy as np
from time import sleep
from datetime import datetime
import time


#settings
count_num=16000
patient_num = 100
sensor_num = 5

import csv #for working with csv files
import numpy #math matrix operations
import time #algo running time
import math #normal math operations


def selector(algo,func_details,popSize,Iter,succ_rate,mean_feval, temperature, costfunction):
    function_name=func_details[0]
    lb=func_details[1]
    ub=func_details[2]
    dim=func_details[3]
    acc_err=func_details[4]
    obj_val=func_details[5]
    temperature=37.8
    costfunction=0.05
    #selection of different parameters

    if(algo==0):
        x,succ_rate,mean_feval=SMOFunc.main(getattr(benchmarks, function_name),lb,ub,dim,popSize,Iter,acc_err,obj_val,succ_rate,mean_feval, temperature, costfunction) #getting attributes from different file
    return x,succ_rate,mean_feval


# Select optimizers
SMO= True # Code by Himanshu Mittal


# Select benchmark function, for more benchmarks functions, F1=True, F2=True and so on
F1=True

optimizer=[SMO] #list of optimizers, for comparison purposes
benchmarkfunc=[F1] #list of functions

# Select number of repetitions for each experiment.
# To obtain meaningful statistical results, usually ~30 independent runs are executed for each algorithm.
NumOfRuns=2

# Select general parameters for all optimizers (population size, number of iterations)
# popsize ~50, iterations ~100
PopulationSize = 10
Iterations= 16000

#Export results ? For testing purposes, export can be turned to false, csv file will not be generated
Export=True

#Automaticly generated name by date and time
ExportToFile="experiment"+time.strftime("%Y-%m-%d-%H-%M-%S")+".csv"

# Check if it works at least once
Flag=False

# CSV Header for convergence
CnvgHeader=[]

for l in range(0,Iterations):
	CnvgHeader.append("Iter"+str(l+1))

mean_error=0
total_feval=0 #feval=function eval
mean1=0
var=0 #variance
sd=0 #std deviations
mean_feval=0
succ_rate=0
GlobalMins=numpy.zeros(NumOfRuns)


for i in range (0, len(optimizer)):
    for j in range (0, len(benchmarkfunc)):
        if((optimizer[i]==True) and (benchmarkfunc[j]==True)): # start experiment if an optimizer and an objective function is selected
            for k in range (0,NumOfRuns):

                func_details=benchmarks.getFunctionDetails(j)
                print("Run: {}".format(k+1)) #to seperate runs
                x,succ_rate,mean_feval=selector(i,func_details,PopulationSize,Iterations,succ_rate,mean_feval, temperature, costfunction)
                mean_error=mean_error+x.error;
                mean1=mean1+x.convergence[-1]
                total_feval=total_feval+x.feval
                GlobalMins[k]=x.convergence[-1]

                if(Export==True):
                    with open(ExportToFile, 'a') as out:
                        writer = csv.writer(out,delimiter=',')
                        if (Flag==False): # just one time to write the header of the CSV file
                            header= numpy.concatenate([["Optimizer","objfname","startTime","EndTime","ExecutionTime"],CnvgHeader])
                            writer.writerow(header) #write into csv
                        a=numpy.concatenate([[x.optimizer,x.objfname,x.startTime,x.endTime,x.executionTime],x.convergence])
                        writer.writerow(a)
                    out.close()
                    print("Results of {} run are saved in 'csv' file.".format(k+1))
                Flag=True # at least one experiment
            mean1=mean1/NumOfRuns
            mean_error=mean_error/NumOfRuns
            if(succ_rate>0):
                mean_feval=mean_feval/succ_rate
            total_feval=total_feval/NumOfRuns
            for k in range (NumOfRuns):
                var=var + math.pow((GlobalMins[k]-mean1),2)
            var=var/NumOfRuns
            sd=math.sqrt(var)
            # print("values after executing are: \n Mean Error \t Mean Function eval \t Total Function eval \t Variance \t STD \n",(mean_error,mean_feval,total_feval,var,sd))
            print("Values after executing SMO: \n Mean Error:{} \n Mean Function eval:{} \n Total Function eval:{} \n Variance:{} \n STD:{}".format(mean_error,mean_feval,total_feval,var,sd))

if (Flag==False): # Faild to run at least one experiment
    print("No Optimizer or Cost function is selected. Check lists of available optimizers and cost functions")
temp_cache_2 = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
energy_cache_2 = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
packet_cache_2 = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
throughput_cache_2 = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
time_cache_2 = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
elapsed_cache_2 = np.zeros((patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
patients_priority_cache_2 = np.zeros((patient_num),  dtype=object) #Count - Patient - Sensor
sensors_priority_cache_2 = np.zeros((sensor_num),  dtype=object) #Count - Patient - Sensor
sensors_dead_cache_2 = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
power_cache_2 = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor

elapsed_ecg=1
elapsed_o2=2
elapsed_eeg=1
elapsed_blood=1
elapsed_temp=1

time_now = datetime.now()
elapsed = 0
for count in range(count_num):        #Count
  print('iteration: ', count+1)
  for patient in range(patient_num):  #Patient
    if patient%2==0:
      section='CCU - Critical - ECG + O2'
    elif patient%3==0:
      section='ICU - Critical - EEG + Blood Pressure'
    elif patient%5==0:
      section='General - Critical - Temperature'
    else:
      section='Normal Internal'

    print('Patient: ', patient, '- Section: ', section)
    for sensor in range(sensor_num):  #Sensor

      sensors[sensor].Configuration(sensor)
      if sensor==0:
        if count==0:
          status='ECG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          #energy Consumption
          #Ekd    = Erx_elec*kd**2 + Etx_kd
          #Etx_kd = Etx_elec*k + Eamp *k *d**2
          #Ekd    = Erx_elec*k* d**2 +  Etx_elec*k + Eamp *k *d**2

          #Erx_elec = 36.1*0.000000001
          #Etx_elec = 16.7*0.000000001
          #Eamp = 1.97*0.000000001
          #k=8
          #d=0.04
          #Energy Residual
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count, patient, sensor] + float(sensors[sensor].E) - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] =sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] <= 0  or temp_cache_2[count, patient, sensor] > 38):
            status='ECG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] = time_cache_2[count, patient, sensor] -  time_cache_2[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_cache_2[ patient, sensor]=0
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='ECG Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
        elif count>0:
          status='ECG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] = sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] < 0  or temp_cache_2[count, patient, sensor] > 38):
            status='ECG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] =    elapsed_ecg*(sensors[sensor].sleep*10**6) -count
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_cache_2[ patient, sensor]=0
              elapsed_ecg=elapsed_ecg+1
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='ECG Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
        if energy_cache_2[count, patient, sensor] == 0:
          sensors_dead_cache_2[sensor] +=1
          print('ECG sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: ECG  - Temperature(iter:',count+1 ,'): ',  round(temp_cache_2[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache_2[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache_2[count, patient, sensor], status)


      elif sensor==1:
        if count==0:
          status='O2 Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] =sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] <= 0  or temp_cache_2[count, patient, sensor] >= 38):
            status='O2 Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] = time_cache_2[count, patient, sensor] -  time_cache_2[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_cache_2[ patient, sensor]=0
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='O2 Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
        elif count>0:
          status='O2 Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] =sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] < 0  or temp_cache_2[count, patient, sensor] > 38):
            status='O2 Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] =    elapsed_o2*( sensors[sensor].sleep*10**6) -count
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_o2=elapsed_o2+1
              elapsed_cache_2[ patient, sensor]=0
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='O2 Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
        if energy_cache_2[count, patient, sensor] == 0:
          sensors_dead_cache_2[sensor] +=1
          print('O2 sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: O2   - Temperature(iter:',count+1 ,'): ',  round(temp_cache_2[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache_2[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache_2[count, patient, sensor], status)

      elif sensor==2:
        if count==0:
          status='EEG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] = sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] <= 0  or temp_cache_2[count, patient, sensor] >= 38):
            status='EEG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] = time_cache_2[count, patient, sensor] -  time_cache_2[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_cache_2[ patient, sensor]=0
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='EEG Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
        elif count>0:
          status='EEG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] =sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] < 0  or temp_cache_2[count, patient, sensor] > 38):
            status='EEG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] =    elapsed_eeg*(sensors[sensor].sleep*10**6) - count
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_cache_2[ patient, sensor]=0
              elapsed_eeg=elapsed_eeg+1
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='EEG Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
        if energy_cache_2[count, patient, sensor] == 0:
          sensors_dead_cache_2[sensor] +=1
          print('EEG sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: EEG  - Temperature(iter:',count+1 ,'): ',  round(temp_cache_2[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache_2[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache_2[count, patient, sensor] , status)


      elif sensor==3:
        if count==0:
          status='Blood Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] =sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] <= 0  or temp_cache_2[count, patient, sensor] >= 38):
            status='Blood Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] = time_cache_2[count, patient, sensor] -  time_cache_2[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_cache_2[ patient, sensor]=0
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='Blood Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
        elif count>0:
          status='Blood Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] =sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] < 0  or temp_cache_2[count, patient, sensor] > 38):
            status='Blood Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] =   elapsed_blood*(sensors[sensor].sleep*10**6) - count
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_cache_2[ patient, sensor]=0
              elapsed_blood=elapsed_blood+1
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='Blood Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
        if energy_cache_2[count, patient, sensor] == 0:
          sensors_dead_cache_2[sensor] +=1
          print('Blood sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: Blood- Temperature(iter:',count+1 ,'): ',  round(temp_cache_2[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache_2[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache_2[count, patient, sensor],  status)

      elif sensor==4:
        if count==0:
          status='Temp Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] =sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] < 0  or temp_cache_2[count, patient, sensor] > 38):
            status='Temp Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] = time_cache_2[count, patient, sensor] -  time_cache_2[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_cache_2[ patient, sensor]=0
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='Temp Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=packet_cache_2[count, patient, sensor]
        elif count>0:
          status='Temp Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache_2[count, patient, sensor] = temp_cache_2[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache_2[count, patient, sensor] = energy_cache_2[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache_2[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache_2[count, patient, sensor] > 0  and temp_cache_2[count, patient, sensor] <38):
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
            patients_priority_cache_2[patient] = random.randint(0, 100)
            sensors_priority_cache_2[sensor] =sensors[sensor].priority
          elif (energy_cache_2[count, patient, sensor] < 0  or temp_cache_2[count, patient, sensor] > 38):
            status='Temp Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache_2[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache_2[ patient, sensor] =   elapsed_temp*(sensors[sensor].sleep*10**6)-count
            if elapsed_cache_2[patient, sensor] > 2:
              elapsed_temp=elapsed_temp+1
              elapsed_cache_2[ patient, sensor]=0
              temp_cache_2[count, patient, sensor]=37
              time_cache_2[count, patient, sensor]=0
              status='Temp Reset'
            packet_cache_2[count, patient, sensor] = packet_cache_2[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache_2[count, patient, sensor]=throughput_cache_2[count-1, patient, sensor]+packet_cache_2[count, patient, sensor]
        if energy_cache_2[count, patient, sensor] == 0:
          sensors_dead_cache_2[sensor] +=1
          print('Temperature sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: Temp - Temperature(iter:',count+1 ,'): ',  round(temp_cache_2[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache_2[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache_2[count, patient, sensor],  status)

"""#Plot

#Energy Residual

![Screenshot from 2022-05-26 04-06-37.png](data:image/png;base64,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)
"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_energy_1 = energy_cache[0:1000, :, :].mean()/1000
sensor_energy_2 = energy_cache[0:2000, :, :].mean()/1000
sensor_energy_3 = energy_cache[0:3000, :, :].mean()/1000
sensor_energy_4 = energy_cache[0:4000, :, :].mean()/1000
sensor_energy_5 = energy_cache[0:5000, :, :].mean()/1000
sensor_energy_6 = energy_cache[0:6000, :, :].mean()/1000
sensor_energy_7 = energy_cache[0:7000, :, :].mean()/1000
sensor_energy_8 = energy_cache[0:8000, :, :].mean()/1000
sensor_energy_9 = energy_cache[0:9000, :, :].mean()/1000
sensor_energy_10 = energy_cache[0:10000, :, :].mean()/1000
sensor_energy_11 = energy_cache[0:11000, :, :].mean()/1000
sensor_energy_12 = energy_cache[0:12000, :, :].mean()/1000
sensor_energy_13 = energy_cache[0:13000, :, :].mean()/1000
sensor_energy_14 = energy_cache[0:14000, :, :].mean()/1000
sensor_energy_15 = energy_cache[0:15000, :, :].mean()/1000
sensor_energy_16 = energy_cache[0:16000, :, :].mean()/1000
x1 = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
y1 = [0,sensor_energy_1 ,sensor_energy_2,sensor_energy_3,sensor_energy_4,sensor_energy_5,sensor_energy_6,sensor_energy_7,sensor_energy_8,sensor_energy_9,sensor_energy_10,sensor_energy_11,sensor_energy_12,sensor_energy_13,sensor_energy_14,sensor_energy_15,sensor_energy_16 ]
plt.plot(x1, y1, 'r-o')
sensor_energy_1 = energy_cache_2[0:1000, :, :].mean()/1000
sensor_energy_2 = energy_cache_2[0:2000, :, :].mean()/1000
sensor_energy_3 = energy_cache_2[0:3000, :, :].mean()/1000
sensor_energy_4 = energy_cache_2[0:4000, :, :].mean()/1000
sensor_energy_5 = energy_cache_2[0:5000, :, :].mean()/1000
sensor_energy_6 = energy_cache_2[0:6000, :, :].mean()/1000
sensor_energy_7 = energy_cache_2[0:7000, :, :].mean()/1000
sensor_energy_8 = energy_cache_2[0:8000, :, :].mean()/1000
sensor_energy_9 = energy_cache_2[0:9000, :, :].mean()/1000
sensor_energy_10 = energy_cache_2[0:10000, :, :].mean()/1000
sensor_energy_11 = energy_cache_2[0:11000, :, :].mean()/1000
sensor_energy_12 = energy_cache_2[0:12000, :, :].mean()/1000
sensor_energy_13 = energy_cache_2[0:13000, :, :].mean()/1000
sensor_energy_14 = energy_cache_2[0:14000, :, :].mean()/1000
sensor_energy_15 = energy_cache_2[0:15000, :, :].mean()/1000
sensor_energy_16 = energy_cache_2[0:16000, :, :].mean()/1000
x2 = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
y2 = [0,sensor_energy_1 ,sensor_energy_2,sensor_energy_3,sensor_energy_4,sensor_energy_5,sensor_energy_6,sensor_energy_7,sensor_energy_8,sensor_energy_9,sensor_energy_10,sensor_energy_11,sensor_energy_12,sensor_energy_13,sensor_energy_14,sensor_energy_15,sensor_energy_16 ]
plt.plot(x2, y2, 'b-o')
plt.yticks([0,0.1,0.2,0.3,0.4,0.5, 0.6, 0.7, 0.8, 0.9, 1.0])
plt.xticks([0,2000,4000,6000,8000,10000, 12000, 14000, 16000])
plt.xlabel('Number of rounds')
plt.ylabel('Residual energy(J)')
plt.grid(True)
plt.title("Residual energy ")
plt.legend(['Q-EAR + EOCC (SMO)', 'EOCC (SMO)'])
plt.show()
plt.close()

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)

x1 = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
y1 = [0,sensor_energy_1 ,sensor_energy_2,sensor_energy_3,sensor_energy_4,sensor_energy_5,sensor_energy_6,sensor_energy_7,sensor_energy_8,sensor_energy_9,sensor_energy_10,sensor_energy_11,sensor_energy_12,sensor_energy_13,sensor_energy_14,sensor_energy_15,sensor_energy_16 ]
plt.plot(x1, y1, 'r-o')

x2 = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
y2 = [0,sensor_energy_1 ,sensor_energy_2,sensor_energy_3,sensor_energy_4,sensor_energy_5,sensor_energy_6,sensor_energy_7,sensor_energy_8,sensor_energy_9,sensor_energy_10,sensor_energy_11,sensor_energy_12,sensor_energy_13,sensor_energy_14,sensor_energy_15,sensor_energy_16 ]
plt.plot(x2, y2, 'b-o')
plt.yticks([0.1,1,10,100])
plt.xticks([10,2000,4000,6000,8000,10000, 12000, 14000, 16000])
plt.xlabel('Number of rounds')
plt.ylabel('Residual energy(J)')
plt.grid(True)
plt.title("$\infty$")
plt.legend(['D2, s=2p', 'D2, s=3p', 'D2, s=4p', 'D2, s=4p'])
plt.show()
plt.close()

"""#Throughput

![Screenshot from 2022-05-26 04-00-56.png](data:image/png;base64,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)
"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_throughput_1 =  throughput_cache[:, :, 50].mean()/1000
sensor_throughput_2 =  throughput_cache[:, :, 100].mean()/1000
sensor_throughput_3 =  throughput_cache[:, :, 150].mean()/1000
sensor_throughput_4 =  throughput_cache[:, :, 200].mean()/1000
sensor_throughput_5 =  throughput_cache[:, :, 250].mean()/1000
sensor_throughput_6 =  throughput_cache[:, :, 300].mean()/1000
sensor_throughput_7 =  throughput_cache[:, :, 350].mean()/1000
sensor_throughput_8 =  throughput_cache[:, :, 400].mean()/1000
sensor_throughput_9 =  throughput_cache[:, :, 450].mean()/1000
sensor_throughput_10 = throughput_cache[:, :, 500].mean()/1000
xpoints_throughput = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
ypoints_throughput = [0,sensor_throughput_1 ,sensor_throughput_2 ,sensor_throughput_3 ,sensor_throughput_4 ,sensor_throughput_5 ,sensor_throughput_6 ,sensor_throughput_7 ,sensor_throughput_8 ,sensor_throughput_9 ,sensor_throughput_10,sensor_throughput_11,sensor_throughput_12,sensor_throughput_13,sensor_throughput_14,sensor_throughput_15,sensor_throughput_16]
plt.plot(xpoints_throughput, ypoints_throughput, 'r-o')
sensor_throughput_1 =  throughput_cache[:, :, 50].mean()/1000
sensor_throughput_2 =  throughput_cache[:, :, 100].mean()/1000
sensor_throughput_3 =  throughput_cache[:, :, 150].mean()/1000
sensor_throughput_4 =  throughput_cache[:, :, 200].mean()/1000
sensor_throughput_5 =  throughput_cache[:, :, 250].mean()/1000
sensor_throughput_6 =  throughput_cache[:, :, 300].mean()/1000
sensor_throughput_7 =  throughput_cache[:, :, 350].mean()/1000
sensor_throughput_8 =  throughput_cache[:, :, 400].mean()/1000
sensor_throughput_9 =  throughput_cache[:, :, 450].mean()/1000
sensor_throughput_10 = throughput_cache[:, :, 500].mean()/1000
xpoints_throughput = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
ypoints_throughput = [0,sensor_throughput_1 ,sensor_throughput_2 ,sensor_throughput_3 ,sensor_throughput_4 ,sensor_throughput_5 ,sensor_throughput_6 ,sensor_throughput_7 ,sensor_throughput_8 ,sensor_throughput_9 ,sensor_throughput_10,sensor_throughput_11,sensor_throughput_12,sensor_throughput_13,sensor_throughput_14,sensor_throughput_15,sensor_throughput_16]
plt.plot(xpoints_throughput, ypoints_throughput, 'b-o')
plt.yticks([0,0.10, 0.20, 0.30,0.40,0.50,0.60,0.70,0.80,0.90,1])
plt.xticks([50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Nodes')
plt.ylabel('Packet Reception Ratio')
plt.grid(True)
plt.legend(['Q-EAR + EOCC (SMO)', 'EOCC (SMO)'])
plt.show()
plt.close()

"""#End to End Delay

![Screenshot from 2022-05-26 04-17-46.png](data:image/png;base64,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)
"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_time_cache_1 =time_cache[:, :, 50].mean()
sensor_time_cache_2 =time_cache[:, :, 100].mean()
sensor_time_cache_3 =time_cache[:, :, 150].mean()
sensor_time_cache_4 =time_cache[:, :, 200].mean()
sensor_time_cache_5 =time_cache[:, :, 250].mean()
sensor_time_cache_6 =time_cache[:, :, 300].mean()
sensor_time_cache_7 =time_cache[:, :, 350].mean()
sensor_time_cache_8 =time_cache[:, :, 400].mean()
sensor_time_cache_9 =time_cache[:, :, 450].mean()
sensor_time_cache_10=time_cache[:, :, 500].mean()
x1 = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
y1 = [sensor_time_cache_1 ,sensor_time_cache_2 ,sensor_time_cache_3 ,sensor_time_cache_4 ,sensor_time_cache_5 ,sensor_time_cache_6 ,sensor_time_cache_7 ,sensor_time_cache_8 ,sensor_time_cache_9 ,sensor_time_cache_10]
plt.plot(x1,y1, 'r-o')
sensor_time_cache_1 =time_cache_2[:, :, 50].mean()
sensor_time_cache_2 =time_cache_2[:, :, 100].mean()
sensor_time_cache_3 =time_cache_2[:, :, 150].mean()
sensor_time_cache_4 =time_cache_2[:, :, 200].mean()
sensor_time_cache_5 =time_cache_2[:, :, 250].mean()
sensor_time_cache_6 =time_cache_2[:, :, 300].mean()
sensor_time_cache_7 =time_cache_2[:, :, 350].mean()
sensor_time_cache_8 =time_cache_2[:, :, 400].mean()
sensor_time_cache_9 =time_cache_2[:, :, 450].mean()
sensor_time_cache_10=time_cache_2[:, :, 500].mean()
x2 = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
y2 = [sensor_time_cache_1 ,sensor_time_cache_2 ,sensor_time_cache_3 ,sensor_time_cache_4 ,sensor_time_cache_5 ,sensor_time_cache_6 ,sensor_time_cache_7 ,sensor_time_cache_8 ,sensor_time_cache_9 ,sensor_time_cache_10]
plt.plot(x2,y2, 'b-o')
plt.yticks([0.1,0.2,  0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
plt.xticks([50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Number of nodes')
plt.ylabel('End-to-end-delay(sec)')
plt.title("End to End Delay")
plt.grid(True)
plt.legend(['Q-EAR based SMO', 'EOCC-TARA'])
plt.show()
plt.close()

"""#Nember of Heated Nodes"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_temp_cache_1 =temp_cache[:, :, 50].mean()
sensor_temp_cache_2 =temp_cache[:, :, 100].mean()
sensor_temp_cache_3 =temp_cache[:, :, 150].mean()
sensor_temp_cache_4 =temp_cache[:, :, 200].mean()
sensor_temp_cache_5 =temp_cache[:, :, 250].mean()
sensor_temp_cache_6 =temp_cache[:, :, 300].mean()
sensor_temp_cache_7 =temp_cache[:, :, 350].mean()
sensor_temp_cache_8 =temp_cache[:, :, 400].mean()
sensor_temp_cache_9 =temp_cache[:, :, 450].mean()
sensor_temp_cache_10=temp_cache[:, :, 500].mean()
x1 = plt.xticks([50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
y1 = [sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ]
plt.plot(x1,y1, 'r-o')
sensor_temp_cache_1 =temp_cache_2[:, :, 50].mean()
sensor_temp_cache_2 =temp_cache_2[:, :, 100].mean()
sensor_temp_cache_3 =temp_cache_2[:, :, 150].mean()
sensor_temp_cache_4 =temp_cache_2[:, :, 200].mean()
sensor_temp_cache_5 =temp_cache_2[:, :, 250].mean()
sensor_temp_cache_6 =temp_cache_2[:, :, 300].mean()
sensor_temp_cache_7 =temp_cache_2[:, :, 350].mean()
sensor_temp_cache_8 =temp_cache_2[:, :, 400].mean()
sensor_temp_cache_9 =temp_cache_2[:, :, 450].mean()
sensor_temp_cache_10=temp_cache_2[:, :, 500].mean()
x2 = plt.xticks([50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
y2 = [sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ]
plt.plot(x2,y2, 'b-o')
plt.yticks([0,5,10, 15, 20,25])
plt.xticks([50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Nodes')
plt.ylabel('Number of heated nodes')
plt.title("Number of heated nodes")
plt.grid(True)
plt.legend(['Q-EAR + EOCC (SMO)', 'EOCC (SMO)'])
plt.show()
plt.close()

"""#Episode"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_rewards_1 =rewards[0:1000, :, :].mean()
sensor_rewards_2 =rewards[0:2000, :, :].mean()
sensor_rewards_3 =rewards[0:3000, :, :].mean()
sensor_rewards_4 =rewards[0:4000, :, :].mean()
sensor_rewards_5 =rewards[0:5000, :, :].mean()
sensor_rewards_6 =rewards[0:6000, :, :].mean()
sensor_rewards_7 =rewards[0:7000, :, :].mean()
sensor_rewards_8 =rewards[0:8000, :, :].mean()
sensor_rewards_9 =rewards[0:9000, :, :].mean()
sensor_rewards_10=rewards[0:10000, :, :].mean()
sensor_rewards_11=rewards[0:11000, :, :].mean()
sensor_rewards_12=rewards[0:12000, :, :].mean()
sensor_rewards_13=rewards[0:13000, :, :].mean()
sensor_rewards_14=rewards[0:14000, :, :].mean()
sensor_rewards_15=rewards[0:15000, :, :].mean()
sensor_rewards_16=rewards[0:16000, :, :].mean()
xpoints_episode = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
ypoints_episode =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10,sensor_temp_cache_11,sensor_temp_cache_12,sensor_temp_cache_13,sensor_temp_cache_14,sensor_temp_cache_15,sensor_temp_cache_16]
plt.plot(xpoints_episode,ypoints_episode, 'r-o')
xpoints_episode2 = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
ypoints_episode2 =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10,sensor_temp_cache_11,sensor_temp_cache_12,sensor_temp_cache_13,sensor_temp_cache_14,sensor_temp_cache_15,sensor_temp_cache_16]
plt.plot(xpoints_episode2,ypoints_episode2, 'b-o')
plt.yticks([50, 100, 150, 200, 250, 300])
plt.xticks([0, 2000, 4000, 8000, 12000, 14000, 16000])
plt.xlabel('Episode')
plt.ylabel('Reward')
plt.show()

from keras.models import Sequential, Conv2D
from keras.layers import Activation, Dense, MaxPooling2D, Dropout, Flatten
def accuracy(self):
    model = Sequential()
    model.add(Conv2D(256, (3, 3)))
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.2))
    model.add(Conv2D(256, (3, 3)))
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.2))
    model.add(Flatten())
    model.add(Dense(64))
    model.add(Dense(env.ACTION_SPACE_SIZE, activation='linear'))
    model.compile(loss="mse", optimizer=Adam(lr=0.001), metrics=['accuracy'])
    return model
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_rewards_1 =rewards[0:1000, :, :].mean()
sensor_rewards_2 =rewards[0:2000, :, :].mean()
sensor_rewards_3 =rewards[0:3000, :, :].mean()
sensor_rewards_4 =rewards[0:4000, :, :].mean()
sensor_rewards_5 =rewards[0:5000, :, :].mean()
sensor_rewards_6 =rewards[0:6000, :, :].mean()
sensor_rewards_7 =rewards[0:7000, :, :].mean()
sensor_rewards_8 =rewards[0:8000, :, :].mean()
sensor_rewards_9 =rewards[0:9000, :, :].mean()
sensor_rewards_10=rewards[0:10000, :, :].mean()
sensor_rewards_11=rewards[0:11000, :, :].mean()
sensor_rewards_12=rewards[0:12000, :, :].mean()
sensor_rewards_13=rewards[0:13000, :, :].mean()
sensor_rewards_14=rewards[0:14000, :, :].mean()
sensor_rewards_15=rewards[0:15000, :, :].mean()
sensor_rewards_16=rewards[0:16000, :, :].mean()
xpoints_episode = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
ypoints_episode =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10,sensor_temp_cache_11,sensor_temp_cache_12,sensor_temp_cache_13,sensor_temp_cache_14,sensor_temp_cache_15,sensor_temp_cache_16]
plt.plot(xpoints_episode,ypoints_episode, 'r-o')
sensor_rewards_1 =rewards_2[0:1000, :, :].mean()
sensor_rewards_2 =rewards_2[0:2000, :, :].mean()
sensor_rewards_3 =rewards_2[0:3000, :, :].mean()
sensor_rewards_4 =rewards_2[0:4000, :, :].mean()
sensor_rewards_5 =rewards_2[0:5000, :, :].mean()
sensor_rewards_6 =rewards_2[0:6000, :, :].mean()
sensor_rewards_7 =rewards_2[0:7000, :, :].mean()
sensor_rewards_8 =rewards_2[0:8000, :, :].mean()
sensor_rewards_9 =rewards_2[0:9000, :, :].mean()
sensor_rewards_10=rewards_2[0:10000, :, :].mean()
sensor_rewards_11=rewards_2[0:11000, :, :].mean()
sensor_rewards_12=rewards_2[0:12000, :, :].mean()
sensor_rewards_13=rewards_2[0:13000, :, :].mean()
sensor_rewards_14=rewards_2[0:14000, :, :].mean()
sensor_rewards_15=rewards_2[0:15000, :, :].mean()
sensor_rewards_16=rewards_2[0:16000, :, :].mean()
xpoints_episode2 = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
ypoints_episode2 =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10,sensor_temp_cache_11,sensor_temp_cache_12,sensor_temp_cache_13,sensor_temp_cache_14,sensor_temp_cache_15,sensor_temp_cache_16]
plt.plot(xpoints_episode2,ypoints_episode2, 'b-o')
plt.yticks([0.0, 0.2, 0.4, 0.6, 0.8, 1.0])
plt.xticks([0, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000])
plt.xlabel('Episode')
plt.ylabel('Reward')
plt.show()

"""#**Throughput Priority**

#**Throughput Priority - High**
"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor = sensors_priority_cache[:]
df_sensor_H = df_sensor.loc[df_sensor[:] >90]
df_patient = patients_priority_cache[:]
df_patient_H = df_patient.loc[df_patient[:] >90]
ypoints_High = df_sensor_H + df_patient_H
plt.plot(ypoints_High, 'r-o')
df_sensor = sensors_priority_cache_2[:]
df_sensor_H = df_sensor.loc[df_sensor[:] >90]
df_patient = patients_priority_cache[:]
df_patient_H = df_patient.loc[df_patient[:] >90]
ypoints_High = df_sensor_H + df_patient_H
plt.plot(ypoints_High, 'k-o')
plt.yticks([1200, 1400, 1600, 1800, 2000, 2200,2400])
plt.xticks([2000,  4000,  6000,  8000,  10000,  12000,  14000,  16000])
plt.xlabel('Number of rounds')
plt.ylabel('Throughput(bps)')
plt.title('Throughput(bps) - High priority ')
plt.grid(True)
plt.legend(['QEAR-High priority packets',  'EOCC-High priority packets'], loc='lower right')
plt.show()

"""#**Throughput Priority - Medium**"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor = sensors_priority_cache[:]
df_sensor_M = df_sensor.loc[df_sensor[:] <60]
df_patient = patients_priority_cache[:]
df_patient_M = df_sensor.loc[df_sensor[:] <60]
ypoints_Medium = df_sensor_M + df_patient_M
plt.plot(ypoints_Medium, 'g-o')
df_sensor = sensors_priority_cache_2[:]
df_sensor_M = df_sensor.loc[df_sensor[:] <60]
df_patient = patients_priority_cache[:]
df_patient_M = df_sensor.loc[df_sensor[:] <60]
ypoints_Medium = df_sensor_M + df_patient_M
plt.plot(ypoints_Medium, 'y-o')
plt.yticks([1200, 1400, 1600, 1800, 2000])
plt.xticks([2000,  4000,  6000,  8000,  10000,  12000,  14000,  16000])
plt.xlabel('Number of rounds')
plt.ylabel('Throughput(bps)')
plt.title('Throughput(bps)- Medium priority')
plt.legend(['QEAR-Medium priority packets',  'EOCC-Medium priority packets'], loc='upper right')
plt.grid(True)
plt.show()

"""#**Throughput Priority - Low**"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor = sensors_priority_cache[:]
df_sensor_L = df_sensor.loc[df_sensor[:] <30]
df_patient = patients_priority_cache[:]
df_patient_L = df_sensor.loc[df_sensor[:] <30]
ypoints_Low = df_sensor_L + df_patient_L
plt.plot(ypoints_Low, 'b-o')
df_sensor = sensors_priority_cache_2[:]
df_sensor_L = df_sensor.loc[df_sensor[:] <30]
df_patient = patients_priority_cache[:]
df_patient_L = df_sensor.loc[df_sensor[:] <30]
ypoints_Low = df_sensor_L + df_patient_L
plt.plot(ypoints_Low, 'm-o')
plt.yticks([200, 400, 600,800, 1000,1200, 1400])
plt.xticks([2000,  4000,  6000,  8000,  10000,  12000,  14000,  16000])
plt.xlabel('Number of rounds')
plt.ylabel('Throughput(bps)')
plt.title('Throughput(bps)-Low priority')
plt.legend(['QEAR-Low priority packets',  'EOCC-Low priority packets'], loc='lower right')
plt.show()

"""#**End to end Priority - High**"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor = sensors_priority_cache[:]
df_sensor_H = df_sensor.loc[df_sensor[:] >90]
time_cache_H=time_cache[df_sensor_H]
ypoints_High = time_cache_H
plt.plot(ypoints_High, 'r-o')
df_sensor = sensors_priority_cache_2[:]
df_sensor_H = df_sensor.loc[df_sensor[:] >90]
time_cache_H=time_cache[df_sensor_H]
ypoints_High = time_cache_H
plt.plot(ypoints_High, 'k-o')
plt.yticks([0.1,0.2, 0.3,0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([2000,  4000,  6000,  8000,  10000,  12000,  14000,  16000])
plt.xlabel('Number of rounds')
plt.ylabel('End-to-end delay (sec)- High priority')
plt.title('End-to-end delay - High priority')
plt.legend(['Q-EAR-High priority packets', 'EOCC-High priority packets'], loc='upper right')
plt.grid(True)
plt.show()
plt.close()

"""#**End to end Priority - Medium**"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor = sensors_priority_cache[:]
df_sensor_L = df_sensor.loc[df_sensor[:] <60]
time_cache_L=time_cache[df_sensor_L]
ypoints_Medium = time_cache_L
plt.plot(ypoints_Medium, 'r-o')
df_sensor = sensors_priority_cache_2[:]
df_sensor_L = df_sensor.loc[df_sensor[:] <60]
time_cache_L=time_cache[df_sensor_L]
ypoints_Medium = time_cache_L
plt.plot(ypoints_Medium, 'k-o')
plt.yticks([0.1,0.2, 0.3,0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([2000,  4000,  6000,  8000,  10000,  12000,  14000,  16000])
plt.xlabel('Number of rounds')
plt.ylabel('End-to-end delay (sec)- Medium priority')
plt.title('End-to-end delay - Medium priority')
plt.legend(['Q-EAR-Medium priority packets', 'EOCC-Medium priority packets'], loc='upper right')
plt.grid(True)
plt.show()
plt.close()

"""#**End to end Priority - Low**"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor = sensors_priority_cache[:]
df_sensor_L = df_sensor.loc[df_sensor[:] <30]
time_cache_L=time_cache[df_sensor_L]
ypoints_High = time_cache_H
ypoints_Low = time_cache_L
plt.plot(ypoints_Low, 'b-o')
df_sensor = sensors_priority_cache_2[:]
df_sensor_L = df_sensor.loc[df_sensor[:] <30]
time_cache_L=time_cache[df_sensor_L]
ypoints_Low = time_cache_L
plt.plot(ypoints_Low, 'm-o')
#plt.yticks([0.01,0.02, 0.03,0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1])
plt.xticks([2000,  4000,  6000,  8000,  10000,  12000,  14000,  16000])
plt.xlabel('Number of rounds')
plt.ylabel('End-to-end delay (sec)- Low priority')
plt.title('End-to-end delay - Low priority')
plt.legend(['Q-EAR-Low priority packets', 'EOCC-Low priority packets'], loc='upper right')
plt.grid(True)
plt.show()
plt.close()

"""#Network lifetime"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_dead_cache_1 =sensors_dead_cache[:, :, 50].mean()/1000
sensor_dead_cache_2 =sensors_dead_cache[:, :, 100].mean()/1000
sensor_dead_cache_3 =sensors_dead_cache[:, :, 150].mean()/1000
sensor_dead_cache_4 =sensors_dead_cache[:, :, 200].mean()/1000
sensor_dead_cache_5 =sensors_dead_cache[:, :, 250].mean()/1000
sensor_dead_cache_6 =sensors_dead_cache[:, :, 300].mean()/1000
sensor_dead_cache_7 =sensors_dead_cache[:, :, 350].mean()/1000
sensor_dead_cache_8 =sensors_dead_cache[:, :, 400].mean()/1000
sensor_dead_cache_9 =sensors_dead_cache[:, :, 450].mean()/1000
sensor_dead_cache_10=sensors_dead_cache[:, :, 500].mean()/1000
xpoints_dead = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_dead = [sensor_dead_cache_1,sensor_dead_cache_2 ,sensor_dead_cache_3 ,sensor_dead_cache_4 ,sensor_dead_cache_5 ,sensor_dead_cache_6 ,sensor_dead_cache_7 ,sensor_dead_cache_8 ,ensor_dead_cache_9 ,sensor_dead_cache_10]
plt.plot(xpoints_dead,ypoints_dead, 'r-o')
sensor_dead_cache_1 =sensors_dead_cache_2[:, :, 50].mean()/1000
sensor_dead_cache_2 =sensors_dead_cache_2[:, :, 100].mean()/1000
sensor_dead_cache_3 =sensors_dead_cache_2[:, :, 150].mean()/1000
sensor_dead_cache_4 =sensors_dead_cache_2[:, :, 200].mean()/1000
sensor_dead_cache_5 =sensors_dead_cache_2[:, :, 250].mean()/1000
sensor_dead_cache_6 =sensors_dead_cache_2[:, :, 300].mean()/1000
sensor_dead_cache_7 =sensors_dead_cache_2[:, :, 350].mean()/1000
sensor_dead_cache_8 =sensors_dead_cache_2[:, :, 400].mean()/1000
sensor_dead_cache_9 =sensors_dead_cache_2[:, :, 450].mean()/1000
sensor_dead_cache_10=sensors_dead_cache_2[:, :, 500].mean()/1000
xpoints_dead = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_dead = [sensor_dead_cache_1,sensor_dead_cache_2 ,sensor_dead_cache_3 ,sensor_dead_cache_4 ,sensor_dead_cache_5 ,sensor_dead_cache_6 ,sensor_dead_cache_7 ,sensor_dead_cache_8 ,ensor_dead_cache_9 ,sensor_dead_cache_10]
plt.plot(xpoints_dead,ypoints_dead, 'b-o')
plt.xticks([50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.yticks([0, 500, 1000, 1500, 2000, 2500, 3000])
plt.xlabel('Number of nodes')
plt.ylabel('Network lifetime')
plt.title("Network lifetime")
plt.grid(True)
plt.legend(['Q-EAR based SMO', 'EOCC-TARA'])
plt.show()
plt.close()

"""#Dead Nodes

"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_dead_cache_1 =sensors_dead_cache[:, :, 50].mean()
sensor_dead_cache_2 =sensors_dead_cache[:, :, 100].mean()
sensor_dead_cache_3 =sensors_dead_cache[:, :, 150].mean()
sensor_dead_cache_4 =sensors_dead_cache[:, :, 200].mean()
sensor_dead_cache_5 =sensors_dead_cache[:, :, 250].mean()
sensor_dead_cache_6 =sensors_dead_cache[:, :, 300].mean()
sensor_dead_cache_7 =sensors_dead_cache[:, :, 350].mean()
sensor_dead_cache_8 =sensors_dead_cache[:, :, 400].mean()
sensor_dead_cache_9 =sensors_dead_cache[:, :, 450].mean()
sensor_dead_cache_10=sensors_dead_cache[:, :, 500].mean()
xpoints_dead = [0,2000,4000,6000,8000,10000, 12000, 14000, 16000]
ypoints_dead = [sensor_dead_cache_1,sensor_dead_cache_2 ,sensor_dead_cache_3 ,sensor_dead_cache_4 ,sensor_dead_cache_5 ,sensor_dead_cache_6 ,sensor_dead_cache_7 ,sensor_dead_cache_8 ,ensor_dead_cache_9 ,sensor_dead_cache_10]
plt.plot(xpoints_dead,ypoints_dead, 'r-o')
sensor_dead_cache_1 =sensors_dead_cache_2[:, :, 50].mean()
sensor_dead_cache_2 =sensors_dead_cache_2[:, :, 100].mean()
sensor_dead_cache_3 =sensors_dead_cache_2[:, :, 150].mean()
sensor_dead_cache_4 =sensors_dead_cache_2[:, :, 200].mean()
sensor_dead_cache_5 =sensors_dead_cache_2[:, :, 250].mean()
sensor_dead_cache_6 =sensors_dead_cache_2[:, :, 300].mean()
sensor_dead_cache_7 =sensors_dead_cache_2[:, :, 350].mean()
sensor_dead_cache_8 =sensors_dead_cache_2[:, :, 400].mean()
sensor_dead_cache_9 =sensors_dead_cache_2[:, :, 450].mean()
sensor_dead_cache_10=sensors_dead_cache_2[:, :, 500].mean()
xpoints_dead = [0,2000,4000,6000,8000,10000, 12000, 14000, 16000]
ypoints_dead = [sensor_dead_cache_1,sensor_dead_cache_2 ,sensor_dead_cache_3 ,sensor_dead_cache_4 ,sensor_dead_cache_5 ,sensor_dead_cache_6 ,sensor_dead_cache_7 ,sensor_dead_cache_8 ,ensor_dead_cache_9 ,sensor_dead_cache_10]
plt.plot(xpoints_dead,ypoints_dead, 'b-o')
plt.yticks([0,50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xticks([0,2000,4000,6000,8000,10000, 12000, 14000, 16000])
plt.xlabel('Nodes')
plt.ylabel('Number of dead nodes')
plt.grid(True)
plt.legend(['Q-EAR + EOCC (SMO)', 'EOCC (SMO)'])
plt.show()
plt.close()

"""#Transmission Rate"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_throughput_1=throughput_cache[0:1000, :, :].mean()*10**2
sensor_throughput_2=throughput_cache[0:2000, :, :].mean()*10**2
sensor_throughput_3=throughput_cache[0:3000, :, :].mean()*10**2
sensor_throughput_4=throughput_cache[0:4000, :, :].mean()*10**2
sensor_throughput_5=throughput_cache[0:5000, :, :].mean()*10**2
sensor_throughput_6=throughput_cache[0:6000, :, :].mean()*10**2
sensor_throughput_7=throughput_cache[0:7000, :, :].mean()*10**2
sensor_throughput_8=throughput_cache[0:8000, :, :].mean()*10**2
sensor_throughput_9=throughput_cache[0:9000, :, :].mean()*10**2
sensor_throughput_10=throughput_cache[0:10000, :, :].mean()*10**2
xpoints_throughput = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000]
ypoints_throughput = [0,sensor_throughput_1 ,sensor_throughput_2 ,sensor_throughput_3 ,sensor_throughput_4 ,sensor_throughput_5 ,sensor_throughput_6 ,sensor_throughput_7 ,sensor_throughput_8 ,sensor_throughput_9 ,sensor_throughput_10,sensor_throughput_11,sensor_throughput_12,sensor_throughput_13,sensor_throughput_14,sensor_throughput_15,sensor_throughput_16]
plt.plot(xpoints_throughput,ypoints_throughput, 'r-o')
sensor_throughput_1=throughput_cache_2[0:1000, :, :].mean()*10**2
sensor_throughput_2=throughput_cache_2[0:2000, :, :].mean()*10**2
sensor_throughput_3=throughput_cache_2[0:3000, :, :].mean()*10**2
sensor_throughput_4=throughput_cache_2[0:4000, :, :].mean()*10**2
sensor_throughput_5=throughput_cache_2[0:5000, :, :].mean()*10**2
sensor_throughput_6=throughput_cache_2[0:6000, :, :].mean()*10**2
sensor_throughput_7=throughput_cache_2[0:7000, :, :].mean()*10**2
sensor_throughput_8=throughput_cache_2[0:8000, :, :].mean()*10**2
sensor_throughput_9=throughput_cache_2[0:9000, :, :].mean()*10**2
sensor_throughput_10=throughput_cache_2[0:10000, :, :].mean()*10**2
xpoints_throughput = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000]
ypoints_throughput = [0,sensor_throughput_1 ,sensor_throughput_2 ,sensor_throughput_3 ,sensor_throughput_4 ,sensor_throughput_5 ,sensor_throughput_6 ,sensor_throughput_7 ,sensor_throughput_8 ,sensor_throughput_9 ,sensor_throughput_10,sensor_throughput_11,sensor_throughput_12,sensor_throughput_13,sensor_throughput_14,sensor_throughput_15,sensor_throughput_16]
plt.plot(xpoints_throughput,ypoints_throughput, 'b-o')
plt.yticks([0,10, 20, 30,40,50,60,70,80,90,100])
plt.xticks([0, 2000, 4000,  6000, 8000, 10000])
plt.xlabel('Number of rounds')
plt.ylabel('Transmission rate (%)')
plt.title("Transmission rate (%)")
plt.grid(True)
plt.legend(['Q-EAR + EOCC (SMO)', 'EOCC (SMO)'])
plt.show()
plt.close()

"""#Energy by Power"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor_power = power_cache_2[:,:,:]
df_sensor_H = df_sensor_power.loc[df_sensor_power[:] ==0]
sensor_power_cache_1=energy_cache(df_sensor_H[:, :, 50])
sensor_power_cache_2=energy_cache(df_sensor_H[:, :, 100])
sensor_power_cache_3=energy_cache(df_sensor_H[:, :, 150])
sensor_power_cache_4=energy_cache(df_sensor_H[:, :, 200])
sensor_power_cache_5=energy_cache(df_sensor_H[:, :, 250])
sensor_power_cache_6=energy_cache(df_sensor_H[:, :, 300])
sensor_power_cache_7=energy_cache(df_sensor_H[:, :, 350])
sensor_power_cache_8=energy_cache(df_sensor_H[:, :, 400])
sensor_power_cache_9=energy_cache(df_sensor_H[:, :, 450])
sensor_power_cache_10=energy_cache(df_sensor_H[:, :, 500])
xpoints_H = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_H = [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_H,ypoints_H, 'g-o')
df_sensor_power = power_cache[:,:,:]
df_sensor_H = df_sensor_power.loc[df_sensor_power[:] ==0]
sensor_power_cache_1=energy_cache(df_sensor_H[:,10, :])
sensor_power_cache_2=energy_cache(df_sensor_H[:,20, :])
sensor_power_cache_3=energy_cache(df_sensor_H[:,30, :])
sensor_power_cache_4=energy_cache(df_sensor_H[:,40, :])
sensor_power_cache_5=energy_cache(df_sensor_H[:,50, :])
sensor_power_cache_6=energy_cache(df_sensor_H[:,60, :])
sensor_power_cache_7=energy_cache(df_sensor_H[:,70, :])
sensor_power_cache_8=energy_cache(df_sensor_H[:,80, :])
sensor_power_cache_9=energy_cache(df_sensor_H[:,90, :])
sensor_power_cache_10=energy_cache(df_sensor_H[:,100, :])
xpoints_H = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_H = [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_H,ypoints_H, 'k-o')
plt.yticks([0,0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([0,50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Number of Nodes')
plt.ylabel('Energy Consumption (J)')
plt.grid(True)
plt.legend(['Q-EAR +  EOCC (SMO) - Power=0dBm', ' EOCC (SMO) - Power=0dBm'])
plt.show()
plt.close()

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor_power = power_cache_2[:,:,:]
df_sensor_M = df_sensor_power.loc[df_sensor_power[:] ==-5]
sensor_power_cache_1=energy_cache_2(df_sensor_M[:, :, 50])
sensor_power_cache_2=energy_cache_2(df_sensor_M[:, :, 100])
sensor_power_cache_3=energy_cache_2(df_sensor_M[:, :, 150])
sensor_power_cache_4=energy_cache_2(df_sensor_M[:, :, 200])
sensor_power_cache_5=energy_cache_2(df_sensor_M[:, :, 250])
sensor_power_cache_6=energy_cache_2(df_sensor_M[:, :, 300])
sensor_power_cache_7=energy_cache_2(df_sensor_M[:, :, 350])
sensor_power_cache_8=energy_cache_2(df_sensor_M[:, :, 400])
sensor_power_cache_9=energy_cache_2(df_sensor_M[:, :, 450])
sensor_power_cache_10=energy_cache_2(df_sensor_M[:, :, 500])
xpoints_M= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_M= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_M,ypoints_M, 'r-o')
df_sensor_power = power_cache[:,:,:]
df_sensor_M = df_sensor_power.loc[df_sensor_power[:] ==-5]
sensor_power_cache_1=energy_cache(df_sensor_M[:, :, 50])
sensor_power_cache_2=energy_cache(df_sensor_M[:, :, 100])
sensor_power_cache_3=energy_cache(df_sensor_M[:, :, 150])
sensor_power_cache_4=energy_cache(df_sensor_M[:, :, 200])
sensor_power_cache_5=energy_cache(df_sensor_M[:, :, 250])
sensor_power_cache_6=energy_cache(df_sensor_M[:, :, 300])
sensor_power_cache_7=energy_cache(df_sensor_M[:, :, 350])
sensor_power_cache_8=energy_cache(df_sensor_M[:, :, 400])
sensor_power_cache_9=energy_cache(df_sensor_M[:, :, 450])
sensor_power_cache_10=energy_cache(df_sensor_M[:, :, 500])
xpoints_M= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_M= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_M,ypoints_M, 'y-o')
plt.yticks([0,0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([0,50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Number of Nodes')
plt.ylabel('Energy Consumption (J)')
plt.grid(True)
plt.legend(['Q-EAR +  EOCC (SMO) - Power=-5dBm', ' EOCC (SMO) - Power=-5dBm'])
plt.show()
plt.close()

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor_power = power_cache_2[:,:,:]
df_sensor_L = df_sensor_power.loc[df_sensor_power[:] ==-10]
sensor_power_cache_1=energy_cache_2(df_sensor_L[:, :, 50])
sensor_power_cache_2=energy_cache_2(df_sensor_L[:, :, 100])
sensor_power_cache_3=energy_cache_2(df_sensor_L[:, :, 150])
sensor_power_cache_4=energy_cache_2(df_sensor_L[:, :, 200])
sensor_power_cache_5=energy_cache_2(df_sensor_L[:, :, 250])
sensor_power_cache_6=energy_cache_2(df_sensor_L[:, :, 300])
sensor_power_cache_7=energy_cache_2(df_sensor_L[:, :, 350])
sensor_power_cache_8=energy_cache_2(df_sensor_L[:, :, 400])
sensor_power_cache_9=energy_cache_2(df_sensor_L[:, :, 450])
sensor_power_cache_10=energy_cache_2(df_sensor_L[:, :, 500])
xpoints_L= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_L= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_L,ypoints_L, 'b-o')
df_sensor_power = power_cache[:,:,:]
df_sensor_L = df_sensor_power.loc[df_sensor_power[:] ==-10]
sensor_power_cache_1=energy_cache(df_sensor_L[:, :, 50])
sensor_power_cache_2=energy_cache(df_sensor_L[:, :, 100])
sensor_power_cache_3=energy_cache(df_sensor_L[:, :, 150])
sensor_power_cache_4=energy_cache(df_sensor_L[:, :, 200])
sensor_power_cache_5=energy_cache(df_sensor_L[:, :, 250])
sensor_power_cache_6=energy_cache(df_sensor_L[:, :, 300])
sensor_power_cache_7=energy_cache(df_sensor_L[:, :, 350])
sensor_power_cache_8=energy_cache(df_sensor_L[:, :, 400])
sensor_power_cache_9=energy_cache(df_sensor_L[:, :, 450])
sensor_power_cache_10=energy_cache(df_sensor_L[:, :, 500])
xpoints_L= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_L= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_L,ypoints_L, 'm-o')
plt.yticks([0,0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([0,50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Number of Nodes')
plt.ylabel('Energy Consumption (J)')
plt.grid(True)
plt.legend(['Q-EAR +  EOCC (SMO) - Power=-10dBm', ' EOCC (SMO) - Power=-10dBm'])
plt.show()
plt.close()

"""#Number of heated nodes by power"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor_power = power_cache_2[:,:,:]
df_sensor_H = df_sensor_power.loc[df_sensor_power[:] ==0]
sensor_power_cache_1=temp_cache_2(df_sensor_L[:, :, 50])
sensor_power_cache_2=temp_cache_2(df_sensor_L[:, :, 100])
sensor_power_cache_3=temp_cache_2(df_sensor_L[:, :, 150])
sensor_power_cache_4=temp_cache_2(df_sensor_L[:, :, 200])
sensor_power_cache_5=temp_cache_2(df_sensor_L[:, :, 250])
sensor_power_cache_6=temp_cache_2(df_sensor_L[:, :, 300])
sensor_power_cache_7=temp_cache_2(df_sensor_L[:, :, 350])
sensor_power_cache_8=temp_cache_2(df_sensor_L[:, :, 400])
sensor_power_cache_9=temp_cache_2(df_sensor_L[:, :, 450])
sensor_power_cache_10=temp_cache_2(df_sensor_L[:, :, 500])
xpoints_L= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_L= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_L,ypoints_L, 'r-o')
df_sensor_power = power_cache[:,:,:]
df_sensor_H = df_sensor_power.loc[df_sensor_power[:] ==0]
sensor_power_cache_1=temp_cache(df_sensor_L[:,10, :])
sensor_power_cache_2=temp_cache(df_sensor_L[:,20, :])
sensor_power_cache_3=temp_cache(df_sensor_L[:,30, :])
sensor_power_cache_4=temp_cache(df_sensor_L[:,40, :])
sensor_power_cache_5=temp_cache(df_sensor_L[:,50, :])
sensor_power_cache_6=temp_cache(df_sensor_L[:,60, :])
sensor_power_cache_7=temp_cache(df_sensor_L[:,70, :])
sensor_power_cache_8=temp_cache(df_sensor_L[:,80, :])
sensor_power_cache_9=temp_cache(df_sensor_L[:,90, :])
sensor_power_cache_10=temp_cache(df_sensor_L[:,100, :])
xpoints_L= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_L= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_L,ypoints_L, 'm-o')
plt.yticks([0,5,10,15,20,25,30,35,40,45, 50,55,60,65,70])
plt.xticks([0,50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Number of Nodes')
plt.ylabel('Number of heated nodes')
plt.title("Nember of Heated Nodes")
plt.legend(['Q-EAR +  EOCC (SMO) - Power=0dBm', ' EOCC (SMO) - Power=0dBm'])
plt.grid(True)

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor_power = power_cache_2[:,:,:]
df_sensor_M = df_sensor_power.loc[df_sensor_power[:] ==-10]
sensor_power_cache_1=temp_cache_2(df_sensor_H[:, :, 50])
sensor_power_cache_2=temp_cache_2(df_sensor_H[:, :, 100])
sensor_power_cache_3=temp_cache_2(df_sensor_H[:, :, 150])
sensor_power_cache_4=temp_cache_2(df_sensor_H[:, :, 200])
sensor_power_cache_5=temp_cache_2(df_sensor_H[:, :, 250])
sensor_power_cache_6=temp_cache_2(df_sensor_H[:, :, 300])
sensor_power_cache_7=temp_cache_2(df_sensor_H[:, :, 350])
sensor_power_cache_8=temp_cache_2(df_sensor_H[:, :, 400])
sensor_power_cache_9=temp_cache_2(df_sensor_H[:, :, 450])
sensor_power_cache_10=temp_cache_2(df_sensor_H[:, :, 500])
xpoints_H = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_H = [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_H,ypoints_H, 'g-o')
df_sensor_power = power_cache[:,:,:]
df_sensor_M = df_sensor_power.loc[df_sensor_power[:] ==-10]
sensor_power_cache_1=temp_cache(df_sensor_H[:, :, 50])
sensor_power_cache_2=temp_cache(df_sensor_H[:, :, 100])
sensor_power_cache_3=temp_cache(df_sensor_H[:, :, 150])
sensor_power_cache_4=temp_cache(df_sensor_H[:, :, 200])
sensor_power_cache_5=temp_cache(df_sensor_H[:, :, 250])
sensor_power_cache_6=temp_cache(df_sensor_H[:, :, 300])
sensor_power_cache_7=temp_cache(df_sensor_H[:, :, 350])
sensor_power_cache_8=temp_cache(df_sensor_H[:, :, 400])
sensor_power_cache_9=temp_cache(df_sensor_H[:, :, 450])
sensor_power_cache_10=temp_cache(df_sensor_H[:, :, 500])
xpoints_H = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_H = [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_H,ypoints_H, 'k-o')
plt.yticks([0,5,10,15,20,25,30,35,40,45, 50,55,60,65,70])
plt.xticks([0,50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Number of Nodes')
plt.ylabel('Number of heated nodes')
plt.title("Nember of Heated Nodes")
plt.legend(['Q-EAR +  EOCC (SMO) - Power=-10dBm', ' EOCC (SMO) - Power=-10dBm'])
plt.grid(True)

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor_power = power_cache_2[:,:,:]
df_sensor_L = df_sensor_power.loc[df_sensor_power[:] ==-5]
sensor_power_cache_1=temp_cache_2(df_sensor_M[:, :, 50])
sensor_power_cache_2=temp_cache_2(df_sensor_M[:, :, 100])
sensor_power_cache_3=temp_cache_2(df_sensor_M[:, :, 150])
sensor_power_cache_4=temp_cache_2(df_sensor_M[:, :, 200])
sensor_power_cache_5=temp_cache_2(df_sensor_M[:, :, 250])
sensor_power_cache_6=temp_cache_2(df_sensor_M[:, :, 300])
sensor_power_cache_7=temp_cache_2(df_sensor_M[:, :, 350])
sensor_power_cache_8=temp_cache_2(df_sensor_M[:, :, 400])
sensor_power_cache_9=temp_cache_2(df_sensor_M[:, :, 450])
sensor_power_cache_10=temp_cache_2(df_sensor_M[:, :, 500])
xpoints_M= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_M= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_M,ypoints_M, 'b-o')
df_sensor_power = power_cache[:,:,:]
df_sensor_M = df_sensor_power.loc[df_sensor_power[:] ==-5]
sensor_power_cache_1=temp_cache(df_sensor_M[:, :, 50])
sensor_power_cache_2=temp_cache(df_sensor_M[:, :, 100])
sensor_power_cache_3=temp_cache(df_sensor_M[:, :, 150])
sensor_power_cache_4=temp_cache(df_sensor_M[:, :, 200])
sensor_power_cache_5=temp_cache(df_sensor_M[:, :, 250])
sensor_power_cache_6=temp_cache(df_sensor_M[:, :, 300])
sensor_power_cache_7=temp_cache(df_sensor_M[:, :, 350])
sensor_power_cache_8=temp_cache(df_sensor_M[:, :, 400])
sensor_power_cache_9=temp_cache(df_sensor_M[:, :, 450])
sensor_power_cache_10=temp_cache(df_sensor_M[:, :, 500])
xpoints_M= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_M= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_M,ypoints_M, 'y-o')
plt.yticks([0,5,10,15,20,25,30,35,40,45, 50,55,60,65,70])
plt.xticks([0,50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Number of Nodes')
plt.ylabel('Number of heated nodes')
plt.title("Nember of Heated Nodes")
plt.legend(['Q-EAR +  EOCC (SMO) - Power=-5dBm', ' EOCC (SMO) - Power=-5dBm'])
plt.grid(True)

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)

xpoints_M= [0,20, 40, 60, 70, 80 , 90, 100]
ypoints_M= [18,35,45, 58, 68, 70, 72, 75]
plt.plot(xpoints_M,ypoints_M, 'r-o')

xpoints_M= [0,20, 40, 60, 70, 80 , 90, 100]
ypoints_M= [25,45,55, 68, 70, 82, 85, 90]
plt.plot(xpoints_M,ypoints_M, 'b-o')
plt.xticks([0, 20 ,40, 60, 80, 100])
plt.yticks([0, 20, 40 ,60, 80 ,100])
plt.xlabel('Time (s)')
plt.ylabel('Work Load')
plt.title("Load Balancing With Different Task Allocation Policies")
plt.legend(['Q-Learning', 'SARSA'])
plt.grid(True)

"""#Packet by power"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor_power = power_cache_2[:,:,:]
df_sensor_M = df_sensor_power.loc[df_sensor_power[:] ==-5]
sensor_power_cache_1=throughput_cache_2(df_sensor_M[:, :, 50])
sensor_power_cache_2=throughput_cache_2(df_sensor_M[:, :, 100])
sensor_power_cache_3=throughput_cache_2(df_sensor_M[:, :, 150])
sensor_power_cache_4=throughput_cache_2(df_sensor_M[:, :, 200])
sensor_power_cache_5=throughput_cache_2(df_sensor_M[:, :, 250])
sensor_power_cache_6=throughput_cache_2(df_sensor_M[:, :, 300])
sensor_power_cache_7=throughput_cache_2(df_sensor_M[:, :, 350])
sensor_power_cache_8=throughput_cache_2(df_sensor_M[:, :, 400])
sensor_power_cache_9=throughput_cache_2(df_sensor_M[:, :, 450])
sensor_power_cache_10=throughput_cache_2(df_sensor_M[:, :, 500])
xpoints_M= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_M= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_M,ypoints_M, 'r-o')
df_sensor_power = power_cache[:,:,:]
df_sensor_M = df_sensor_power.loc[df_sensor_power[:] ==-5]
sensor_power_cache_1=throughput_cache(df_sensor_M[:, :, 50])
sensor_power_cache_2=throughput_cache(df_sensor_M[:, :, 100])
sensor_power_cache_3=throughput_cache(df_sensor_M[:, :, 150])
sensor_power_cache_4=throughput_cache(df_sensor_M[:, :, 200])
sensor_power_cache_5=throughput_cache(df_sensor_M[:, :, 250])
sensor_power_cache_6=throughput_cache(df_sensor_M[:, :, 300])
sensor_power_cache_7=throughput_cache(df_sensor_M[:, :, 350])
sensor_power_cache_8=throughput_cache(df_sensor_M[:, :, 400])
sensor_power_cache_9=throughput_cache(df_sensor_M[:, :, 450])
sensor_power_cache_10=throughput_cach(df_sensor_M[:, :, 500])
xpoints_M= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_M= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,sensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_M,ypoints_M, 'Y-o')
plt.yticks([0,0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Nodes')
plt.ylabel('Packet Reception Ratio')
plt.title("Packet Reception Ratio By Power")
plt.legend(['QEAR + EOCC Power=-5dBm', 'EOCC - Power=-5dBm'], loc='upper right')
plt.grid(True)

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor_power = power_cache_2[:,:,:]
df_sensor_H = df_sensor_power.loc[df_sensor_power[:] ==0]
sensor_power_cache_1=throughput_cache_2(df_sensor_L[:, :, 50])
sensor_power_cache_2=throughput_cache_2(df_sensor_L[:, :, 100])
sensor_power_cache_3=throughput_cache_2(df_sensor_L[:, :, 150])
sensor_power_cache_4=throughput_cache_2(df_sensor_L[:, :, 200])
sensor_power_cache_5=throughput_cache_2(df_sensor_L[:, :, 250])
sensor_power_cache_6=throughput_cache_2(df_sensor_L[:, :, 300])
sensor_power_cache_7=throughput_cache_2(df_sensor_L[:, :, 350])
sensor_power_cache_8=throughput_cache_2(df_sensor_L[:, :, 400])
sensor_power_cache_9=throughput_cache_2(df_sensor_L[:, :, 450])
sensor_power_cache_10=throughput_cache_2(df_sensor_L[:, :, 500])
xpoints_L= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_L= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,ensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_L,ypoints_L, 'b-o')
df_sensor_power = power_cache[:,:,:]
df_sensor_H = df_sensor_power.loc[df_sensor_power[:] ==0]
sensor_power_cache_1=throughput_cache(df_sensor_L[:, :, 50])
sensor_power_cache_2=throughput_cache(df_sensor_L[:, :, 100])
sensor_power_cache_3=throughput_cache(df_sensor_L[:, :, 150])
sensor_power_cache_4=throughput_cache(df_sensor_L[:, :, 200])
sensor_power_cache_5=throughput_cache(df_sensor_L[:, :, 250])
sensor_power_cache_6=throughput_cache(df_sensor_L[:, :, 300])
sensor_power_cache_7=throughput_cache(df_sensor_L[:, :, 350])
sensor_power_cache_8=throughput_cache(df_sensor_L[:, :, 400])
sensor_power_cache_9=throughput_cache(df_sensor_L[:, :, 450])
sensor_power_cache_10=throughput_cache(df_sensor_L[:, :, 500])
xpoints_L= [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_L= [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,ensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_L,ypoints_L, 'm-o')
plt.yticks([0,0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Nodes')
plt.ylabel('Packet Reception Ratio')
plt.title("Packet Reception Ratio By Power")
plt.legend(['QEAR + EOCC Power=0dBm', 'EOCC - Power=0dBm'], loc='upper right')
plt.grid(True)

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
df_sensor_power = power_cache_2[:,:,:]
df_sensor_M = df_sensor_power.loc[df_sensor_power[:] ==-10]
sensor_power_cache_1=throughput_cache_2(df_sensor_H[:, :, 50])
sensor_power_cache_2=throughput_cache_2(df_sensor_H[:, :, 100])
sensor_power_cache_3=throughput_cache_2(df_sensor_H[:, :, 150])
sensor_power_cache_4=throughput_cache_2(df_sensor_H[:, :, 200])
sensor_power_cache_5=throughput_cache_2(df_sensor_H[:, :, 250])
sensor_power_cache_6=throughput_cache_2(df_sensor_H[:, :, 300])
sensor_power_cache_7=throughput_cache_2(df_sensor_H[:, :, 350])
sensor_power_cache_8=throughput_cache_2(df_sensor_H[:, :, 400])
sensor_power_cache_9=throughput_cache_2(df_sensor_H[:, :, 450])
sensor_power_cache_10=throughput_cache_2(df_sensor_H[:, :, 500])
xpoints_H = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_H = [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,ensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_H,ypoints_H, 'g-o')
df_sensor_power = power_cache[:,:,:]
df_sensor_M = df_sensor_power.loc[df_sensor_power[:] ==-10]
sensor_power_cache_1=throughput_cache(df_sensor_H[:, :, 50])
sensor_power_cache_2=throughput_cache(df_sensor_H[:, :, 100])
sensor_power_cache_3=throughput_cache(df_sensor_H[:, :, 150])
sensor_power_cache_4=throughput_cache(df_sensor_H[:, :, 200])
sensor_power_cache_5=throughput_cache(df_sensor_H[:, :, 250])
sensor_power_cache_6=throughput_cache(df_sensor_H[:, :, 300])
sensor_power_cache_7=throughput_cache(df_sensor_H[:, :, 350])
sensor_power_cache_8=throughput_cache(df_sensor_H[:, :, 400])
sensor_power_cache_9=throughput_cache(df_sensor_H[:, :, 450])
sensor_power_cache_10=throughput_cache(df_sensor_H[:, :, 500])
xpoints_H = [50, 100, 150,  200, 250, 300, 350, 400, 450, 500]
ypoints_H = [sensor_power_cache_1,sensor_power_cache_2 ,sensor_power_cache_3 ,sensor_power_cache_4 ,sensor_power_cache_5 ,sensor_power_cache_6 ,sensor_power_cache_7 ,sensor_power_cache_8 ,ensor_power_cache_9 ,sensor_power_cache_10]
plt.plot(xpoints_H,ypoints_H, 'K-o')
plt.yticks([0,0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([50, 100, 150,  200, 250, 300, 350, 400, 450, 500])
plt.xlabel('Nodes')
plt.ylabel('Packet Reception Ratio')
plt.title("Packet Reception Ratio By Power")
plt.legend(['QEAR + EOCC Power=-10dBm', 'EOCC - Power=-10dBm'], loc='upper right')
plt.grid(True)

"""#**Tier 2**

#**Rayleigh Fading Channel**

کانال‌های محو ریلی مدل‌های مفیدی از پدیده‌های دنیای واقعی در ارتباطات بی‌سیم هستند. این پدیده ها شامل اثرات پراکندگی چند مسیری، پراکندگی زمانی و جابجایی های داپلر است که از حرکت نسبی بین فرستنده و گیرنده ناشی می شود.
 شکل زیر منعکس شده مستقیم و اصلی بین یک فرستنده رادیویی ثابت و یک گیرنده متحرک را نشان می دهد. اشکال سایه دار بازتاب دهنده هایی مانند ساختمان ها هستند.

#**NOMA - Rayleigh Flat Fading Channel**

##**Random Walk**
"""

!pip install pyrandwalk



"""#**Random Walk**"""

!pip install pyrandwalk

!pip install sdeint

def db2pow(xdb):
    """Convert decibels (dB) to power

    .. doctest::

        >>> from spectrum import db2pow
        >>> p = db2pow(-10)
        >>> p
        0.1

    .. seealso:: :func:`pow2db`
    """
    return 10.**(xdb/10.)

"""#**Q Learning Rayleigh Flat Fading Quasi Static - NOMA**"""

import numpy as np
from time import sleep
from datetime import datetime
import time
from random import randrange
import random
import multiprocessing
training_qlearn()
import matplotlib.pyplot as plt
import numpy as np
import math
from pyrandwalk import *
from scipy.spatial import distance
v_mph = 60 # velocity
center_freq = 200e6 # RF carrier frequency in Hz
Fs = 1e5 # sample rate of simulation
N = 100# number of patients 100
K=13 #Access Points=13
transmit_cnt=10000
totPower=1 #%Total power of LOS path & scattered paths
Ps=1
AAS_thereshold=0.000002
v = v_mph * 0.44704 # convert to m/s
fd = v*center_freq/3e8 # max
#print("max Doppler shift:", fd)
t = np.arange(0, 1, 1/Fs) # time vector. (start, stop, step)
x = np.zeros(len(t))
y = np.zeros(len(t))
EbN0dB = [0, 10, 40]
count_num=transmit_cnt
patient_num=N
aps = K
energy_cache = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
packet_cache = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
throughput_cache = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
time_cache = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
elapsed_cache = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
patients_priority_cache = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
sensors_dead_cache = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
power_cache = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
velocity_cache = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
shortest_path = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
r_hat=0.5
states = [0, 1, 2, 3, 4]
transition = np.array([[1,    0, 0,    0, 0],
                   [0.25, 0, 0.75, 0, 0],
                   [0, 0.25, 0, 0.75, 0],
                   [0, 0, 0.25, 0, 0.75],
                   [0, 0,    0, 1,    0]])
E = 100
Erx_elec = 36.1*0.000000001
Etx_elec = 16.7*0.000000001
Eamp = 1.97*0.000000001
k=8
elapsed_hub=1

time_now = datetime.now()
elapsed = 0
sleep=0.005
from scipy import special as sp
def q_func(x):
  return 0.5-0.5*sp.erf(x/np.sqrt(2))
#RandomWalk
rw = RandomWalk(states, transition)
states, probs = rw.run()
rw_v = max(probs)
for i in range(transmit_cnt):
  for j in range(N):
    for ap in range(K):
      #1. compute fading channel coefficient related to the symbol transmission from Hi is represented by LHi
      Ml=40 #db
      L1=30 #reference distance= 1m =30 db
      N0=1.2 #power
      euclidean_distance__ha = 0 # Euclidean Distance between hub and access points
      n_power=4
      #2. compute Rayleigh distributed with probability density function (pdf)
      phi=np.pi/2
      theta = np.linspace(-np.pi, np.pi, 6000)
      ohm = (1/(2*np.pi))* np.exp(- j) * (1 + (np.sqrt(4*np.pi*j) \
            * np.exp(j * (np.cos(theta-phi))**2) *np.cos(theta-phi)) \
            * (1 - q_func(np.sqrt(2*j) * np.cos(theta-phi))))

      ohm=ohm**2
      r = np.linspace(0, 6, 6000)
      LHc = ((2*r)/ohm)*np.exp(-r**2/ohm)
      # 3. compute path loss between hub_i and access_points_j  محاسبه مسیر های از دست رفته بین هاب و آنتن ها
      # 4. LHc -> Rayleigh distributed with probability density function (pdf)  محاسبه تابع احتمال چگالی توزیع رایلی
      alpha = (np.random.rand() - 0.5) * 2 * np.pi
      phi =   (np.random.rand() - 0.5) * 2 * np.pi
      p=phi
      x = x + np.random.randn() * np.cos(2 * np.pi * fd * t * np.cos(alpha) + phi)
      y = y + np.random.randn() * np.sin(2 * np.pi * fd * t * np.cos(alpha) + phi)
      xx=int(abs(sum(x)))
      num_str_x = str(xx)
      x_digit = num_str_x[0]
      phi=int(x_digit)
      yy=int(abs(sum(y)))
      num_str_y = str(yy)
      y_digit = num_str_y[0]
      Ghq=int(y_digit)
      # 5. Compute Euclidean Distance between hub and access points  محاسبه فاصله اقلیدسی بین هاب و آنتن ها
      euclidean_distance__ha = distance.euclidean(x, y)

      # 6. Noise samples (AWGN) with zero mean and unit variance
      noise = (np.random.randn(1,20)+np.random.randn(1,20))/math.sqrt(2) #AWGN with unity power
      Phq=int(y_digit)
      L_d=Ml*(euclidean_distance__ha**n_power)*L1
      GHi=sum(LHc/np.sqrt(L_d))

      #7. Compute SINR = Signal-to-Interference plus Noise Ratio (SINR) محاسبه سیگنالهای تداخلی بعلاوه نرخ نویزها با مجذور خی
      #8. Chi-square distributed γ with 2 degrees of freedom and with the pdf
      Ghq = rw_v**2
      SINR = (GHi**2)*int(x_digit)/ N0+Ghq**2*Phq
      SNR = (ohm/L_d) * (phi/N0)

      # 9. Compute Edge Server Adaptive Access Point Selection
      Tem=1
      Eh = (Erx_elec+Eamp)*euclidean_distance__ha**n_power*L1
      if max(SNR)<SINR:
        AAS = (SINR*Tem)/(Eh*phi)
        Bhi=(Tem/Phq)
        # 10. Received Signal at Access Point
        if AAS>AAS_thereshold:
          Xsignal_receiver=(GHi*Bhi*Ps)*int(x_digit)+noise
          Rayleigh_Flat_Fading=[]
          for sig in Xsignal_receiver:
            Rayleigh_Flat_Fading.append(sig)
          Rayleigh_Flat_Fading = sum(Rayleigh_Flat_Fading)
          Rayleigh_Flat_Fading=int(abs(sum(Rayleigh_Flat_Fading)))
          Rayleigh_Flat_Fading = str(Rayleigh_Flat_Fading)
          Rayleigh_Flat_Fading = Rayleigh_Flat_Fading[0]
          d=math.sqrt(((int(Rayleigh_Flat_Fading))**2)+((int(y_digit))**2))
          Ekd    = Erx_elec*k* d**2 +  Etx_elec*k + Eamp *k *d**2
          Ekd    = round(Ekd, 10)
          time.sleep(sleep) #sleeps for x seconds
          status='sleeping...'
          if status=='sleeping...':
            elapsed_timecache =   elapsed_hub*(sleep*10**6)-2
          else:
            # 11. Computing while sensor is not in resting or sleeping mode
            energy_cache[i, j, ap] = energy_cache[j - 1, i]  - Ekd #K - N
            time_cache[i, j, ap] = (time_now.minute*60+time_now.second)+elapsed_timecache
            packet_cache[i, j, ap] = packet_cache[j, i] + 1 #K - N
            shortest_path[i, j, ap]=get_shortest_path_NOMA(int(Rayleigh_Flat_Fading), int(y_digit))
            velocity_cache[i, j, ap] = int(shortest_path[i, j, ap])/int(time_cache[i, j, ap])
            throughput_cache[i, j, ap]=throughput_cache[j-1, i]+packet_cache[j, i]

"""#**Episodes - Learning Rate**"""

import matplotlib.pyplot as plt
sensor_rewards_1 =rewards[0:1000, :, :].mean()
sensor_rewards_2 =rewards[0:2000, :, :].mean()
sensor_rewards_3 =rewards[0:3000, :, :].mean()
sensor_rewards_4 =rewards[0:4000, :, :].mean()
sensor_rewards_5 =rewards[0:5000, :, :].mean()
sensor_rewards_6 =rewards[0:6000, :, :].mean()
sensor_rewards_7 =rewards[0:7000, :, :].mean()
sensor_rewards_8 =rewards[0:8000, :, :].mean()
sensor_rewards_9 =rewards[0:9000, :, :].mean()
sensor_rewards_10=rewards[0:10000, :, :].mean()
sensor_rewards_12=rewards[0:12000, :, :].mean()
sensor_rewards_14=rewards[0:14000, :, :].mean()
sensor_rewards_16=rewards[0:16000, :, :].mean()
xpoints_eeg = [0, 0 ,0, 0, 1,5 ,20, 30 ,300,500, 800,  1000,1500 ,2000,2500,3000,  4000,  6000, 8000, 10000, 12000, 14000, 16000]
ypoints_episode =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10,sensor_temp_cache_12,sensor_temp_cache_14,sensor_temp_cache_16]
plt.plot(xpoints_eeg, ypoints_eeg,  lw=1, marker='_', color='g', ms=4)
xpoints_eeg = [0, 0 ,0, 0, 1,5 ,20, 30 ,300,500, 800,  1000,1500 ,2000,2500,3000,  4000,  6000, 8000, 10000, 12000, 14000, 16000]
ypoints_episode =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10,sensor_temp_cache_12,sensor_temp_cache_14,sensor_temp_cache_16]
plt.plot(xpoints_eeg, ypoints_eeg,  lw=1, marker='_', color='m', ms=4)
xpoints_eeg = [0, 0 ,0, 0, 1,5 ,20, 30 ,300,500, 800,  1000,1500 ,2000,2500,3000,  4000,  6000, 8000, 10000, 12000, 14000, 16000]
ypoints_episode =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10,sensor_temp_cache_12,sensor_temp_cache_14,sensor_temp_cache_16]
plt.plot(xpoints_eeg, ypoints_eeg,  lw=1, marker='_', color='k', ms=4)
xpoints_eeg = [0, 0 ,0, 0, 1,5 ,20, 30 ,300,500, 800,  1000,1500 ,2000,2500,3000,  4000,  6000, 8000, 10000, 12000, 14000, 16000]
ypoints_episode =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10,sensor_temp_cache_12,sensor_temp_cache_14,sensor_temp_cache_16]
plt.plot(xpoints_eeg, ypoints_eeg,  lw=1, marker='_', color='r', ms=4)
plt.yticks([0,10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
plt.xticks([0, 2000, 4000,  6000, 8000, 10000, 12000, 14000, 16000])
plt.xlabel('Episode')
plt.ylabel('Average Reward')
plt.legend(['lr=.01', 'lr=.001', 'lr=.0001', 'lr=.00001'])
plt.show()

"""#**Cumulative Rewards**"""

import matplotlib.pyplot as plt
from random import randrange
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
import math
fig = plt.figure()
ax = fig.add_subplot(1,1,1)
ypoints_eeg2=[]
for i in range(10000):
    ypoints_eeg2.append(randrange(10000))
sensor_rewards_1 =rewards[0:1000, :, :].mean()
sensor_rewards_2 =rewards[0:2000, :, :].mean()
sensor_rewards_3 =rewards[0:3000, :, :].mean()
sensor_rewards_4 =rewards[0:4000, :, :].mean()
sensor_rewards_5 =rewards[0:5000, :, :].mean()
sensor_rewards_6 =rewards[0:6000, :, :].mean()
sensor_rewards_7 =rewards[0:7000, :, :].mean()
sensor_rewards_8 =rewards[0:8000, :, :].mean()
sensor_rewards_9 =rewards[0:9000, :, :].mean()
sensor_rewards_10=rewards[0:10000, :, :].mean()
sensor_rewards_12=rewards[0:12000, :, :].mean()
sensor_rewards_14=rewards[0:14000, :, :].mean()
sensor_rewards_16=rewards[0:16000, :, :].mean()
x = [0, 0 ,0, 0, 1,5 ,20, 30 ,300,500, 800,  1000,1500 ,2000,2500,3000,  4000,  6000, 8000, 10000, 12000, 14000, 16000]
y =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10,sensor_temp_cache_12,sensor_temp_cache_14,sensor_temp_cache_16]
ax.plot(x,y,  lw=1, marker='o', color='r', ms=4) # square # this is the main plot
plt.xlabel('Number of iterations')
plt.ylabel('Cumulative Reward')
#this is the small figure
ins_ax = inset_axes(ax, width=1.5, height=1.5,
          bbox_transform=ax.transAxes, bbox_to_anchor=(0.75,0.75),)

# the small plot just by slicing the original data
ins_ax.plot(x[0:300],  lw=1, marker='o', color='r', ms=4)
plt.show()
plt.yticks([0,10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
plt.xticks([0, 2000, 4000,  6000, 8000, 10000, 12000, 14000, 16000])
plt.xlabel('Number of iterations')
plt.ylabel('Average Reward')
plt.show()

"""#**MPDS - Rayleigh Flat Fading Quasi Static - NOMA**"""

import numpy as np
from time import sleep
from datetime import datetime
import time
from random import randrange
import random
import multiprocessing
import matplotlib.pyplot as plt
import numpy as np
import math
import math
from pyrandwalk import *
from scipy.spatial import distance
v_mph = 60 # velocity
center_freq = 200e6 # RF carrier frequency in Hz
Fs = 1e5 # sample rate of simulation
N = 100# number of patients 100
K=13 #Access Points=13
transmit_cnt=10000
totPower=1 #%Total power of LOS path & scattered paths
Ps=1
AAS_thereshold=0.000002
v = v_mph * 0.44704 # convert to m/s
fd = v*center_freq/3e8 # max
#print("max Doppler shift:", fd)
t = np.arange(0, 1, 1/Fs) # time vector. (start, stop, step)
x = np.zeros(len(t))
y = np.zeros(len(t))
EbN0dB = [0, 10, 40]
count_num=transmit_cnt
patient_num=N
aps = K
energy_cache_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
packet_cache_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
throughput_cache_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
time_cache_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
elapsed_cache_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
patients_priority_cache_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
sensors_dead_cache_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
power_cache_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
velocity_cache_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
shortest_path_2 = np.zeros((count_num, patient_num, aps),  dtype=object) #Count - Patient - Sensor
r_hat=0.5
states = [0, 1, 2, 3, 4]
transition = np.array([[1,    0, 0,    0, 0],
                   [0.25, 0, 0.75, 0, 0],
                   [0, 0.25, 0, 0.75, 0],
                   [0, 0, 0.25, 0, 0.75],
                   [0, 0,    0, 1,    0]])
E = 2
Erx_elec = 50*0.000000001
Etx_elec = 16.7*0.000000001
Eamp = 0.1*0.000000001
Rs=2
Rh=230
dist=math.sqrt(Rh-Rs)**2
k=8
elapsed_hub=1
time_now = datetime.now()
elapsed = 0
sleep=0.005
from scipy import special as sp
def q_func(x):
  return 0.5-0.5*sp.erf(x/np.sqrt(2))
#RandomWalk
rw = RandomWalk(states, transition)
states, probs = rw.run()
rw_v = max(probs)
for i in range(transmit_cnt):
  for j in range(N):
    for ap in range(K):
      #1. compute fading channel coefficient related to the symbol transmission from Hi is represented by LHi
      Ml=40 #db
      L1=30 #reference distance= 1m =30 db
      N0=1.2 #power
      euclidean_distance__ha = 0 # Euclidean Distance between hub and access points
      n_power=4
      #2. compute Rayleigh distributed with probability density function (pdf)
      phi=np.pi/2
      theta = np.linspace(-np.pi, np.pi, 6000)
      ohm = (1/(2*np.pi))* np.exp(- j) * (1 + (np.sqrt(4*np.pi*j) \
            * np.exp(j * (np.cos(theta-phi))**2) *np.cos(theta-phi)) \
            * (1 - q_func(np.sqrt(2*j) * np.cos(theta-phi))))

      ohm=ohm**2
      r = np.linspace(0, 6, 6000)
      LHc = ((2*r)/ohm)*np.exp(-r**2/ohm)
      # 3. compute path loss between hub_i and access_points_j  محاسبه مسیر های از دست رفته بین هاب و آنتن ها
      # 4. LHc -> Rayleigh distributed with probability density function (pdf)  محاسبه تابع احتمال چگالی توزیع رایلی
      alpha = (np.random.rand() - 0.5) * 2 * np.pi
      phi =   (np.random.rand() - 0.5) * 2 * np.pi
      p=phi
      x = x + np.random.randn() * np.cos(2 * np.pi * fd * t * np.cos(alpha) + phi)
      y = y + np.random.randn() * np.sin(2 * np.pi * fd * t * np.cos(alpha) + phi)
      xx=int(abs(sum(x)))
      num_str_x = str(xx)
      x_digit = num_str_x[0]
      phi=int(x_digit)
      yy=int(abs(sum(y)))
      num_str_y = str(yy)
      y_digit = num_str_y[0]
      Ghq=int(y_digit)
      # 5. Compute Euclidean Distance between hub and access points  محاسبه فاصله اقلیدسی بین هاب و آنتن ها
      euclidean_distance__ha = distance.euclidean(x, y)

      # 6. Noise samples (AWGN) with zero mean and unit variance
      noise = (np.random.randn(1,20)+np.random.randn(1,20))/math.sqrt(2) #AWGN with unity power
      Phq=int(y_digit)
      L_d=Ml*(euclidean_distance__ha**n_power)*L1
      GHi=sum(LHc/np.sqrt(L_d))

      #7. Compute SINR = Signal-to-Interference plus Noise Ratio (SINR) محاسبه سیگنالهای تداخلی بعلاوه نرخ نویزها با مجذور خی
      #8. Chi-square distributed γ with 2 degrees of freedom and with the pdf
      Ghq = rw_v**2
      SINR = (GHi**2)*int(x_digit)/ N0+Ghq**2*Phq
      SNR = (ohm/L_d) * (phi/N0)

      # 9. Compute Edge Server Adaptive Access Point Selection
      Tem=1
      Eh = (Erx_elec+Eamp)*euclidean_distance__ha**n_power*L1
      if max(SNR)<SINR:
        AAS = (SINR*Tem)/(Eh*phi)
        Bhi=(Tem/Phq)
        # 10. Received Signal at Access Point
        if AAS>AAS_thereshold:
          Xsignal_receiver=(GHi*Bhi*Ps)*int(x_digit)+noise
          Rayleigh_Flat_Fading=[]
          for sig in Xsignal_receiver:
            Rayleigh_Flat_Fading.append(sig)
          Rayleigh_Flat_Fading = sum(Rayleigh_Flat_Fading)
          Rayleigh_Flat_Fading=int(abs(sum(Rayleigh_Flat_Fading)))
          Rayleigh_Flat_Fading = str(Rayleigh_Flat_Fading)
          Rayleigh_Flat_Fading = Rayleigh_Flat_Fading[0]
          d=math.sqrt(((int(Rayleigh_Flat_Fading))**2)+((int(y_digit))**2))
          Ekd    = Erx_elec*k* d**2 +  Etx_elec*k + Eamp *k *d**2
          Ekd    = round(Ekd, 10)
          time.sleep(sleep) #sleeps for x seconds
          status='sleeping...'
          if status=='sleeping...':
            elapsed_timecache =   elapsed_hub*(sleep*10**6)-2
          else:
            # 11. Computing while sensor is not in resting or sleeping mode
            energy_cache[i, j, ap] = energy_cache[j - 1, i]  - Ekd #K - N
            time_cache[i, j, ap] = (time_now.minute*60+time_now.second)+elapsed_timecache
            packet_cache[i, j, ap] = packet_cache[j, i] + 1 #K - N
            shortest_path[i, j, ap]=math.sqrt(int(Rayleigh_Flat_Fading)- int(y_digit))**2 +dist
            velocity_cache[i, j, ap] = int(shortest_path[i, j, ap])/int(time_cache[i, j, ap])
            throughput_cache[i, j, ap]=throughput_cache[j-1, i]+packet_cache[j, i]

"""#**MPDS - Average Delay - Number of Patients - NOMA - Rayleigh**

#**Average Delay - Number of Patients - NOMA - Rayleigh**
"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_time_cache_1 =time_cache[:,10,:].mean()
sensor_time_cache_2 =time_cache[:,20,:].mean()
sensor_time_cache_3 =time_cache[:,30,:].mean()
sensor_time_cache_4 =time_cache[:,40,:].mean()
sensor_time_cache_5 =time_cache[:,50,:].mean()
sensor_time_cache_6 =time_cache[:,60,:].mean()
sensor_time_cache_7 =time_cache[:,70,:].mean()
sensor_time_cache_8 =time_cache[:,80,:].mean()
sensor_time_cache_9 =time_cache[:,90,:].mean()
sensor_time_cache_10=time_cache[:,100,:].mean()
xpoints_endtoend=[10, 20, 30,  40, 50, 60, 70, 80, 90, 100]
ypoints_endtoend = [sensor_time_cache_1 ,sensor_time_cache_2 ,sensor_time_cache_3 ,sensor_time_cache_4 ,sensor_time_cache_5 ,sensor_time_cache_6 ,sensor_time_cache_7 ,sensor_time_cache_8 ,sensor_time_cache_9 ,sensor_time_cache_10]
plt.plot(xpoints_endtoend,ypoints_endtoend, label = 'NOMA-based Q-EAR+EOCC',color='magenta', lw=2,markerfacecolor='magenta',marker='D', ms=7) # circle
sensor_time_cache_1 =time_cache_2[:,10,:].mean()
sensor_time_cache_2 =time_cache_2[:,20,:].mean()
sensor_time_cache_3 =time_cache_2[:,30,:].mean()
sensor_time_cache_4 =time_cache_2[:,40,:].mean()
sensor_time_cache_5 =time_cache_2[:,50,:].mean()
sensor_time_cache_6 =time_cache_2[:,60,:].mean()
sensor_time_cache_7 =time_cache_2[:,70,:].mean()
sensor_time_cache_8 =time_cache_2[:,80,:].mean()
sensor_time_cache_9 =time_cache_2[:,90,:].mean()
sensor_time_cache_10=time_cache_2[:,100,:].mean()
xpoints_endtoend=[10, 20, 30,  40, 50, 60, 70, 80, 90, 100]
ypoints_endtoend = [sensor_time_cache_1 ,sensor_time_cache_2 ,sensor_time_cache_3 ,sensor_time_cache_4 ,sensor_time_cache_5 ,sensor_time_cache_6 ,sensor_time_cache_7 ,sensor_time_cache_8 ,sensor_time_cache_9 ,sensor_time_cache_10]
plt.plot(xpoints_endtoend,ypoints_endtoend, label = 'WH with NOMA-based MPDS',color='green', lw=2,markerfacecolor='green',marker='o', ms=7) # circle
plt.yticks([0,10, 20, 30,  40, 50, 60, 70, 80])
plt.xticks([10, 20, 30,  40, 50, 60, 70, 80, 90, 100])
plt.xlabel('Number of Patients')
plt.ylabel('Average Delay (sec)')
plt.grid(True)
plt.title('The amount of latency Rayleigh flat fading channel')
plt.legend()
plt.show()

"""#**Average Delay (sec) - Number of Access Points- NOMA - Rayleigh**

#**MPDS - Average Delay (sec) - Number of Access Points- NOMA - Rayleigh**
"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_time_cache_1 =time_cache[:,:,9].mean()
sensor_time_cache_2 =time_cache[:,:,10].mean()
sensor_time_cache_3 =time_cache[:,:,11].mean()
sensor_time_cache_4 =time_cache[:,:,12].mean()
sensor_time_cache_5 =time_cache[:,:,13].mean()
xpoints = [9, 10, 11, 12, 13]
ypoints = [sensor_time_cache_1, sensor_time_cache_2, sensor_time_cache_3, sensor_time_cache_4, sensor_time_cache_5]
plt.plot(xpoints,ypoints, label = 'NOMA-based MPDS Q-EAR',color='magenta', lw=2,markerfacecolor='magenta',marker='D', ms=7) # circle
sensor_time_cache_1 =time_cache_2[:,:,9].mean()
sensor_time_cache_2 =time_cache_2[:,:,10].mean()
sensor_time_cache_3 =time_cache_2[:,:,11].mean()
sensor_time_cache_4 =time_cache_2[:,:,12].mean()
sensor_time_cache_5 =time_cache_2[:,:,13].mean()
xpoints = [9, 10, 11, 12, 13]
ypoints = [sensor_time_cache_1, sensor_time_cache_2, sensor_time_cache_3, sensor_time_cache_4, sensor_time_cache_5]
plt.plot(xpoints,ypoints, label = 'WH with NOMA-based MPDS',color='green', lw=2,markerfacecolor='green',marker='o', ms=7) # circle
plt.yticks([15, 20, 25, 30, 35, 40, 45, 50, 55])
plt.xticks([9, 10, 11, 12, 13])
plt.xlabel('Number of APs')
plt.ylabel('Average Delay (sec)')
plt.grid(True)
plt.title('The amount of latency Rayleigh flat fading channel')
plt.legend()
plt.show()
plt.close()

"""#**MPDS - Effective Thrughput(bps) - Number of Patients - NOMA - Rayleigh**"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_throughput_1 =  throughput_cache[:, 10,:].mean()
sensor_throughput_2 =  throughput_cache[:, 25,:].mean()
sensor_throughput_3 =  throughput_cache[:, 50,:].mean()
sensor_throughput_4 =  throughput_cache[:, 75,:].mean()
sensor_throughput_5 =  throughput_cache[:, 100,:].mean()
xpoints = [10, 25, 50, 75, 100]
ypoints = [sensor_throughput_1 ,sensor_throughput_2 ,sensor_throughput_3 ,sensor_throughput_4 ,sensor_throughput_5 ]
plt.plot(xpoints,ypoints, label = 'NOMA-based Q-EAR',color='magenta', lw=2,markerfacecolor='magenta',marker='D', ms=7) # circle
sensor_throughput_1 =  throughput_cache_2[:, 10,:].mean()
sensor_throughput_2 =  throughput_cache_2[:, 25,:].mean()
sensor_throughput_3 =  throughput_cache_2[:, 50,:].mean()
sensor_throughput_4 =  throughput_cache_2[:, 75,:].mean()
sensor_throughput_5 =  throughput_cache_2[:, 100,:].mean()
xpoints = [10, 25, 50, 75, 100]
ypoints = [sensor_throughput_1 ,sensor_throughput_2 ,sensor_throughput_3 ,sensor_throughput_4 ,sensor_throughput_5 ]
plt.plot(xpoints,ypoints, label = 'WH with NOMA-based MPDS',color='green', lw=2,markerfacecolor='green',marker='o', ms=7) # circle
plt.yticks([18, 20, 22, 24, 26, 28, 30])
plt.xticks([10, 25, 50, 75, 100])
plt.xlabel('Number of Patients')
plt.ylabel('Effective Thrughput(bps)')
plt.grid(True)
plt.title('The amount of latency Rayleigh flat fading channel')
plt.legend(loc='upper right')
plt.show()

"""#**Effective Thrughput(bps) - Number of Access Points- NOMA - Rayleigh**"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_throughput_2 =  throughput_cache[:,:,10].mean()
sensor_throughput_3 =  throughput_cache[:,:,11].mean()
sensor_throughput_4 =  throughput_cache[:,:,12].mean()
sensor_throughput_5 =  throughput_cache[:,:,13].mean()
xpoints_eeg_4 = [9, 10, 11, 12, 13]
ypoints_eeg_4 = [sensor_throughput_1, sensor_throughput_2, sensor_throughput_3, sensor_throughput_4, sensor_throughput_5]
plt.plot(xpoints_eeg_4,ypoints_eeg_4, label = 'NOMA-based MPDS Q-EAR',color='magenta', lw=2,markerfacecolor='magenta',marker='D', ms=7) # circle
sensor_throughput_2 =  throughput_cache_2[:,:,10].mean()
sensor_throughput_3 =  throughput_cache_2[:,:,11].mean()
sensor_throughput_4 =  throughput_cache_2[:,:,12].mean()
sensor_throughput_5 =  throughput_cache_2[:,:,13].mean()
xpoints_eeg_4 = [9, 10, 11, 12, 13]
ypoints_eeg_4 = [sensor_throughput_1, sensor_throughput_2, sensor_throughput_3, sensor_throughput_4, sensor_throughput_5]
xpoints_eeg_1 = [9, 10, 11, 12, 13]
ypoints_eeg_1 = [24, 26, 27, 29, 31]
plt.plot(xpoints_eeg_1,ypoints_eeg_1, label = 'WH with NOMA-based MPDS',color='green', lw=2,markerfacecolor='green',marker='o', ms=7) # circle
plt.yticks([ 20, 25, 30, 35])
plt.xticks([9, 10, 11, 12, 13])
plt.xlabel('Number of APs')
plt.ylabel('Effective Thrughput(bps)')
plt.grid(True)
plt.title('The amount of latency Rayleigh flat fading channel')
plt.legend(loc='lower left')
plt.show()

"""#**Average Energy Consumption (J) - Number of Patients- NOMA - Rayleigh**"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_energy_1 = energy_cache[:, 10, :].mean()
sensor_energy_2 = energy_cache[:, 25, :].mean()
sensor_energy_3 = energy_cache[:, 50, :].mean()
sensor_energy_4 = energy_cache[:, 75, :].mean()
sensor_energy_5 = energy_cache[:, 100,:].mean()
xpoints_eeg_4 = [10, 25, 50, 75, 100]
ypoints_eeg_4 = [sensor_time_cache_1, sensor_time_cache_2, sensor_time_cache_3, sensor_time_cache_4, sensor_time_cache_5]
plt.plot(xpoints_eeg_4,ypoints_eeg_4, label = 'NOMA-based MPDS Q-EAR',color='magenta', lw=2,markerfacecolor='magenta',marker='D', ms=7) # circle
sensor_energy_1 = energy_cache_2[:, 10, :].mean()
sensor_energy_2 = energy_cache_2[:, 25, :].mean()
sensor_energy_3 = energy_cache_2[:, 50, :].mean()
sensor_energy_4 = energy_cache_2[:, 75, :].mean()
sensor_energy_5 = energy_cache_2[:, 100,:].mean()
xpoints_eeg_4 = [10, 25, 50, 75, 100]
ypoints_eeg_4 = [sensor_time_cache_1, sensor_time_cache_2, sensor_time_cache_3, sensor_time_cache_4, sensor_time_cache_5]
plt.plot(xpoints_eeg_4,ypoints_eeg_4, label = 'WH with NOMA-based MPDS',color='green', lw=2,markerfacecolor='green',marker='o', ms=7) # circle
plt.yticks([0, 10, 20, 30, 40, 50,60, 70, 80])
plt.xticks([10, 25, 50, 75, 100])
plt.xlabel('Number of Patients')
plt.ylabel('Average Energy Consumption (J)')
plt.grid(True)
plt.title('The amount of latency Rayleigh flat fading channel')
plt.legend(loc='upper left')
plt.show()

"""#**Average Energy Consumption (J)  - Number of Access Points- NOMA - Rayleigh**"""

import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 100)
sensor_energy_1 = energy_cache[:,:,9].mean()
sensor_energy_2 = energy_cache[:,:,10].mean()
sensor_energy_3 = energy_cache[:,:,11].mean()
sensor_energy_4 = energy_cache[:,:,12].mean()
sensor_energy_5 = energy_cache[:,:,13].mean()
xpoints_eeg_4 = [9, 10, 11, 12, 13]
ypoints_eeg_4 = [sensor_energy_1, sensor_energy_2,sensor_energy_3,sensor_energy_4,sensor_energy_5]
plt.plot(xpoints_eeg_4,ypoints_eeg_4, label = 'NOMA-based MPDS Q-EAR',color='magenta', lw=2,markerfacecolor='magenta',marker='D', ms=7) # circle
sensor_energy_1 = energy_cache_2[:,:,9].mean()
sensor_energy_2 = energy_cache_2[:,:,10].mean()
sensor_energy_3 = energy_cache_2[:,:,11].mean()
sensor_energy_4 = energy_cache_2[:,:,12].mean()
sensor_energy_5 = energy_cache_2[:,:,13].mean()
xpoints_eeg_4 = [9, 10, 11, 12, 13]
ypoints_eeg_4 = [sensor_energy_1, sensor_energy_2,sensor_energy_3,sensor_energy_4,sensor_energy_5]
plt.plot(xpoints_eeg_1,ypoints_eeg_1, label = 'WH with NOMA-based MPDS',color='green', lw=2,markerfacecolor='green',marker='o', ms=7) # circle
plt.yticks([0, 10, 20, 30, 40, 50,60, 70, 80])
plt.xticks([9, 10, 11, 12, 13])
plt.xlabel('Number of APs')
plt.ylabel('Average Energy Consumption (J)')
plt.grid(True)
plt.title('The amount of latency Rayleigh flat fading channel')
plt.legend(loc='center left')
plt.show()

"""#**Velocity (m/s)  - Average Delay (sec) - Q-EAR vs WH with NOMA based MPDS**"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
i, j, ap =np.where(velocity_cache==0)
value1=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==2)
value2=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==4)
value3=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==6)
value4=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==8)
value5=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==10)
value6=time_cache[i, j, ap]
data = {'0':value1, '2':value2, '4':value3, '6':value4, '8':value5, '10':value6}
velocity = list(data.keys())
values = list(data.values())
figure(figsize = (5, 4), dpi = 100)
data2 = {'0':23, '2':5, '4':5, '6':4.5, '8':4, '10':3}
velocity2 = list(data2.keys())
values2 = list(data2.values())
velocity = ['0','2','4','6','8','10']
X_axis = np.arange(len(velocity))
figure(figsize = (5, 4), dpi = 100)
# creating the bar plot
plt.bar(X_axis - 0.2, values, color ='gray', width = 0.3, label = 'Q-EAR')
i, j, ap =np.where(velocity_cache==0)
value1=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==2)
value2=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==4)
value3=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==6)
value4=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==8)
value5=time_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==10)
value6=time_cache[i, j, ap]
data = {'0':value1, '2':value2, '4':value3, '6':value4, '8':value5, '10':value6}
velocity = list(data.keys())
values = list(data.values())
plt.bar(X_axis + 0.2, values2, color ='black', width = 0.3, label = 'WH with NOMA based MPDS')
plt.yticks([0, 5, 10, 15, 20, 25, 30])
plt.xticks(X_axis, velocity)
plt.grid(True)
plt.legend(loc='upper right')
plt.xlabel("Velocity (m/s)")
plt.ylabel("Average Delay (sec)")
plt.title("Rayleigh Flat Fading NOMA MPDS")
plt.show()
plt.close()

"""#**Velocity (m/s)  - Effective Thrughput(bps) - Q-EAR vs WH with NOMA based MPDS**"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
i, j, ap =np.where(velocity_cache==0)
value1=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==2)
value2=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==4)
value3=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==6)
value4=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==8)
value5=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==10)
value6=throughput_cache[i, j, ap]
velocity = ['0','2','4','6','8','10']
X_axis = np.arange(len(velocity))
plt.bar(X_axis - 0.2, values, color ='gray', width = 0.3, label = 'Q-EAR')
velocity = list(data.keys())
values = list(data.values())
figure(figsize = (5, 4), dpi = 100)
# creating the bar plot
plt.bar(X_axis + 0.2, values2, color ='black', width = 0.3, label = 'WH with NOMA based MPDS')
i, j, ap =np.where(velocity_cache==0)
value1=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==2)
value2=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==4)
value3=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==6)
value4=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==8)
value5=throughput_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==10)
value6=throughput_cache[i, j, ap]
data = {'0':value1, '2':value2, '4':value3, '6':value4, '8':value5, '10':value6}
velocity = list(data.keys())
values = list(data.values())
velocity = ['0','2','4','6','8','10']
plt.yticks([0, 5, 10, 15, 20, 25, 30])
plt.xticks(X_axis, velocity)
plt.grid(True)
plt.legend(loc='upper right')
plt.xlabel("Velocity (m/s)")
plt.ylabel('Effective Thrughput(bps)')
plt.title("Velocity Rayleigh Flat Fading NOMA MPDS")
plt.show()
plt.close()

"""#**Velocity (m/s)  - Average Energy Consumption (J) - Q-EAR vs WH with NOMA based MPDS**"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
i, j, ap =np.where(velocity_cache==0)
value1=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==2)
value2=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==4)
value3=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==6)
value4=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==8)
value5=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==10)
value6=energy_cache[i, j, ap]
data = {'0':value1, '2':value2, '4':value3, '6':value4, '8':value5, '10':value6}
velocity = list(data.keys())
values = list(data.values())
plt.bar(X_axis - 0.2, values, color ='gray', width = 0.3, label = 'Q-EAR')
i, j, ap =np.where(velocity_cache==0)
value1=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==2)
value2=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==4)
value3=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==6)
value4=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==8)
value5=energy_cache[i, j, ap]
i, j, ap =np.where(velocity_cache==10)
value6=energy_cache[i, j, ap]
figure(figsize = (5, 4), dpi = 100)
data = {'0':value1, '2':value2, '4':value3, '6':value4, '8':value5, '10':value6}
velocity = list(data.keys())
values = list(data.values())
plt.bar(X_axis + 0.2, values2, color ='black', width = 0.3, label = 'WH with NOMA based MPDS')
velocity = ['0','2','4','6','8','10']
X_axis = np.arange(len(velocity))
plt.yticks([0, 2,4,6,8,10])
plt.xticks(X_axis, velocity)
plt.grid(True)
plt.legend(loc='upper right')
plt.xlabel("Velocity (m/s)")
plt.ylabel('Average Energy Consumption (J)')
plt.title("Velocity Rayleigh Flat Fading NOMA Q-EAR")
plt.show()
plt.close()

"""#**Served Failed Hub - Access Points**"""

import cv2
import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
figure(figsize = (5, 4), dpi = 220)
served=0
failed=0
sensor_energy_1 = energy_cache[:,:,9].mean()
sensor_energy_2 = energy_cache[:,:,10].mean()
sensor_energy_3 = energy_cache[:,:,11].mean()
sensor_energy_4 = energy_cache[:,:,12].mean()
sensor_energy_5 = energy_cache[:,:,13].mean()
if sensor_energy_1 > sensor_energy_2:
  served =1
elif sensor_energy_1 < sensor_energy_2:
  failed =1
elif sensor_energy_2 < sensor_energy_3:
  failed =1
elif sensor_energy_2 > sensor_energy_3:
  failed =1
elif sensor_energy_3 < sensor_energy_4:
  failed =1
elif sensor_energy_3 > sensor_energy_4:
  failed =1
elif sensor_energy_4 < sensor_energy_5:
  failed =1
elif sensor_energy_14 > sensor_energy_5:
  failed =1
plt.xticks([0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000])
plt.yticks([0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000])
plt.xlabel("X(m)")
plt.ylabel('Y(m)')
plt.show()
plt.close()