# -*- coding: utf-8 -*-
"""Python_Wireless_Communication_Shortest_Path_Packet_Qlearning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KFCfg8CYqaHbB7W9bzk9NAVE9e3UC_ds
"""

import random
import math
import numpy
import matplotlib as plt
import sys
import numpy as np
import datetime

#Model
#set parameters
class Model:
    def __init__(self, n, m, dx, dy):
        # Number of Nodes(Coordinators)
        self.n = n

        # Number of Senesors
        self.m = m

        #Area dimension
        self.dx = dx
        self.dy = dy

        #Sink Motion pattern
        self.Sinkx = 0.5*self.dx
        self.Sinky = self.Sinkx

        #Initial Energy  (Joules)
        self.En = 100
        self.Ec = 200

        #Eelec = Etx = Erx
        self.ETX = 50*0.000000001
        self.ERX = 50*0.000000001

        #Transmit Amplifier types
        self.Efs = 10*0.000000000001
        self.Emp = 0.0013*0.000000000001

        #Data Aggregation Energy
        self.EDA = 5*0.000000001

        #Computation of do
        self.d0 = math.sqrt(self.Efs/self.Emp)

        #maximum number of rounds
        self.rmax = 5000

        #Data packet size
        self.DataPacketLen = 50000000000000000000

        #Hello packet size
        self.HelloPacketLen = 50000000000000000000

        #Number of Packets sended in steady-state phase
        self.NumPacket = 8

        #Redio Range
        self.RR = 35 #0.5*self.x*math.sqrt(2)

        #Number of Cluster Head
        self.NC = 10

        # Vsup
        self.Vsup = 2.7

        # Isens
        self.Isens = 25 * 10**-3

        # Tsen
        self.Tsens = 0.5 * 10**-3

        self.w1 = 1.1
        self.w2 = 1.2
        self.w3 = 1.2

        self.Niter = 0.97*10**6
        self.f = 191.42*10**6
        self.Cavg = 22*10**-12
        self.I0 = 1.196*10**-3
        self.Vt = 0.2
        self.Proc = 21.26

        self.IA = 8 * 10**-3
        self.IS = 1 * 10**-6
        self.TAN = 10**-3
        self.TACH = 10 *10**-3
        self.TranON = 2450*10**-6
        self.TranOFF = 250*10**-6
        self.TS = 299 * 10**-3
        self.TSCH = 290 * 10**-3

        self.CN = (self.TranON + self.TAN + self.TranOFF)/(self.TranON + self.TAN + self.TranOFF + self.TS)
        self.CCH = (self.TranON + self.TACH + self.TranOFF)/(self.TranON + self.TACH + self.TranOFF + self.TSCH)

        self.Vmax = 2
        self.Vmin = 0

        self.gamma = 0.4
        self.C = 3 * 10**8

        self.Pld0=10*math.log(4*math.pi*self.d0*self.f)*self.C
        self.pploss = 0.2

        self.BER = 10**-5


        self.fi = 1.79
        self.miu = 4*math.pi*10**7
        self.ro = 1040
        self.omega = 2.4
        self.eps=52.73
        self.I=0.1

class Topology:
    def __init__(self, model):
        self.xc = [random.uniform(0, model.dx) for _ in range(model.n)]
        self.yc = [random.uniform(0, model.dy) for _ in range(model.n)]

        xn = []
        yn = []
        for c in self.xc:
            for _ in range(0,model.m):
                randx = random.uniform(-0.5,0.5)
                xn.append(c+randx)

        for c in self.yc:
            for _ in range(0,model.m):
                randy = random.uniform(-0.5,0.5)
                yn.append(c+randy)
        self.xn = xn
        self.yn = yn
        self.x = self.xc + self.xn
        self.y = self.yc + self.yn



        x_=self.xc + self.xn
        y_ = self.yc + self.yn

        x_ = np.array(x_)
        x_ = x_.astype(int)
        self.x=x_

        y_ = np.array(y_)
        y_ = y_.astype(int)
        self.y=y_


        self.velX = [[random.uniform(-1,1) for _ in range(20)] for _ in range(model.n)]
        self.velY = [[random.uniform(-1,1) for _ in range(20)] for _ in range(model.n)]

        self.velX_ = [[random.uniform(-1,1) for _ in range(20)] for _ in range(model.n)]
        self.velY_ = [[random.uniform(-1,1) for _ in range(20)] for _ in range(model.n)]




        #print("self.velX", self.velX)
        #print("self.velY",self.velY)
        #print("self.x",self.x)
        #print("self.y",self.y)


    def BrownianMotion(self):
        n = 20
        dt = 1/n
        dB = 0; dC = 0
        for i in range(n):
            dB += math.sqrt(dt)*random.random();
            dC += math.sqrt(dt)*random.random();

        return dB, dC

    def RandomWalk(self, model):
        '''
        for i in range(model.n):
            v = random.random()*(model.Vmax - model.Vmin) + model.Vmin
            angle = random.random()*2*math.pi
            self.xc += v * math.cos(angle)
            self.yc += v * math.sin(angle)
        '''
        for i in range(model.n):
            ux = numpy.mean(self.velX[i])
            uy = numpy.mean(self.velY[i])

            n = 20; k = int(n/2); sx = 0;  sy = 0

            for j in range(n-k):
                sy = sy + (self.velY[i][j]-uy)*(self.velY[i][j+k]-uy)
                sx = sx + (self.velX[i][j]-ux)*(self.velX[i][j+k]-ux)

            sx = sx/n
            sy = sy/n

            self.velX[i].pop(0)
            self.velX[i].append(sx)

            self.velY[i].pop(0)
            self.velY[i].append(sy)

            u = numpy.array([ux, uy])
            vXY = numpy.array([self.velX[i][-1],self.velY[i][-1]])

            J = numpy.cov(self.velX[i],self.velY[i])
            B = self.BrownianMotion()
            dt = 1/n
            teta = random.random()*2*math.pi

            m1 = numpy.array([[-math.log1p(abs(sx)),teta],[-teta, -math.log1p(abs(sy))]])

            dv = numpy.dot(-m1,(vXY-u))*dt + numpy.dot(J,B)*dt
            self.xc[i] = abs(self.xc[i] + dv[0])
            self.yc[i] = abs(self.yc[i] + dv[1])


        xn = []
        yn = []
        for c in self.xc:
            for _ in range(0, model.m):
                randx = random.uniform(-0.5,0.5)
                xn.append(c+randx)

        for c in self.yc:
            for _ in range(0, model.m):
                randy = random.uniform(-0.5,0.5)
                yn.append(c+randy)

        self.xn = xn
        self.yn = yn
        self.x = self.xc + self.xn
        self.y = self.yc + self.yn

class Sensors:
    def __init__(self):
        self.x=0
        self.y=0
        self.df=0
        self.id=0
        self.dis2sink=0
        self.dis2ch=0
        self.MCH=0
        self.type = 'Null'
        self.E = 0
        self.SensingF = 0
        self.PowerConsumption = 0
        self.TransferingF = 0
        self.NeighbourList = []
        self.RoutingTable = []
        '''
        self.LinkReliability=[]
        self.LinkQr=[]
        self.LinkPathloss=[]
        self.LinkEnergy=[]
        '''

    def Configuration(self,  counterType):


        if (counterType == 0):

            self.type = 'ecg'
            self.priority = 100 #percent
            self.x = 2
            self.y = 9
            self.E = 3.4
            self.SensingF = 500
            self.PowerConsumption = 464 * 10**-3
            self.TransferingF = 2
            self.sleep = 0.002
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 1.23
            self.yknn = 1.79
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=3


        elif (counterType == 1):

            self.type = 'o2'
            self.priority = 80 #percent
            self.x = 3
            self.y = 9
            self.E = 3.5
            self.SensingF = 500
            self.PowerConsumption = 464 * 10**-3
            self.TransferingF = 2
            self.sleep = 0.002
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 0.75
            self.yknn = 0.41
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=4

        elif (counterType == 2):

            self.type = 'eeg'
            self.priority = 40 #percent
            self.x = 1
            self.y = 1
            self.E = 5
            self.SensingF = 20
            self.PowerConsumption = 435 * 10**-3
            self.TransferingF = 50*10**-3
            self.sleep = 0.005
            self.temperature = 0.001 # for each packet
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 1.87
            self.yknn = 0.81
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=1

        elif (counterType == 3):

            self.type = 'blood'
            self.priority = 20 #percent
            self.x = 7
            self.y = 1
            self.E = 4.9
            self.SensingF = 4
            self.PowerConsumption = 464 * 10**-3
            self.TransferingF = 250*10**-3
            self.sleep = 0.025
            self.temperature = 0.001 # for each packet
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 0.65
            self.yknn = 0.81
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=1

        elif (counterType == 4):

            self.type = 'temp'
            self.priority = 60 #percent
            self.x = 1
            self.y = 4
            self.E = 3.3
            self.SensingF = 0.2
            self.PowerConsumption = 1951 * 10**-3
            self.TransferingF = 5
            self.sleep = 0.005
            self.temperature = 0.001 # for each packet
            #Temperature
            self.GrowthTemperature  = 0.001 # for each packet
            self.MildTemperature    = 37
            self.MaxTemperature     = 38
            self.CurrentTemperature = 37
            self.ReverseTime        = 540
            self.ElapseTime         = datetime.now()
            self.xknn = 1.87
            self.yknn = 0.71
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8
            self.coef=4

        elif (counterType == 5):          #Coordinator
            self.x = 0
            self.y = 5
            self.type = 'coor'
            self.E = 100
            self.patientClass = coordiantorType
            #self.numPacket = 1524.2
            self.Erx_elec = 36.1*0.000000001
            self.Etx_elec = 16.7*0.000000001
            self.Eamp = 1.97*0.000000001
            self.k=8

        else:                              #Sink

            self.type = 'sink'
            self.E = 100000

    def Sensing(self, model):
        if self.type == 'C':
            self.E = self.E - (model.w1 * model.DataPacketLen * model.Vsup * model.Isens * model.Tsens)

        else:
            self.E = self.E - self.SensingF * (model.DataPacketLen * model.Vsup * model.Isens * model.Tsens)

    def Proccessing(self,model):
        if self.type == 'C':
            self.E = self.E - self.numPacket * model.w3 * (model.DataPacketLen * model.Niter * model.Cavg * model.Vsup**2 + \
                model.DataPacketLen * model.Vsup * (model.I0 * math.e ** (model.Vsup/(model.Vt*model.Proc))) * (model.Niter/model.f))
        else:
            self.E = self.E - self.SensingF * (model.DataPacketLen * model.Niter * model.Cavg * model.Vsup**2 + \
                model.DataPacketLen * model.Vsup * (model.I0 * math.e ** (model.Vsup/(model.Vt*model.Proc))) * (model.Niter/model.f))

    def Trasient(self, model):
        pass

    def findNeighbours(self):
        return self.NeighbourList

    def Moving(self, x, y):
        self.x = x
        self.y = y

"""#Q-Learning"""

#QLearning
#def createArray():
#Initialize row, column
#define the shape of the environment (i.e., its states)
environment_rows = 11
environment_columns = 11
#Create a 3D numpy array to hold the current Q-values for each state and action pair: Q(s, a)
#The array contains 11 rows and 11 columns (to match the shape of the environment), as well as a third "action" dimension.
#The "action" dimension consists of 4 layers that will allow us to keep track of the Q-values for each possible action in
#each state (see next cell for a description of possible actions).
#The value of each (state, action) pair is initialized to 0.
q_values = np.zeros((environment_rows, environment_columns, 4))

#define actions
#numeric action codes: 0 = up, 1 = right, 2 = down, 3 = left
actions = ['up', 'right', 'down', 'left', 'upleft', 'upright', 'downleft', 'downright']
#Create a 2D numpy array to hold the rewards for each state.
#The array contains 100 rows and 100 columns (to match the shape of the environment), and each value is initialized to -100.
rewards = np.full((environment_rows, environment_columns), -100.)
rewards[0, 5] = 100. #set the reward for the packaging area (i.e., the goal) to 100  # (model.Sinkx , model.Sinky)



#define aisle locations (i.e., white squares) for rows 1 through 9
aisles = {} #store locations in a dictionary
aisles[1] = [i for i in range(1, 10)]
aisles[2] = [1, 7, 9]
aisles[3] = [i for i in range(1, 8)]
aisles[3].append(9)
aisles[4] = [3, 7]
aisles[5] = [i for i in range(11)]
aisles[6] = [5]
aisles[7] = [i for i in range(1, 10)]
aisles[8] = [3, 7]
aisles[9] = [i for i in range(11)]
#set the rewards for all aisle locations (i.e., white squares)
for row_index in range(1, 10):
  for column_index in aisles[row_index]:
    rewards[row_index, column_index] = -1.
#print rewards matrix
for row in rewards:
  print(row)
#define a function that determines if the specified location is a terminal state
def is_terminal_state(current_row_index, current_column_index):
  #if the reward for this location is -1, then it is not a terminal state (i.e., it is a 'white square')
  #print('current_row_index',current_row_index)
  #print(current_row_index,current_column_index)
  if (rewards[current_row_index, current_column_index] == -1.):
    return False
  else:
    return True
#define a function that will choose a random, non-terminal starting location
def get_starting_location():
  #get a random row and column index
  current_row_index = np.random.randint(environment_rows)
  current_column_index = np.random.randint(environment_columns)
  #continue choosing random row and column indexes until a non-terminal state is identified
  #(i.e., until the chosen state is a 'white square').
  while is_terminal_state(current_row_index, current_column_index):
    current_row_index = np.random.randint(environment_rows)
    current_column_index = np.random.randint(environment_columns)
  return current_row_index, current_column_index
#define an epsilon greedy algorithm that will choose which action to take next (i.e., where to move next)
def get_next_action(current_row_index, current_column_index, epsilon):
  #if a randomly chosen value between 0 and 1 is less than epsilon,
  #then choose the most promising value from the Q-table for this state.
  if np.random.random() < epsilon:
    #if (isinstance(current_row_index, int) and isinstance(current_column_index, int)):
    return np.argmax(q_values[current_row_index, current_column_index])
  else: #choose a random action
    return np.random.randint(4)
#define a function that will get the next location based on the chosen action
def get_next_location(current_row_index, current_column_index, action_index):
  new_row_index = current_row_index
  new_column_index = current_column_index
  if actions[action_index] == 'up' and current_row_index > 0:                                 # North
    new_row_index -= 1
  elif actions[action_index] == 'right' and current_column_index < environment_columns - 1:   # East
    new_column_index += 1
  elif actions[action_index] == 'down' and current_row_index < environment_rows - 1:          # South
    new_row_index += 1
  elif actions[action_index] == 'left' and current_column_index > 0:                          # West
    new_column_index -= 1
  elif actions[action_index] == 'upleft' and current_column_index < environment_columns - 1:  # North West
    new_column_index += 1
  elif actions[action_index] == 'upright' and current_column_index > 0 :# North East
    new_column_index -= 1
  elif actions[action_index] == 'downleft' and current_column_index  > 0 :# South West
    new_column_index -= 1
  elif actions[action_index] == 'downright' and current_column_index  < environment_columns - 1:                 # South East
    new_column_index += 1
  return new_row_index, new_column_index


#Define a function that will get the shortest path between any location within the warehouse that
#the robot is allowed to travel and the item packaging location.
def get_shortest_path(start_row_index, start_column_index):
  #return immediately if this is an invalid starting location
  if is_terminal_state(start_row_index, start_column_index) : #hub
    return []
  else: #if this is a 'legal' starting location
    current_row_index, current_column_index = start_row_index, start_column_index
    shortest_path = []
    shortest_path.append([current_row_index, current_column_index])
    #continue moving along the path until we reach the goal (i.e., the item packaging location)
    while not is_terminal_state(current_row_index, current_column_index):
      #get the best action to take
      action_index = get_next_action(current_row_index, current_column_index, 1.)
      #move to the next location on the path, and add the new location to the list
      current_row_index, current_column_index = get_next_location(current_row_index, current_column_index, action_index)
      shortest_path.append([current_row_index, current_column_index])
    if shortest_path == []:
      return null
    else:
      return shortest_path

def training_qlearn():
  #define training parameters
  epsilon = 0.9 #the percentage of time when we should take the best action (instead of a random action)
  discount_factor = 0.9 #discount factor for future rewards
  learning_rate = 0.9 #the rate at which the agent should learn

  #run through 1000 training episodes
  for episode in range(1000): #epoch
    #get the starting location for this episode
    row_index, column_index = get_starting_location()
    #continue taking actions (i.e., moving) until we reach a terminal state
    #(i.e., until we reach the item packaging area or crash into an item storage location)
    while not is_terminal_state(row_index, column_index):
      #choose which action to take (i.e., where to move next)
      action_index = get_next_action(row_index, column_index, epsilon)
      #perform the chosen action, and transition to the next state (i.e., move to the next location)
      old_row_index, old_column_index = row_index, column_index #store the old row and column indexes
      row_index, column_index = get_next_location(row_index, column_index, action_index)
      #receive the reward for moving to the new state, and calculate the temporal difference
      reward = rewards[row_index, column_index]
      old_q_value = q_values[old_row_index, old_column_index, action_index]
      temporal_difference = reward + (discount_factor * np.max(q_values[row_index, column_index])) - old_q_value
      #update the Q-value for the previous state and action pair
      new_q_value = old_q_value + (learning_rate * temporal_difference)
      q_values[old_row_index, old_column_index, action_index] = new_q_value
  print('Training complete!')

"""#SAR"""

import math
import cmath
def SAR(R, t):
    fi = 1.79
    miu = 4*math.pi*10**7
    ro = 1040
    omega = 2.4*10**-9
    eps=52.73
    I=0.1
    R=R/100
    alpha = omega*math.sqrt((miu*eps)/2)*(math.sqrt(1 + (fi/(miu*eps))**2 - 1))**(1/2)
    beta = omega*math.sqrt((miu*eps)/2)*(math.sqrt(1 + (fi/(miu*eps)**2 +1 )))**(1/2)
    gamma = alpha + cmath.sqrt(-1) * beta
    SAR = (fi * miu* omega)/(ro*math.sqrt(fi**2 + eps**2 * omega**2)) * ((I*1*1*math.exp(-alpha*R))/(4 *math.pi) * (1/R**2 + abs(gamma)/R))**2

    C = 3600
    delta =  SAR * t/C
    return delta

import numpy as np
from time import sleep
from datetime import datetime
import time


#settings
count_num=16000
patient_num = 100
sensor_num = 5

import numpy as np
from time import sleep
from datetime import datetime
import time
from random import randrange
import random
import multiprocessing
training_qlearn()
sensors = [Sensors() for _ in range(6)]
temp_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
energy_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
packet_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
throughput_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
time_cache = np.zeros((count_num, patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
elapsed_cache = np.zeros((patient_num, sensor_num),  dtype=object) #Count - Patient - Sensor
patients_priority_cache = np.zeros((patient_num),  dtype=object) #Count - Patient - Sensor
sensors_priority_cache = np.zeros((sensor_num),  dtype=object) #Count - Patient - Sensor


elapsed_ecg=1
elapsed_o2=2
elapsed_eeg=1
elapsed_blood=1
elapsed_temp=1

time_now = datetime.now()
elapsed = 0
for count in range(count_num):        #Count
  print('iteration: ', count+1)
  for patient in range(patient_num):  #Patient
    print('patient: ', patient)
    for sensor in range(sensor_num):  #Sensor

      sensors[sensor].Configuration(sensor)
      if sensor==0:
        if count==0:
          status='ECG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          #energy Consumption
          #Ekd    = Erx_elec*kd**2 + Etx_kd
          #Etx_kd = Etx_elec*k + Eamp *k *d**2
          #Ekd    = Erx_elec*k* d**2 +  Etx_elec*k + Eamp *k *d**2

          #Erx_elec = 36.1*0.000000001
          #Etx_elec = 16.7*0.000000001
          #Eamp = 1.97*0.000000001
          #k=8
          #d=0.04
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + float(sensors[sensor].E) - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('ECG shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] <= 0  or temp_cache[count, patient, sensor] > 38):
            status='ECG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='ECG Reset'
              print('ECG shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='ECG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] = sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('ECG shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='ECG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =    elapsed_ecg*(sensors[sensor].sleep*10**6) -count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              elapsed_ecg=elapsed_ecg+1
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='ECG Reset'
              print('ECG shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          print('ECG sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: ECG  - Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor], status)


      elif sensor==1:
        if count==0:
          status='O2 Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('O2 shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] <= 0  or temp_cache[count, patient, sensor] >= 38):
            status='O2 Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='O2 Reset'
              print('O2 shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='O2 Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('O2 shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='O2 Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =    elapsed_o2*( sensors[sensor].sleep*10**6) -count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_o2=elapsed_o2+1
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='O2 Reset'
              print('O2 shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          print('O2 sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: O2   - Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor], status)

      elif sensor==2:
        if count==0:
          status='EEG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] = sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('EEG shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] <= 0  or temp_cache[count, patient, sensor] >= 38):
            status='EEG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='EEG Reset'
              print('EEG shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='EEG Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('EEG shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='EEG Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =    elapsed_eeg*(sensors[sensor].sleep*10**6) - count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              elapsed_eeg=elapsed_eeg+1
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='EEG Reset'
              print('EEG shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          print('EEG sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: EEG  - Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor] , status)


      elif sensor==3:
        if count==0:
          status='Blood Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('Blood shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] <= 0  or temp_cache[count, patient, sensor] >= 38):
            status='Blood Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='Blood Reset'
              print('Blood shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='Blood Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('Blood shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='Blood Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =   elapsed_blood*(sensors[sensor].sleep*10**6) - count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              elapsed_blood=elapsed_blood+1
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='Blood Reset'
              print('Blood shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          print('Blood sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: Blood- Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor],  status)

      elif sensor==4:
        if count==0:
          status='Temp Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count, patient, sensor] + sensors[sensor].CurrentTemperature + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count, patient, sensor] + sensors[sensor].E - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('Temp shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='Temp Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] = time_cache[count, patient, sensor] -  time_cache[count - sensors[sensor].sleep*10**6, patient, sensor]
            if elapsed_cache[patient, sensor] > 2:
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='Temp Reset'
              print('Temp shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=packet_cache[count, patient, sensor]
        elif count>0:
          status='Temp Working...'
          d=math.sqrt(((sensors[sensor].x-sensors[5].x)**2)+((sensors[sensor].y-sensors[5].y)**2))
          sar = SAR(d,count)
          inc_temp = sar + sensors[sensor].GrowthTemperature
          inc_temp    = round(inc_temp, 5)
          temp_cache[count, patient, sensor] = temp_cache[count - 1, patient, sensor] + inc_temp #Count - Patient - Sensor
          Ekd    = sensors[sensor].Erx_elec*sensors[sensor].k* d**2 +  sensors[sensor].Etx_elec*sensors[sensor].k + sensors[sensor].Eamp *sensors[sensor].k *d**2
          Ekd    = round(Ekd, 10)
          energy_cache[count, patient, sensor] = energy_cache[count - 1, patient, sensor]  - Ekd #Count - Patient - Sensor
          time_cache[count, patient, sensor] = (time_now.minute*60+time_now.second)
          if (energy_cache[count, patient, sensor] > 0  and temp_cache[count, patient, sensor] <38):
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] + 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
            patients_priority_cache[patient] = random.randint(0, 100)
            sensors_priority_cache[sensor] =sensors[sensor].priority
            shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
            print('Temp shortest_path: ', shortest_path)
          elif (energy_cache[count, patient, sensor] < 0  or temp_cache[count, patient, sensor] > 38):
            status='Temp Sleeping'
            time.sleep(sensors[sensor].sleep) #sleeps for x seconds
            temp_cache[count, patient, sensor] = 38 - sensors[sensor].sleep
            elapsed_cache[ patient, sensor] =   elapsed_temp*(sensors[sensor].sleep*10**6)-count
            if elapsed_cache[patient, sensor] > 2:
              elapsed_temp=elapsed_temp+1
              elapsed_cache[ patient, sensor]=0
              temp_cache[count, patient, sensor]=37
              time_cache[count, patient, sensor]=0
              shortest_path=get_shortest_path(int(sensors[sensor].x), int(sensors[sensor].y))
              status='Temp Reset'
              print('Temp shortest_path: ', shortest_path)
            packet_cache[count, patient, sensor] = packet_cache[count, patient, sensor] - 1 #Count - Patient - Sensor
            throughput_cache[count, patient, sensor]=throughput_cache[count-1, patient, sensor]+packet_cache[count, patient, sensor]
        if energy_cache[count, patient, sensor] == 0:
          print('Temperature sensor is not accessible anymore due to zero energy...')
        else:
          print('sensor: Temp - Temperature(iter:',count+1 ,'): ',  round(temp_cache[count, patient, sensor], 10), 'Energy(iter:',count+1 ,'): ',round(energy_cache[count, patient, sensor], 10), 'Packet(iter:',count+1 ,'): ',packet_cache[count, patient, sensor],  status)

"""#Plot

#Energy Residual
"""

import matplotlib.pyplot as plt
sensor_energy_1 = energy_cache[0:1000, :, :].mean()
sensor_energy_2 = energy_cache[0:2000, :, :].mean()
sensor_energy_3 = energy_cache[0:3000, :, :].mean()
sensor_energy_4 = energy_cache[0:4000, :, :].mean()
sensor_energy_5 = energy_cache[0:5000, :, :].mean()
sensor_energy_6 = energy_cache[0:6000, :, :].mean()
sensor_energy_7 = energy_cache[0:7000, :, :].mean()
sensor_energy_8 = energy_cache[0:8000, :, :].mean()
sensor_energy_9 = energy_cache[0:9000, :, :].mean()
sensor_energy_10 = energy_cache[0:10000, :, :].mean()
sensor_energy_11 = energy_cache[0:11000, :, :].mean()
sensor_energy_12 = energy_cache[0:12000, :, :].mean()
sensor_energy_13 = energy_cache[0:13000, :, :].mean()
sensor_energy_14 = energy_cache[0:14000, :, :].mean()
sensor_energy_15 = energy_cache[0:15000, :, :].mean()
sensor_energy_16 = energy_cache[0:16000, :, :].mean()
xpoints_energy = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
ypoints_energy = [0,sensor_energy_1 ,sensor_energy_2,sensor_energy_3,sensor_energy_4,sensor_energy_5,sensor_energy_6,sensor_energy_7,sensor_energy_8,sensor_energy_9,sensor_energy_10,sensor_energy_11,sensor_energy_12,sensor_energy_13,sensor_energy_14,sensor_energy_15,sensor_energy_16 ]
plt.plot(xpoints_energy, ypoints_energy, 'g-o')
plt.yticks([0,0.1,0.2,0.3,0.4,0.5, 0.6, 0.7])
plt.xticks([0,2000,4000,6000,8000,10000, 12000, 14000, 16000])
plt.xlabel('Number of rounds')
plt.ylabel('Residual energy(J)')
plt.legend(['Q Learning '])
plt.show()

"""![energy-node.png](data:image/png;base64,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pmJnZ6c4ODjk6lFy9OhRxdnZWbGzs1PGjRtX5IdRujxeCEpKrr///ltp2bKl4uLiovTp00e5ffu20bN99tlniqOjo+Ls7Ky89dZbSkZGhtEy+fj4KC+++KJiYWGhWFtbK99//32xZrl//74ycOBA5aWXXlI8PDyUixcvPnOul156SVGr1dr//z86MRk71+MeLwTGzpWZmakMHTpUcXZ2Vpo3b67s3LnToLlkiAkhhDBxJvGMQAghRMGkEAghhImTQiCEECZOCoEQQpg4KQRCCGHipBCIEk2lUjFp0iTt53nz5vHFF18Uy76HDx/OunXrimVfhfn1119p0qQJnTp10vuxClKlShWjHVuUfFIIRIlWvnx5fvvtt1zDBZcEGo2myG1XrVrFt99+y19//VUs+xOiuEkhECWahYUFfn5+LFy4MM+6J3/RP/rVu3v3bjp06MDgwYNxcHDgo48+IigoiFatWuHi4sLFixe12+zYsYPXXnsNBwcHNm3aBDw8KU+ZMgUPDw+aNWvGd999p91vp06dePPNN3FxccmTJzg4GBcXF5o2bcqHH34IwJdffsn+/fvx9/dnypQpudo/ub+MjAxGjBiBi4sLzZs31xaO1atX895772m369WrF7t379Z+52nTpuHq6kqbNm24fv06ADExMbRt2xYPDw8+/fRT7bZXr16lffv2uLm50bRpU/bt21fEfxOiLJNCIEq8cePGERQUREpKSpG3OXHiBIsXL+bUqVP89NNPREVFER4ezqhRo1i6dKm23eXLl9mzZw+bN2/G39+fjIwMVq1ahZWVFUePHuXo0aOsXLmSmJgYAMLDw5k1axZnz57NdbwrV67w4YcfsmvXLiIjIzl69CgbNmzgs88+w93dnaCgIObOnZsn5+P7W7ZsGQCnTp0iODiYd955h4yMjEK/Z1paGm3atOHEiRO0b9+elStXAjB+/HjGjBnD0aNHefHFF7Xt165di5eXF5GRkZw4cQI3N7ci/01F2SWFQJR41apVY9iwYSxZsqTI23h4eFCvXj3Kly/PSy+9hKenJwAuLi65ZmwaPHgwZmZmNG7cGDs7O86dO8eff/7JmjVrcHNzo3Xr1ty6dYvo6GgAWrVqRaNGjfIc7+jRo3Ts2JHatWtrR9vcu3evzpyP72///v28/fbbALz88ss0bNiQqKioQrcvV66cdqa5li1bar/bgQMHGDJkCIB2n4/+Lj/++CNffPEFp06domrVqjozirJPCoEoFSZMmMCqVatIS0vTLrOwsCAnJwd4OPTugwcPtOvKly+v/WczMzPtZzMzM7Kzs7Xrnhye99EQv0uXLiUyMpLIyEhiYmK0haRy5cr55nvWkVoe319B+3j8ewK5rhIsLS2138Hc3LzQ7wbQvn179u7di7W1NW+//TZr1qx5ptyibJFCIEqFGjVqMHjwYFatWqVdZmtry7FjxwAIDQ0lKyvrqff766+/kpOTw8WLF7l06RKOjo54eXmxfPly7f6ioqJyFaD8tG7dmj179nDz5k00Gg3BwcF06NDhqbK0b9+eoKAg7THj4uJwdHTE1taWyMhIcnJyiI+PJzw8XOe+2rVrR0hICIB2nwCxsbHUqVOH0aNHM3LkSI4fP/5UGUXZZGHsAEIU1aRJkwgICNB+Hj16NH369KFVq1Z06dKlwF/rhXF0dKRDhw5cv36dFStWUKFCBUaNGsXly5dp0aIFiqJQu3ZtNmzYUOh+6tWrx+zZs+nUqROKotCjRw/69OnzVFnGjh2Lv78/Li4uWFhYsHr1asqXL0+7du1o1KiR9kF0ixYtdO5r8eLFvPnmmyxevJgBAwZol+/evZu5c+diaWlJlSpV5IpAACCjjwohhImTW0NCCGHipBAIIYSJk0IghBAmTgqBEEKYOCkEQghh4qQQCCGEiZNCIIQQJu7/AN4fJRPfD24mAAAAAElFTkSuQmCC)

#Throughput
"""

import matplotlib.pyplot as plt

sensor_throughput_1 =  throughput_cache[0:1000, :, :].mean()
sensor_throughput_2 =  throughput_cache[0:2000, :, :].mean()
sensor_throughput_3 =  throughput_cache[0:3000, :, :].mean()
sensor_throughput_4 =  throughput_cache[0:4000, :, :].mean()
sensor_throughput_5 =  throughput_cache[0:5000, :, :].mean()
sensor_throughput_6 =  throughput_cache[0:6000, :, :].mean()
sensor_throughput_7 =  throughput_cache[0:7000, :, :].mean()
sensor_throughput_8 =  throughput_cache[0:8000, :, :].mean()
sensor_throughput_9 =  throughput_cache[0:9000, :, :].mean()
sensor_throughput_10 = throughput_cache[0:10000, :, :].mean()
sensor_throughput_11 = throughput_cache[0:11000, :, :].mean()
sensor_throughput_12 = throughput_cache[0:12000, :, :].mean()
sensor_throughput_13 = throughput_cache[0:13000, :, :].mean()
sensor_throughput_14 = throughput_cache[0:14000, :, :].mean()
sensor_throughput_15 = throughput_cache[0:15000, :, :].mean()
sensor_throughput_16 = throughput_cache[0:16000, :, :].mean()
xpoints_throughput = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
ypoints_throughput = [0,sensor_throughput_1 ,sensor_throughput_2 ,sensor_throughput_3 ,sensor_throughput_4 ,sensor_throughput_5 ,sensor_throughput_6 ,sensor_throughput_7 ,sensor_throughput_8 ,sensor_throughput_9 ,sensor_throughput_10,sensor_throughput_11,sensor_throughput_12,sensor_throughput_13,sensor_throughput_14,sensor_throughput_15,sensor_throughput_16]
plt.plot(xpoints_throughput, ypoints_throughput, 'g-o')
plt.yticks([0,0.1,0.2,0.3,0.4,0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([0,2000,4000,6000,8000,10000, 12000, 14000, 16000])
plt.xlabel('Number of rounds')
plt.ylabel('Throughput')
plt.legend(['Q Learning '])
plt.show()

import matplotlib.pyplot as plt


xpoints_throughput = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]
ypoints_throughput = [0,sensor_throughput_1 ,sensor_throughput_2 ,sensor_throughput_3 ,sensor_throughput_4 ,sensor_throughput_5 ,sensor_throughput_6 ,sensor_throughput_7 ,sensor_throughput_8 ,sensor_throughput_9 ,sensor_throughput_10,sensor_throughput_11,sensor_throughput_12,sensor_throughput_13,sensor_throughput_14,sensor_throughput_15,sensor_throughput_16]
plt.plot(xpoints_throughput, ypoints_throughput, 'g-o')
plt.yticks([0,0.1,0.2,0.3,0.4,0.5, 0.6, 0.7, 0.8, 0.9, 1])
plt.xticks([0,2000,4000,6000,8000,10000, 12000, 14000, 16000])
plt.xlabel('Number of rounds')
plt.ylabel('Throughput')
plt.legend(['Q Learning '])
plt.show()

"""![throughputnode.png](data:image/png;base64,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)

#End to End Delay
"""

import matplotlib.pyplot as plt
sensor_time_cache_1 =time_cache[:,1, :].mean()
sensor_time_cache_2 =time_cache[: 2, :].mean()
sensor_time_cache_3 =time_cache[: 3, :].mean()
sensor_time_cache_4 =time_cache[: 4, :].mean()
sensor_time_cache_5 =time_cache[: 5, :].mean()
sensor_time_cache_6 =time_cache[: 6, :].mean()
sensor_time_cache_7 =time_cache[: 7, :].mean()
sensor_time_cache_8 =time_cache[: 8, :].mean()
sensor_time_cache_9 =time_cache[: 9, :].mean()
sensor_time_cache_10=time_cache[:,10, :].mean()
xpoints_endtoend=[5, 10, 15,  20, 25, 30, 35, 40, 45, 50]
ypoints_endtoend = [sensor_time_cache_1 ,sensor_time_cache_2 ,sensor_time_cache_3 ,sensor_time_cache_4 ,sensor_time_cache_5 ,sensor_time_cache_6 ,sensor_time_cache_7 ,sensor_time_cache_8 ,sensor_time_cache_9 ,sensor_time_cache_10]
plt.plot(xpoints_endtoend , ypoints_endtoend, 'g-o')
plt.yticks([0,0.025,0.05, 0.075, 0.1])
plt.xticks([5, 10, 15,  20, 25, 30, 35, 40, 45, 50])
plt.xlabel('Number of nodes')
plt.ylabel('End-to-end-delay(sec)')
plt.title("End to End Delay")
plt.legend(['Q Learning '])
plt.show()

"""![end-to-end-node-2.png](data:image/png;base64,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)

#Packet Delivery Ratio
"""

import matplotlib.pyplot as plt
sensor_packet_cache_1 =packet_cache[:,1, :].mean()
sensor_packet_cache_2 =packet_cache[: 2, :].mean()
sensor_packet_cache_3 =packet_cache[: 3, :].mean()
sensor_packet_cache_4 =packet_cache[: 4, :].mean()
sensor_packet_cache_5 =packet_cache[: 5, :].mean()
sensor_packet_cache_6 =packet_cache[: 6, :].mean()
sensor_packet_cache_7 =packet_cache[: 7, :].mean()
sensor_packet_cache_8 =packet_cache[: 8, :].mean()
sensor_packet_cache_9 =packet_cache[: 9, :].mean()
sensor_packet_cache_10=packet_cache[:,10, :].mean()
xpoints_eeg = [0, 5, 10, 15,  20, 25, 30, 35, 40, 45, 50]
ypoints_eeg = [sensor_packet_cache_1 ,sensor_packet_cache_2 ,sensor_packet_cache_3 ,sensor_packet_cache_4 ,sensor_packet_cache_5 ,sensor_packet_cache_6 ,sensor_packet_cache_7 ,sensor_packet_cache_8 ,sensor_packet_cache_9 ,sensor_packet_cache_10]
plt.plot(xpoints_eeg,ypoints_eeg, 'g-o')
plt.yticks([0,0.10, 0.20, 0.30,0.40,0.50,0.60,0.70,0.80,0.90,0.100])
plt.xticks([5, 10, 15,  20, 25, 30, 35, 40, 45, 50])
plt.xlabel('Nodes')
plt.ylabel('Packet Reception Ratio')
plt.legend(['Q Learning '])
plt.show()

"""![packet-node.png](data:image/png;base64,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)

#Nember of Heated Nodes
"""

import matplotlib.pyplot as plt
sensor_temp_cache_1 =temp_cache[:,1, :].mean()
sensor_temp_cache_2 =temp_cache[: 2, :].mean()
sensor_temp_cache_3 =temp_cache[: 3, :].mean()
sensor_temp_cache_4 =temp_cache[: 4, :].mean()
sensor_temp_cache_5 =temp_cache[: 5, :].mean()
sensor_temp_cache_6 =temp_cache[: 6, :].mean()
sensor_temp_cache_7 =temp_cache[: 7, :].mean()
sensor_temp_cache_8 =temp_cache[: 8, :].mean()
sensor_temp_cache_9 =temp_cache[: 9, :].mean()
sensor_temp_cache_10=temp_cache[:,10, :].mean()
xpoints_eeg = [5, 10, 15,  20, 25, 30, 35, 40,  45, 50]
ypoints_eeg = [sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10]
plt.plot(xpoints_eeg,ypoints_eeg, 'g-o')
plt.yticks([0,1, 2, 3,4,5,6,7,8,9,10])
plt.xticks([5, 10, 15,  20, 25, 30, 35, 40, 45, 50])
plt.xlabel('Nodes')
plt.ylabel('Number of heated nodes')
plt.legend(['Q Learning '])
plt.show()

"""![heated.png](data:image/png;base64,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)

#Episode
"""

import matplotlib.pyplot as plt
sensor_rewards_1 =rewards[0:1000, :, :].mean()
sensor_rewards_2 =rewards[0:2000, :, :].mean()
sensor_rewards_3 =rewards[0:3000, :, :].mean()
sensor_rewards_4 =rewards[0:4000, :, :].mean()
sensor_rewards_5 =rewards[0:5000, :, :].mean()
sensor_rewards_6 =rewards[0:6000, :, :].mean()
sensor_rewards_7 =rewards[0:7000, :, :].mean()
sensor_rewards_8 =rewards[0:8000, :, :].mean()
sensor_rewards_9 =rewards[0:9000, :, :].mean()
sensor_rewards_10=rewards[0:10000, :, :].mean()
xpoints_episode = [0,1000 , 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000]
ypoints_episode =[sensor_temp_cache_1 ,sensor_temp_cache_2 ,sensor_temp_cache_3 ,sensor_temp_cache_4 ,sensor_temp_cache_5 ,sensor_temp_cache_6 ,sensor_temp_cache_7 ,sensor_temp_cache_8 ,sensor_temp_cache_9 ,sensor_temp_cache_10]
plt.plot(xpoints_episode,ypoints_episode, 'g-o')
plt.yticks([-1, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
plt.xticks([0, 2000, 4000,  6000, 8000, 10000])
plt.xlabel('Episode')
plt.ylabel('Average Reward')
plt.legend(['Q Learning '])
plt.show()

"""![episode.png](data:image/png;base64,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)"""